<!DOCTYPE html>
<meta charset=utf-8>
<title>La progettazione di applicazioni - Programmare in Scala</title>
<link rel=stylesheet href=styles.css>
<style>
body{counter-reset:h1 13}
</style>
<script>_gaq=[['_setAccount','UA-10482652-1'],['_trackPageview']];(function(){var g=document.createElement('script');g.src='//www.google-analytics.com/ga.js';g.setAttribute('async','true');document.documentElement.firstChild.appendChild(g);})();</script>

<div id=book>
<p>Voi siete qui: <a href=index.html>Inizio</a> <span class=u>&#8227;</span> <a href=indice.html#cap-13>Programmare in Scala</a> <span class=u>&#8227;</span>

<h1>La progettazione di applicazioni</h1>

<p>In questo capitolo, esamineremo in modo pragmatico lo sviluppo di applicazioni in Scala. Analizzeremo alcune caratteristiche del linguaggio e della API di cui non abbiamo parlato prima, esamineremo i pattern di progettazione e gli idiomi comuni e rivisteremo i <em>tratti</em> con un occhio verso la strutturazione efficace del nostro codice.

<h2 id=Annotations>Annotazioni</h2>

<p>Come Java e .NET, Scala supporta le <em>annotazioni</em> per aggiungere <em>metadati</em> alle dichiarazioni. Le annotazioni sono usate da una varietà di strumenti nelle tipiche applicazioni aziendali e di rete. Per esempio, ci sono annotazioni che forniscono direttive al compilatore e alcuni framework <abbr>ORM</abbr> (Object-Relational Mapping <span class=wtf>&hellip;</span>) usano le annotazioni sui tipi e sui loro membri per indicare informazioni sulla mappatura della persistenza. Mentre alcuni usi per le annotazioni in Java e .NET possono essere compiuti attraverso altri mezzi in Scala, le annotazioni possono rivelarsi essenziali per interoperare con le librerie Java e .NET che ne fanno largo uso. Fortunatamente, le annotazioni Java e .NET possono essere usate nel codice Scala.

<p>L'interpretazione delle annotazioni Scala dipende dall'ambiente a tempo di esecuzione. In questa sezione, ci concentreremo sull'ambiente del <abbr>JDK</abbr>.

<p>In Java, le annotazioni sono dichiarate usando convenzioni particolari, come per esempio dichiarando le annotazioni con la parola chiave <code>@interface</code> anziché <code>class</code> o <code>interface</code>. Ecco la dichiarazione di un'annotazione presa dalla libreria Contract4J <a href=apa.html#Contract4J>[Contract4J]</a> che usa le annotazioni per supportare la <em>progettazione per contratto</em> in Java (si veda anche la sezione <a href=#DesignByContractExample>Una progettazione migliore con la progettazione per contratto</a> più avanti). Alcuni commenti sono stati rimossi e i rimanenti tradotti, per chiarezza.

<pre><code>// <a href=esempi/cap-13/Pre.java>esempi/cap-13/Pre.java</a>

package org.contract4j5.contract;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER, ElementType.METHOD, ElementType.CONSTRUCTOR})
public @interface Pre {
  /**
   * Il "valore" è l'espressione di test, che deve essere valutata a true o false.
   * Deve essere un'espressione valida nel linguaggio di scripting che state usando.
   */
  String value() default "";

  /**
   * Un messaggio opzionale da stampare insieme al messaggio standard stampato
   * quando il contratto non viene rispettato.
   */
  String message() default "";
}</code></pre>

<p>L'annotazione <code>@Pre</code> viene usata per specificare le &#8220;precondizioni&#8221; che devono essere soddisfatte quando si <em>entra</em> in un metodo o in un costruttore, o <em>prima</em> di usare un parametro passato a un metodo o a un costruttore. Le condizioni vengono specificate sotto forma di una stringa che in realtà è una porzione di codice sorgente valutabile come <code>true</code> o <code>false</code>. I <em>linguaggi</em> sorgente supportati per questi frammenti sono linguaggi di scripting come Groovy e JRuby. Il nome della variabile per questa stringa, <code>value</code>, è un nome convenzionale per il campo più importante nell'annotazione.

<p>L'altro campo, <code>message</code>, è un messaggio opzionale da usare quando viene presentato un fallimento.

<p>Alla dichiarazione vengono applicate altre annotazioni; per esempio, l'annotazione <code>@Retention</code> con il valore <code>RetentionPolicy.RUNTIME</code> significa che quando <code>@Pre</code> viene usata, le sue informazioni verranno conservate nel file di classe per essere usate a tempo di esecuzione.

<p>Ecco un esempio in Scala che usa <code>@Pre</code> e mostra diversi modi di specificare i parametri <code>value</code> e <code>message</code>.

<pre><code>// <a href=esempi/cap-13/pre-example.scala>esempi/cap-13/pre-example.scala</a>

import org.contract4j5.contract._

class Person(
  @Pre( "name != null &amp;&amp; name.length() &gt; 0" )
  val name: String,
  @Pre{ val value = "age &gt; 0", val message = "Sei troppo giovane!" }
  val age: Int,
  @Pre( "ssn != null" )
  val ssn: SSN)

class SSN(
  @Pre( "valid(ssn)" ) { val message = "Il formato deve essere NNN-NN-NNNN." }
  val ssn: String) {

  private def valid(value: String) =
    value.matches("""^\s*\d{3}-\d{2}-\d{4}\s*$""")
}</code></pre>

<p>Nella classe <code>Person</code>, l'annotazione <code>@Pre</code> prende come argomento una semplice stringa: la &#8220;precondizione&#8221; che gli utenti devono soddisfare quando passano un nome. Questo valore non può essere <code>null</code> e non può essere di lunghezza zero. Come in Java, se all'annotazione viene passato un singolo argomento, questo viene assegnato al campo <code>value</code>.

<p>Una simile annotazione <code>@Pre</code> è usata per il terzo argomento <code>ssn</code>, il numero di previdenza sociale. In entrambi i casi, al campo <code>message</code> viene assegnata una stringa vuota, specificato come valore predefinito nella definizione di <code>Pre</code>.

<p>L'annotazione <code>@Pre</code> per l'età mostra un possibile modo di specificare valori per più di un campo, usando le parentesi graffe anziché le parentesi tonde. La sintassi per ogni campo somiglia a una dichiarazione <code>val</code>, ma senza alcuna informazione di tipo, in quanto i tipi possono sempre essere inferiti! Questa sintassi vi permette di usare la sintassi abbreviata per <code>value</code> e specificare comunque i valori per gli altri campi.

<blockquote class=note>
<p><span class=u>&#x261E;</span>Se <code>Person</code> fosse una classe Java, l'espressione per questa annotazione sarebbe identica, a parte il fatto che non ci sarebbe alcuna parola chiave <code>val</code> e che verrebbero usate le parentesi tonde.
</blockquote>

<p>L'annotazione <code>@Pre</code> sul parametro del costruttore della classe <code>SSN</code> mostra la sintassi alternativa per specificare i valori per più di un campo. Il campo <code>value</code> viene specificato come prima con una lista di parametri di un elemento; il campo <code>message</code> viene inizializzato in un blocco conseguente racchiuso tra parentesi graffe.

<p>Per collaudare questo script sarebbero necessari alcuni passi di installazione di Contract4J e di configurazione per l'ambiente che non mostreremo. Fate riferimento a <a href=apa.html#Contract4J>[Contract4J]</a> per maggiori informazioni.

<p>Le annotazioni Scala non usano una sintassi speciale per le dichiarazioni, ma vengono dichiarate come normali classi. Questo approccio elimina un &#8220;caso speciale&#8221; nel linguaggio, ma significa anche che alcune delle caratteristiche offerte dalle annotazioni Java non sono supportate, come vedremo. Ecco un'annotazione di esempio dalla libreria Scala, <code>SerialVersionUID</code> (ancora una volta con i commenti rimossi, per chiarezza).

<pre><code>package scala

class SerialVersionUID(uid: Long) extends StaticAnnotation</code></pre>

<p>L'annotazione <code>@SerialVersionUID</code> viene applicata a una classe per definire un identificatore unico globale sotto forma di numero <code>Long</code>. Quando si usa questa annotazione, l'identificatore viene specificato come un argomento del costruttore. Questa annotazione serve allo stesso scopo del campo <code>static</code> chiaamto <code>serialVersionUID</code> in una classe Java. Questo è un esempio di un'annotazione Scala che corrisponde a un costrutto Java che non è un'annotazione.

<p>Il genitore di <code>SerialVersionUID</code> è il tratto <code>scala.StaticAnnotation</code>, che viene usato come genitore per tutte le annotazioni che dovrebbero essere visibili al controllore di tipo, anche attraverso le unità di compilazione. La classe genitore di <code>scala.StaticAnnotation</code> è <code>scala.Annotation</code>, che è il genitore di tutte le annotazioni Scala.

<p>Avete notato che non c'è alcuna parola chiave <code>val</code> nella dichiarazione del parametro <code>uid</code>? Come mai <code>uid</code> non è un campo? Il motivo è che il dato dell'annotazione non è destinato a essere usato dal programma, bensì è un metadato pensato per essere usato da strumenti esterni come <kbd>scalac</kbd>. Questo significa anche che le annotazioni Scala non hanno alcun modo di definire valori nelle versioni 2.7.X, in quanto gli argomenti impliciti non funzionano. Tuttavia, gli argomenti predefiniti introdotti nella versione 2.8.0  potrebbero funzionare (non sono ancora stati implementati al momento della scrittura, quindi non ci è stato possibile verificare).

<p>Come per le annotazioni Java (e .NET), la clausola che contiene un'annotazione Scala viene applicata alla definizione che precede. Potete avere tutte le clausole che volete, e l'ordine in cui compaiono non è significativo.

<p>Come per le annotazioni Java, le clausole che contengono un'annotazione Scala vengono scritte usando la sintassi <code>@Annotazione</code>, se il costruttore dell'annotazione non accetta parametri, oppure <code>@Annotazione(arg1, &hellip;, argN)</code>, se il costruttore accetta un numero N di parametri. L'annotazione deve essere una sottoclasse di <code>scala.Annotation</code>.

<p>Tutti i parametri del costruttore devono essere espressioni costanti, comprese stringhe, letterali classe, enumerazioni Java, espressioni numeriche e array monodimensionali di questi tipi. Tuttavia, il compilatore permette di usare anche clausole di annotazione con altri argomenti, come valori booleani e <span class=wtf>mappe</span>, come mostrato in questo esempio.

<pre><code>// <a href=esempi/cap-13/anno-example.scala>esempi/cap-13/anno-example.scala</a>

import scala.StaticAnnotation

class Persist(tableName: String, params: Map[String,Any])
  extends StaticAnnotation

// Non viene compilato:
// @Persist("ACCOUNTS", Map("dbms" -&gt; "MySql", "writeAutomatically" -&gt; true))
@Persist("ACCOUNTS", Map(("dbms", "MySql"), ("writeAutomatically", true)))
class Account(val balance: Double)</code></pre>

<p>Stranamente, se tentate di usare la normale sintassi per i letterali <code>Map</code> mostrata nel commento, ottenete un errore di compilazione che lamenta la mancanza del metodo <code>-&gt;</code> nella classe <code>String</code>. La conversione implicita verso <code>ArrowAssoc</code> che abbiamo esaminato nella sezione <a href=cap-7.html#PredefObject>L'oggetto <code>Predef</code></a> nel capitolo 7 non viene invocata, e quindi dovete usare una lista di oggetti <code>Tuple</code>, che è quanto <code>Map.apply</code> si aspetta realmente.

<p>Un altro figlio di <code>scala.Annotation</code> progettato per essere esteso da altre annotazioni è il tratto <code>scala.ClassfileAnnotation</code>. Esso viene usato per le annotazioni che dovrebbero essere conservate a tempo di esecuzione, cioè che dovrebbero essere visibili nel file di classe in modo da essere disponibili a tempo di esecuzione. Tuttavia, se lo usate con la versione di Scala per il <abbr>JDK</abbr> otterrete errori di compilazione come quello che segue.

<pre><samp>&hellip;: warning: implementation restriction: subclassing Classfile does not
            make your annotation visible at runtime.  If that is what
            you want, you must write the annotation class in Java.
&hellip;</samp></pre>

<p>Perciò, se desiderate la visibilità a tempo di esecuzione, dovete implementare l'annotazione in Java. Questo non crea problemi, dato che potete usare qualsiasi annotazione Java nel codice Scala. Attualmente la libreria Scala non definisce annotazioni derivate da <code>ClassfileAnnotation</code>, forse per ovvie ragioni.

<blockquote class=warning>
<p><span class=u>&#x2762;</span>Evitate <code>ClassfileAnnotation</code> e implementate in Java le annotazioni che richiedono di essere conservate a tempo di esecuzione.
</blockquote>

<p>Per le versioni 2.7.X di Scala è necessario tenere presente un'altra importante limitazione: le annotazioni non possono essere annidate. Questo crea problemi quando usate annotazioni JPA nel codice Scala, come discusso in <a href=apa.html#JPAScala>[JPAScala]</a>. Tuttavia, la versione 2.8 di Scala rimuove questa limitazione.

<blockquote class=warning>
<p><span class=u>&#x2762;</span>Le annotazioni possono essere annidate solo in Scala 2.8.
</blockquote>

<p>La tabella seguente (adattata ed estesa da <a class=url href="http://www.scala-lang.org/node/106">http://www.scala-lang.org/node/106</a>) descrive tutte le annotazioni definite nella libreria Scala, partendo dai figli diretti di <code>Annotation</code> e proseguendo con i figli di <code>StaticAnnotation</code>.

<div class=table id=scala-annotations>
<p class=tt>Tabella 13.1. Le annotazioni Scala derivate da <code>Annotation</code>.
<table summary="Le annotazioni Scala derivate da Annotation." border=0>
<colgroup>
<col align="left">
<col align="left">
<col align="left">
</colgroup>
<thead valign="top"><tr>
<th align="left" valign="top">Nome
<th align="left" valign="top">Equivalente Java
<th align="left" valign="top">Descrizione
</thead>
<tbody valign="top">
<tr>
<td align="left" valign="top"><p><code>ClassfileAnnotation</code>
<td align="left" valign="top"><p>Annotazione con <code>@Retention(RetentionPolicy.RUNTIME)</code>
<td align="left" valign="top"><p>Il tratto genitore per le annotazioni che dovrebbero essere conservate nel file di classe per l'accesso a tempo di esecuzione, ma in realtà non funziona con il <abbr>JDK</abbr>!
<tr>
<td align="left" valign="top"><p><code>BeanDescription</code>
<td align="left" valign="top"><p><code>BeanDescriptor</code> (classe)
<td align="left" valign="top"><p>Un'annotazione per i componenti <em>JavaBeans</em> che associa a un tipo o a un membro una breve descrizione (fornita come argomento all'annotazione) che verrà inclusa tra le informazioni generate per il componente.
<tr>
<td align="left" valign="top"><p><code>BeanDisplayName</code>
<td align="left" valign="top"><p><code>BeanDescriptor</code> (classe)
<td align="left" valign="top"><p>Un'annotazione per i componenti <em>JavaBeans</em> che associa a un tipo o a un membro un nome (fornito come argomento all'annotazione) che verrà incluso tra le informazioni generate per il componente.
<tr>
<td align="left" valign="top"><p><code>BeanInfo</code>
<td align="left" valign="top"><p><code>BeanInfo</code> (classe)
<td align="left" valign="top"><p>Un marcatore usato per indicare che una classe <code>BeanInfo</code> dovrebbe essere generata per la classe Scala marcata. Una dichiarazione <code>val</code> diventa una proprietà a sola lettura; una dichiarazione <code>var</code> diventa una proprietà a lettura e scrittura; una dichiarazione <code>def</code> diventa un metodo.
<tr>
<td align="left" valign="top"><p><code>BeanInfoSkip</code>
<td align="left" valign="top"><p><em>nessuno</em>
<td align="left" valign="top"><p>Un marcatore usato per indicare che le informazioni del componente non dovrebbero essere generate per il membro annotato.
<tr>
<td align="left" valign="top"><p><code>StaticAnnotation</code>
<td align="left" valign="top"><p>Campi statici, <code>@Target(ElementType.TYPE)</code>
<td align="left" valign="top"><p>Il tratto genitore per le annotazioni che dovrebbero essere visibili attraverso le unità di compilazioni e definire metadati &#8220;statici&#8221;.
<tr>
<td align="left" valign="top"><p><code>TypeConstraint</code>
<td align="left" valign="top"><p><em>nessuno</em>
<td align="left" valign="top"><p>Un tratto che può essere applicato come annotazione ad altre annotazioni che definiscono vincoli su un tipo, basandosi solo sulle informazioni definite all'interno del tipo stesso anziché su informazioni esterne relative al contesto in cui il tipo viene definito o usato. Il compilatore può sfruttare questa restrizione per riscrivere il vincolo. Attualmente la libreria Scala non contiene annotazioni che usano questo tratto.
<tr>
<td align="left" valign="top"><p><code>unchecked</code>
<td align="left" valign="top"><p><em>nessuno</em>
<td align="left" valign="top"><p>Un marcatore da applicare al selettore in una istruzione di pattern matching (per esempio, la <code>x</code> in <code>x match {&hellip;}</code>) che omette un messaggio di warning del compilatore nel caso in cui le clausole <code>case</code> non siano &#8220;esaustive&#8221;. Un errore di tipo <code>MatchError</code> può ancora avvenire a tempo di esecuzione se non esiste alcuna corrispondenza per un valore di <code>x</code> nelle clausole <code>case</code>. Si veda l'esempio più avanti.
<tr>
<td align="left" valign="top"><p><code>unsealed</code>
<td align="left" valign="top"><p><em>nessuno</em>
<td align="left" valign="top"><p>Deprecata, usate <code>@unchecked</code> al suo posto.
</tbody>
</table>
</div>

<p>&nbsp;

<div class=table id=scala-static-annotations>
<p class=tt>Tabella 13.2. Le annotazioni Scala derivate da <code>StaticAnnotation</code>.
<table summary="Le annotazioni Scala derivate da StaticAnnotation." border=0>
<colgroup>
<col align="left">
<col align="left">
<col align="left">
</colgroup>
<thead valign="top"><tr>
<th align="left" valign="top">Nome
<th align="left" valign="top">Equivalente Java
<th align="left" valign="top">Descrizione
</thead>
<tbody valign="top">
<tr>
<td align="left" valign="top"><p><code>BeanProperty</code>
<td align="left" valign="top"><p>Convenzioni <em>JavaBeans</em>
<td align="left" valign="top"><p>Un marcatore applicabile ai campi (compresi gli argomenti del costruttore con una parola chiave <code>val</code> o <code>var</code>) che induce il compilatore a generare metodi di &#8220;lettura&#8221; e &#8220;scrittura&#8221; nello stile <em>JavaBeans</em>. Il metodo di scrittura viene generato solo per le dichiarazioni <code>var</code>. Si veda in merito la disamina nella sezione <a href=cap-14.html#JavaBeanProperties>Proprietà JavaBeans</a> del capitolo 14.
<tr>
<td align="left" valign="top"><p><code>cloneable</code>
<td align="left" valign="top"><p><code>java.lang.Cloneable</code> (interfaccia)
<td align="left" valign="top"><p>Un marcatore per indicare che una classe può essere clonata.
<tr>
<td align="left" valign="top"><p><code>cps</code>
<td align="left" valign="top"><p><em>nessuno</em>
<td align="left" valign="top"><p>Genera il bytecode usando un <span class=wtf>continuation passing style</span> (versione 2.8).
<tr>
<td align="left" valign="top"><p><code>deprecated</code>
<td align="left" valign="top"><p><code>java.lang.Deprecated</code>
<td align="left" valign="top"><p>Un marcatore applicabile a qualsiasi definizione per indicare che l'elemento definito è obsoleta. Il compilatore genererà un messaggio di warning quando l'elemento viene usato.
<tr>
<td align="left" valign="top"><p><code>inline</code>
<td align="left" valign="top"><p><em>nessuno</em>
<td align="left" valign="top"><p>Un marcatore applicabile ai metodi che chiede al compilatore di impegnarsi &#8220;molto duramente&#8221; a <span class=wtf>inline</span> il metodo.
<tr>
<td align="left" valign="top"><p><code>native</code>
<td align="left" valign="top"><p><code>native</code> (parola chiave)
<td align="left" valign="top"><p>Un marcatore per indicare che il metodo è implementato come codice &#8220;nativo&#8221;. Il corpo del metodo non verrà generato dal compilatore, ma il controllo di tipo sulle invocazioni del metodo verrà comunque effettuato.
<tr>
<td align="left" valign="top"><p><code>noinline</code>
<td align="left" valign="top"><p><em>nessuno</em>
<td align="left" valign="top"><p>Un marcatore applicabile ai metodi usato per impedire al compilatore di <span class=wtf>inline</span> il metodo anche quando questa operazione sembra innocua.
<tr>
<td align="left" valign="top"><p><code>remote</code>
<td align="left" valign="top"><p><code>java.rmi.Remote</code> (interfaccia)
<td align="left" valign="top"><p>Un marcatore usato per indicare che la classe può essere invocata da una <abbr>JVM</abbr> remota.
<tr>
<td align="left" valign="top"><p><code>serializable</code>
<td align="left" valign="top"><p><code>java.io.Serializable</code> (interfaccia)
<td align="left" valign="top"><p>Un marcatore usato per indicare che la classe può essere serializzata.
<tr>
<td align="left" valign="top"><p><code>SerialVersionUID</code>
<td align="left" valign="top"><p>Un campo <em>statico</em> <code>serialVersionUID</code> in una classe
<td align="left" valign="top"><p>Definisce un identificatore unico globale ai fini della serializzazione. Il costruttore dell'annotazione accetta un numero <code>Long</code> come argomento per rappresentare l'identificatore unico.
<tr>
<td align="left" valign="top"><p><code>switch</code>
<td align="left" valign="top"><p><em>nessuno</em>
<td align="left" valign="top"><p>Un'annotazione da applicare a un'espressione di pattern matching, come per esempio <code>(x: @switch) match {&#8230;}</code>. Quando è presente, il compilatore verificherà che il costrutto sia stato compilato in una istruzione <code>switch</code> basata su tabella o <span class=wtf>lookup-based</span>, generando un errore se il costrutto è stato compilato in una serie di espressioni condizionali, che sono meno efficienti. Disponibile solo a partire da Scala 2.8.
<tr>
<td align="left" valign="top"><p><code>specialized</code>
<td align="left" valign="top"><p><em>nessuno</em>
<td align="left" valign="top"><p>Un'annotazione da applicare ai parametri di tipo nei tipi e nei metodi parametrici. Induce il compilatore a generare versioni ottimizzate del tipo o del metodo per i tipi <code>AnyVal</code> corrispondenti ai tipi primitivi della piattaforma. Opzionalmente, è possibile limitare i tipi <code>AnyVal</code> per i quali verranno generate le implementazioni specializzate (si veda più avanti per una discussione in merito). Disponibile solo a partire da Scala 2.8.
<tr>
<td align="left" valign="top"><p><code>tailRec</code>
<td align="left" valign="top"><p><em>nessuno</em>
<td align="left" valign="top"><p>Un'annotazione applicabile ai metodi per indurre il compilatore a verificare che il metodo sia stato compilato con la <em class=wtf>tail call optimization</em>. Quando è presente, il compilatore genererà un errore se il metodo non può essere ottimizzato in un ciclo. Questo può succedere, per esempio, quando il metodo è qualificato come <code>private</code> o <code>final</code>, può essere ridefinito, e quando le invocazioni ricorsive non sono realmente le ultime istruzioni del metodo. Disponibile solo a partire da Scala 2.8.
<tr>
<td align="left" valign="top"><p><code>throws</code>
<td align="left" valign="top"><p><code>throws</code> (parola chiave)
<td align="left" valign="top"><p>Indica quali eccezioni vengono lanciate dal metodo annotato (si veda la discussione più avanti).
<tr>
<td align="left" valign="top"><p><code>transient</code>
<td align="left" valign="top"><p><code>transient</code> (parola chiave)
<td align="left" valign="top"><p>Contrassegna un metodo come &#8220;transitorio&#8221;.
<tr>
<td align="left" valign="top"><p><code>uncheckedStable</code>
<td align="left" valign="top"><p><em>nessuno</em>
<td align="left" valign="top"><p>Un marcatore applicabile a un valore che si suppone stabile anche se il suo tipo è volatile (cioè annotato con <code>@volatile</code>).
<tr>
<td align="left" valign="top"><p><code>uncheckedVariance</code>
<td align="left" valign="top"><p><em>nessuno</em>
<td align="left" valign="top"><p>Un marcatore applicato a un argomento di tipo che è volatile, quando è usato in un tipo parametrico, per omettere il controllo della varianza.
<tr>
<td align="left" valign="top"><p><code>volatile</code>
<td align="left" valign="top"><p><code>volatile</code> (parola chiave, solo per i campi)
<td align="left" valign="top"><p>Un marcatore applicabile a un singolo campo (o a un intero tipo, nel qual caso ha effetto su tutti i suoi campi) per indicare che il campo può essere modificato da un altro thread.
</tbody>
</table>
</div>

<p>Tra le annotazioni disponibili solo a partire dalla versione 2.8 di Scala, considerate <code>@tailRec</code>, usata nell'esempio seguente.

<pre><code>import scala.annotation.tailrec

@tailrec
def fib(i: Int): Int = i match {
  case _ if i &lt;= 1 =&gt; i
  case _ =&gt; fib(i-1) + fib(i-2)
}
println(fib(5))</code></pre>

<p>Notate che <code>fib</code> effettua il calcolo dei numeri di Fibonacci in maniera ricorsiva, ma la funzione non è ricorsiva in coda perché l'invocazione a sé stessa non è l'ultima operazione eseguita nella seconda clausola <code>case</code>; infatti, dopo essersi richiamata due volte, la funzione esegue una somma. Perciò, una <span class=wtf>tail call optimization</span> non può essere effettuata su questo metodo, e quando il compilatore vede l'annotazione <code>@tailrec</code> genera un errore informandoci di non poter applicare l'ottimizzazione. Il tentativo di eseguire questo script produce l'errore seguente.

<pre><samp>&hellip; 4: error: could not optimize @tailrec annotated method
def fib(i: Int): Int = i match {
     ^
one error found</samp></pre>

<p>Possiamo usare lo stesso metodo per dimostrare la nuova annotazione <code>@switch</code> disponibile in Scala 2.8.

<pre><code>import scala.annotation.switch

def fib(i: Int): Int = (i: @switch) match {
  case _ if i &lt;= 1 =&gt; i
  case _ =&gt; fib(i-1) + fib(i-2)
}
println(fib(5))</code></pre>

<p>Questa volta annotiamo la variabile <code>i</code> nell'istruzione <code>match</code>. Questa annotazione induce il compilatore a generare un errore nel caso non sia in grado di generare un costrutto <code>switch</code> nel bytecode a partire dai casi dell'istruzione <code>match</code>. In genere, i costrutti <code>switch</code> sono più efficienti rispetto alle espressioni condizionali. L'esecuzione di questo script produce l'uscita seguente.

<pre><samp>&hellip; 3: error: could not emit switch for @switch annotated match
def fib(i: Int): Int = (i: @switch) match {
                                     ^
one error found</samp></pre>

<p>Evidentemente è necessario generare blocchi condizionali anziché un costrutto <code>switch</code>, a causa della guardia <code>if i &lt;= 1</code> che abbiamo inserito nella prima clausola <code>case</code>.

<p>Diamo ora un'occhiata a un esempio di <code>@unchecked</code> in azione, adattato dalla pagina <em>Scaladoc</em> relativa a questa annotazione. Considerate il seguente frammento di codice.

<pre><code>&hellip;
def process(x: Option[int]) = x match {
  case Some(value) =&gt; &hellip;
}
&hellip;</code></pre>

<p>Se provate a compilarlo, otterrete il seguente messaggio di warning.

<pre><samp>&hellip;: warning: does not cover case {object None}
  def f(x: Option[int]) = x match {
                          ^
one warning found</samp></pre>

<p>Normalmente vorreste aggiungere una clausola <code>case</code> per <code>None</code>. Tuttavia, se volete che il compilatore ometta i messaggi di warning in situazioni come queste, modificate il metodo nel modo seguente.

<pre><code>&hellip;
def process(x: Option[int]) = (x: @unchecked) match {
  case Some(value) =&gt; &hellip;
}
&hellip;</code></pre>

<p>Grazie all'annotazione <code>@unchecked</code> applicata a <code>x</code> come mostrato, il messaggio di warning non verrà emesso. Tuttavia, se <code>x</code> dovesse mai valere <code>None</code>, allora verrà lanciato un errore di tipo <code>MatchError</code>.

<p>L'annotazione <code>@specialized</code> è un'altra delle annotazioni relative all'ottimizzazione aggiunte nella versione 2.8 di Scala e rappresenta una soluzione pratica di compromesso tra l'efficienza nello spazio e le prestazioni. In Java e in Scala l'implementazione di un tipo o un metodo parametrico viene generata nel punto della dichiarazione (come abbiamo detto nella sezione <a href=cap-12.html#ParameterizedTypes>Capire i tipi parametrici</a> del capitolo 12, a differenza di quanto accade in C++, dove viene usato un <em>template</em> per generare l'implementazione dei reali parametri di tipo nei punti in cui il template viene usato. L'approccio del C++ ha il vantaggio di permettere la generazione di implementazioni ottimizzate per i tipi primitivi, mentre ha lo svantaggio di risultare in <span class=wtf>code bloat</span> a causa di tutte le istanziazioni dei template.

<p>La generazione di implementazioni &#8220;a richiesta&#8221; non è adatta ai linguaggi per la <abbr>JVM</abbr>, principalmente a causa della mancanza di un passo di &#8220;collegamento&#8221; come nei linguaggi compilati, durante il quale possono essere determinate le istanziazioni richieste di un template. Questo crea un dilemma. Di solito, un tipo o un metodo parametrico Scala verrà tradotto in una singola implementazione usando <code>Any</code> per i parametri di tipo (in parte a causa della cancellazione di tipo a livello di bytecode). I generici Java funzionano allo stesso modo. Tuttavia, se il tipo o il metodo vengono usati con uno dei tipi <code>AnyVal</code>, per esempio <code>Int</code>, l'implementazione sarà penalizzata da operazioni inefficienti di <span class=wtf>boxing</span> e <span class=wtf>unboxing</span>.

<p>L'alternativa sarebbe generare un'implementazione separata per ogni <code>AnyVal</code> corrispondente a un tipo primitivo, ma questo condurrebbe al <span class=wtf>code bloat</span>, soprattutto perché sarebbe raro che un'applicazione usi tutte quelle implementazioni. Quindi, dobbiamo affrontare un dilemma.

<p>L'annotazione <code>@specialized</code> rappresenta un pratico compromesso: permette all'utente di segnalare al compilatore che l'efficienza a tempo di esecuzione è più importante dell'efficienza in termini di spazio, inducendolo quindi a generare le implementazioni separate per ogni tipo primitivo corrispondente a <code>AnyVal</code>. Qui di seguito riportiamo un esempio di come usare l'annotazione.

<pre><code>class SpecialCollection[@specialized +T](&hellip;) {
  &hellip;
}</code></pre>

<p>Al momento della scrittura, l'implementazione degli assemblaggi &#8220;notturni&#8221; di Scala 2.8 supporta solo la generazione di implementazioni specializzate per <code>Int</code> e <code>Double</code>, ma per il rilascio finale della versione 2.8 si prevede di supportare anche gli altri tipi derivati da <code>AnyVal</code>. Si pianifica anche di permettere all'utente di specificare i tipi per i quali richiedere la generazione delle implementazioni ottimizzate, in modo da evitare di ritrovarsi con implementazioni inutilizzate per qualche <code>AnyVal</code>. Si veda la documentazione <em>Scaladoc</em> della versione 2.8 finale per i dettagli sull'insieme di caratteristiche finale.

<p>Un'altra annotazione prevista per la versione 2.8 è <code>@cps</code>, che sta per <em class=wtf>continuation passing style</em>. Sarà una direttiva interpretata da un plug-in del compilatore che attiverà la generazione di bytecode basato sulle continuazioni per le invocazioni dei metodi al posto del bytecode predefinito basato su un modello a pila. L'annotazione non avrà effetto a meno che venga usato il corrispondente plug-in di <kbd>scalac</kbd>. Consultate la documentazione del rilascio per maggiori informazioni su questa funzione non appena diverrà disponibile.

<p>Per comprendere l'annotazione <code>@throws</code> è importante ricordare che Scala, a differenza di Java, non dispone di eccezioni controllate, né di una clausola <code>throws</code> per le dichiarazioni di metodo. Questo non costituisce un problema nel caso in cui un metodo Scala invochi un metodo Java che dichiara di lanciare un'eccezione controllata, in quanto Scala tratterà questa eccezione come non controllata. Tuttavia, supponete che il metodo Scala in questione non catturi l'eccezione ma la lasci passare: cosa succede se questo metodo Scala viene invocato da altro codice Java?

<p>Diamo un'occhiata a un esempio riguardante <code>java.io.IOException</code>, che è un'eccezione controllata. La classe Scala riportata di seguito stampa il contenuto di un <code>java.io.File</code>.

<pre><code>// <a href=esempi/cap-13/file-printer.scala>esempi/cap-13/file-printer.scala</a>

import java.io._

class FilePrinter(val file: File) {

  @throws(classOf[IOException])
  def print() = {
    var reader: LineNumberReader = null
    try {
      reader = new LineNumberReader(new FileReader(file))
      loop(reader)
    } finally {
      if (reader != null)
        reader.close
    }
  }

  private def loop(reader: LineNumberReader): Unit = {
    val line = reader.readLine()
    if (line != null) {
      format("%3d: %s\n", reader.getLineNumber, line)
      loop(reader)
    }
  }
}</code></pre>

<p>L'annotazione <code>@throws</code> è applicata al metodo <code>print</code> e l'argomento del suo costruttore è un singolo oggetto <code>java.lang.Class[Any]</code>, in questo caso <code>classOf[IOException]</code>. I metodi della <abbr>API</abbr> Java di I/O usati da <code>print</code> e il metodo privato <code>loop</code> potrebbero lanciare questa eccezione.

<p><span class=wtf>By the way</span>, notate che <code>loop</code> usa una ricorsione in coda in stile funzionale anziché un ciclo. Nessuna variabile è stata modificata nella produzione di questa uscita! (A dire il vero, non sappiamo cosa succeda realmente all'interno delle classi di I/O di Java&hellip;)

<pre><code>// <a href=esempi/cap-13/FilePrinterMain.java>esempi/cap-13/FilePrinterMain.java</a>

import java.io.*;

public class FilePrinterMain {
  public static void main(String[] args) {
    for (String fileName: args) {
      try {
        File file = new File(fileName);
        new FilePrinter(file).print();
      } catch (IOException ioe) {
        System.err.println("IOException per il file " + fileName);
        System.err.println(ioe.getMessage());
      }
    }
  }
}</code></pre>

<p>Queste classi vengono compilate senza errori. Potete provare a eseguirle tramite il comando seguente (supponendo che <span class=file>FilePrinterMain.java</span> si trovi nella directory <span class=file>annotations</span>, come accade nella distribuzione degli esempi di codice).

<pre><samp>scala -cp build FilePrinterMain annotations/FilePrinterMain.java</samp></pre>

<p>Dovreste ottenere l'uscita seguente.

<pre><samp> 1: import java.io.*;
 2:
 3: public class FilePrinterMain {
 4:   public static void main(String[] args) {
 5:     for (String fileName: args) {
 6:       try {
 7:         File file = new File(fileName);
 8:         new FilePrinter(file).print();
 9:       } catch (IOException ioe) {
10:         System.err.println("IOException per il file " + fileName);
11:         System.err.println(ioe.getMessage());
12:       }
13:     }
14:   }
15: }</samp></pre>

<p>Ora, tornando alla classe <code>FilePrinter</code>, supponete di nascondere in un commento la riga che contiene l'annotazione <code>@throws</code>. Il file continuerà a venire compilato, ma quando compilate <span class=file>FilePrinterMain.java</span> otterrete l'errore seguente.

<pre><samp>annotations/FilePrinterMain.java:9: exception java.io.IOException is never
thrown in body of corresponding try statement
      } catch (IOException ioe) {
        ^
1 error</samp></pre>

<p>Sebbene <code>java.io.Exception</code> possa essere lanciata da <code>FilePrinter</code>, questa informazione non si trova nel bytecode generato da <kbd>scalac</kbd>, quindi l'analisi compiuta da <kbd>javac</kbd> conclude erroneamente che <code>IOException</code> non venga mai lanciata.

<p>Lo scopo di <code>@throws</code>, quindi, è quello di inserire l'informazione sulle eccezioni controllate che possono essere lanciate nel bytecode che verrà letto da <kbd>javac</kbd>.

<blockquote class=note>
<p><span class=u>&#x261E;</span>In un ambiente misto Java/Scala, considerate l'ipotesi di aggiungere l'annotazione <code>@throws</code> a tutti i vostri metodi Scala che possono lanciare eccezioni controllate Java. Prima o poi qualche porzione di codice Java finirà probabilmente per invocare uno di quei metodi.
</blockquote>

<h2 id=EnumerationsVsPatternMatching>Un confronto tra enumerazioni e pattern matching</h2>

<p>Le enumerazioni sono un modo di definire un insieme finito di valori costanti e rappresentano un'alternativa leggera alle classi <code>case</code>. Potete fare riferimento direttamente ai valori, iterare attraverso di essi, accedere a essi tramite un indice intero, <span class=baa>&amp;</span>c.

<p>Proprio come per le annotazioni, la forma delle enumerazioni di Scala è basata sulle classi e su un particolare insieme di idiomi anziché su parole chiave speciali da usare per definirle, come accade per le enumerazioni in Java e .NET. Tuttavia, potete anche usare le enumerazioni definite in quei linguaggi.

<p>Le enumerazioni di Scala si definiscono estendendo la classe astratta <code>scala.Enumeration</code> e si possono costruire in diversi modi. Vi mostreremo l'idioma che ricalca più da vicino le forme usate in Java e .NET che potreste già conoscere.

<p>Vi ricordate gli script per i metodi <abbr>HTTP</abbr> che abbiamo realizzato nella sezione <a href=cap-7.html#SealedClassHierarchies>Gerarchie di classi sigillate</a> del capitolo 7? Avevamo definito l'insieme dei metodi di <abbr>HTTP</abbr> 1.1 usando una gerarchia sigillata di classi <code>case</code>.

<pre><code>// <a href=esempi/cap-7/sealed/http-script.scala>esempi/cap-7/sealed/http-script.scala</a>

sealed abstract class HttpMethod()
case class Connect(body: String) extends HttpMethod
case class Delete (body: String) extends HttpMethod
case class Get    (body: String) extends HttpMethod
case class Head   (body: String) extends HttpMethod
case class Options(body: String) extends HttpMethod
case class Post   (body: String) extends HttpMethod
case class Put    (body: String) extends HttpMethod
case class Trace  (body: String) extends HttpMethod

def handle (method: HttpMethod) = method match {
  case Connect (body) =&gt; println("connect: " + body)
  case Delete  (body) =&gt; println("delete: "  + body)
  case Get     (body) =&gt; println("get: "     + body)
  case Head    (body) =&gt; println("head: "    + body)
  case Options (body) =&gt; println("options: " + body)
  case Post    (body) =&gt; println("post: "    + body)
  case Put     (body) =&gt; println("put: "     + body)
  case Trace   (body) =&gt; println("trace: "   + body)
}

val methods = List(
  Connect("corpo di connect..."),
  Delete ("corpo di delete..."),
  Get    ("corpo di get..."),
  Head   ("corpo di head..."),
  Options("corpo di options..."),
  Post   ("corpo di post..."),
  Put    ("corpo di put..."),
  Trace  ("corpo di trace..."))

methods.foreach { method =&gt; handle(method) }</code></pre>

<p>In quell'esempio, ogni metodo aveva un attributo <code>body</code> per il corpo del messaggio. Qui ipotizzeremo che il corpo venga gestito in altri modi: ci interessa solo identificare il tipo di metodo <abbr>HTTP</abbr>. Quindi, ecco una classe <code>Enumeration</code> per i metodi di <abbr>HTTP</abbr> 1.1.

<pre><code>// <a href=esempi/cap-13/http-enum-script.scala>esempi/cap-13/http-enum-script.scala</a>

object HttpMethod extends Enumeration {
  type Method = Value
  val Connect, Delete, Get, Head, Options, Post, Put, Trace = Value
}

import HttpMethod._

def handle (method: HttpMethod.Method) = method match {
  case Connect =&gt; println("Connect: " + method.id)
  case Delete  =&gt; println("Delete: "  + method.id)
  case Get     =&gt; println("Get: "     + method.id)
  case Head    =&gt; println("Head: "    + method.id)
  case Options =&gt; println("Options: " + method.id)
  case Post    =&gt; println("Post: "    + method.id)
  case Put     =&gt; println("Put: "     + method.id)
  case Trace   =&gt; println("Trace: "   + method.id)
}

HttpMethod foreach { method =&gt; handle(method) }
println(HttpMethod)</code></pre>

<p>Questo script produce l'uscita seguente. (Abbiamo suddiviso il testo tra parentesi graffe su più righe, per adeguarlo meglio alla larghezza della pagina.)

<pre><samp>Connect: 0
Delete: 1
Get: 2
Head: 3
Options: 4
Post: 5
Put: 6
Trace: 7
{Main$$anon$1$HttpMethod(0), Main$$anon$1$HttpMethod(1),
Main$$anon$1$HttpMethod(2), Main$$anon$1$HttpMethod(3),
Main$$anon$1$HttpMethod(4), Main$$anon$1$HttpMethod(5),
Main$$anon$1$HttpMethod(6), Main$$anon$1$HttpMethod(7)}</samp></pre>

<p>Ci sono due usi di <code>Value</code> nella definizione di <code>HttpMethod</code>. Il primo uso è un riferimento a una classe astratta, <code>Enumeration.Value</code>, che incapsula alcune operazioni utili per i &#8220;valori&#8221; nelle enumerazioni. Definiamo un nuovo <code>type</code> chiamato <code>Method</code> che funziona come un alias per <code>Value</code>. Ne vediamo l'uso nel tipo dell'argomento passato al metodo <code>handle</code>, che mostra <code>HttpMethod</code> in azione. Per il lettore, <code>HttpMethod.Method</code> è un nome più significativo di <code>HttpMethod.Value</code>. Notate che, nel metodo <code>handle</code>, abbiamo usato anche uno dei campi di <code>Enumeration.Value</code>, chiamato <code>id</code>.

<p>Il secondo uso di <code>Value</code> in realtà è l'invocazione di un metodo. Non c'è alcune collisione tra questi due nomi. La riga <code>val Connect, Delete, Get, Head, Options, Post, Put, Trace = Value</code> definisce l'insieme di valori per l'enumerazione. Il metodo <code>Value</code> viene invocato per ognuno di essi, e per ognuno crea una nuova istanza di <code>Enumeration.Value</code>, aggiungendola all'insieme di valori gestito dalla enumerazione.

<p>Nel codice <span class=wtf>sottostante alla</span> definizione, importiamo la definizione in <code>HttpMethod</code> e definiamo un metodo <code>handle</code> che effettua il pattern matching sugli oggetti <code>HttpMethod.Method</code>, stampando semplicemente un messaggio e il campo <code>id</code> di ogni valore. Notate che l'esempio non contiene nessuna clausola <code>case</code> &#8220;predefinita&#8221; (per esempio <code>case _ &#8658; &#8230;</code>) perché in questo caso non ne è richiesta alcuna. Tuttavia, il compilatore non sa realmente che tutti i possibili valori sono trattati, a differenza di quanto accade con una gerarchia sigillata di classi <code>case</code>. Se nascondete in un commento una delle istruzioni <code>case</code> nel metodo <code>handle</code> non otterrete messaggi di warning da parte del compilatore, bensì un errore di tipo <code>MatchError</code> durante l'esecuzione.

<blockquote class=warning>
<p><span class=u>&#x2762;</span>Quando si effettua il pattern matching sui valori di una enumerazione, il compilatore non è in grado di capire se la corrispondenza è &#8220;esaustiva&#8221;.
</blockquote>

<p>Potreste domandarvi perché abbiamo cablato le stringhe come <code>"Connect"</code> nelle istruzioni <code>println</code> contenute nelle clausole <code>case</code>: non avremmo potuto recuperare il nome dall'oggetto <code>HttpMethod.Method</code>? E perché il risultato di <code>println(HttpMethod)</code> non include quei nomi al posto degli illeggibili nomi usati internamente dagli oggetti?

<p>Siete probabilmente abituati a usare quei nomi con le enumerazioni Java o .NET. Sfortunatamente, non possiamo recuperare quei nomi dai valori nella enumerazione Scala, almeno dato il modo in cui abbiamo dichiarato <code>HttpMethod</code>. Tuttavia, ci sono due modi in cui possiamo cambiare l'implementazione per ottenere le stringhe con i nomi. Nel primo approccio, passiamo il nome a <code>Value</code> quando creiamo i campi.

<pre><code>// <a href=esempi/cap-13/http-enum2-script.scala>esempi/cap-13/http-enum2-script.scala</a>

object HttpMethod extends Enumeration {
  type Method = Value
  val Connect = Value("Connect")
  val Delete  = Value("Delete")
  val Get     = Value("Get")
  val Head    = Value("Head")
  val Options = Value("Options")
  val Post    = Value("Post")
  val Put     = Value("Put")
  val Trace   = Value("Trace")
}

import HttpMethod._

def handle (method: HttpMethod.Method) = method match {
  case Connect =&gt; println(method + ": " + method.id)
  case Delete  =&gt; println(method + ": " + method.id)
  case Get     =&gt; println(method + ": " + method.id)
  case Head    =&gt; println(method + ": " + method.id)
  case Options =&gt; println(method + ": " + method.id)
  case Post    =&gt; println(method + ": " + method.id)
  case Put     =&gt; println(method + ": " + method.id)
  case Trace   =&gt; println(method + ": " + method.id)
}

HttpMethod foreach { method =&gt; handle(method) }
println(HttpMethod)</code></pre>

<p>&Egrave; un po' ridondante dover usare la stessa parola due volte nelle dichiarazioni come <code>val Connect = Value("Connect")</code>.

<p>L'esecuzione di questo script produce un'uscita più gradevole.

<pre><samp>Connect: 0
Delete: 1
Get: 2
Head: 3
Options: 4
Post: 5
Put: 6
Trace: 7
{Connect, Delete, Get, Head, Options, Post, Put, Trace}</samp></pre>

<p>Nel secondo approccio, passiamo la lista di nomi al costruttore <code>Enumeration</code>.

<pre><code>// <a href=esempi/cap-13/http-enum3-script.scala>esempi/cap-13/http-enum3-script.scala</a>

object HttpMethod extends Enumeration(
    "Connect", "Delete", "Get", "Head", "Options", "Post", "Put", "Trace") {
  type Method = Value
  val Connect, Delete, Get, Head, Options, Post, Put, Trace = Value
}

import HttpMethod._

def handle (method: HttpMethod.Method) = method match {
  case Connect =&gt; println(method + ": " + method.id)
  case Delete  =&gt; println(method + ": " + method.id)
  case Get     =&gt; println(method + ": " + method.id)
  case Head    =&gt; println(method + ": " + method.id)
  case Options =&gt; println(method + ": " + method.id)
  case Post    =&gt; println(method + ": " + method.id)
  case Put     =&gt; println(method + ": " + method.id)
  case Trace   =&gt; println(method + ": " + method.id)
}

HttpMethod foreach { method =&gt; handle(method) }
println(HttpMethod)</code></pre>

<p>Questo script produce la stessa identica uscita del precedente. Notate che abbiamo una lista <em>ridondante</em> di stringhe di nomi e di nomi di valori. <em>Sta a voi mantenere gli elementi nella lista e il loro ordine coerenti con i valori dichiarati!</em> Questa versione contiene meno caratteri, ma è maggiormente soggetta a errori. Internamente, <code>Enumeration</code> accoppia le stringhe con le corrispondenti istanze di <code>Value</code> nel momento in cui vengono create.

<p>Il risultato della stampa dell'intero oggetto <code>HttpMethod</code> è migliore in entrambe le implementazioni alternative. Quando i valori hanno un nome, il loro metodo <code>toString</code> restituisce quel nome. In effetti, i nostri due ultimi esempi sono diventati piuttosto artificiosi perché ora abbiamo istruzioni identiche per tutte le clausole <code>case</code>! Naturalmente, in un'implementazione reale, gestireste i diversi metodi <abbr>HTTP</abbr> in maniera differente tra loro.

<h2 id=ThoughtsOnAnnotationsAndEnumerations>Considerazioni su annotazioni ed enumerazioni</h2>

<p>Sia per le annotazioni sia per le enumerazioni l'approccio di Scala, che prevede di usare gli ordinari meccanismi basati sulle classi anziché inventare parole chiave e sintassi personalizzata, presenta vantaggi e svantaggi. I vantaggi includono un minor numero di casi speciali nel linguaggio: le classi e i tratti sono usati più o meno nello stesso modo in cui vengono usati per il codice &#8220;normale&#8221;. Gli svantaggi includono la necessità di comprendere e usare convenzioni <em>ad hoc</em> che non sono sempre pratiche come i meccanismi sintattici particolari richiesti da Java e .NET. Inoltre, le implementazioni di Scala non sono altrettanto complete.

<p>Quindi, la comunità Scala dovrebbe cedere e implementare meccanismi <em>ad hoc</em> ma più completi per le annotazioni e le enumerazioni? Forse no. Scala è un linguaggio più flessibile rispetto alla maggior parte degli altri linguaggi. Molte funzionalità offerte dalle annotazioni e dalle enumerazioni di Java e .NET possono essere implementate in Scala in altri modi.

<p>Alcuni &#8220;casi d'uso&#8221; per le funzionalità più avanzate delle annotazioni Java possono essere implementate più elegantemente con codice Scala &#8220;normale&#8221;, come vedremo nella sezione <a href=#DesignPatterns>Pattern di progettazione</a> più avanti. Per quanto riguarda le enumerazioni, le classi <code>case</code> sigillate e il pattern matching offrono una soluzione flessibile in molti casi.

<h3 id=EnumerationsVsCaseClassesAndPatternMatching>Le enumerazioni a confronto con le classi <code>case</code> e il pattern matching</h3>

<p>Rivisitiamo lo script per i metodi <abbr>HTTP</abbr>, che usa una gerarchia sigillata di classi <code>case</code>, confrontandolo con la versione scritta in precedenza che usa un'istanza di <code>Enumeration</code>. Dato che la versione con l'enumerazione non gestisce il corpo del messaggio, modifichiamo la versione con la gerarchia sigillata di classi <code>case</code> in modo che si avvicini alla versione con l'enumerazione: eliminiamo la gestione del corpo del messaggio e aggiungiamo i metodi <code>name</code> e <code>id</code>.

<pre><code>// <a href=esempi/cap-13/http-case-script.scala>esempi/cap-13/http-case-script.scala</a>

sealed abstract class HttpMethod(val id: Int) {
  def name = getClass getSimpleName
  override def toString = name
}

case object Connect extends HttpMethod(0)
case object Delete  extends HttpMethod(1)
case object Get     extends HttpMethod(2)
case object Head    extends HttpMethod(3)
case object Options extends HttpMethod(4)
case object Post    extends HttpMethod(5)
case object Put     extends HttpMethod(6)
case object Trace   extends HttpMethod(7)

def handle (method: HttpMethod) = method match {
  case Connect =&gt; println(method + ": " + method.id)
  case Delete  =&gt; println(method + ": " + method.id)
  case Get     =&gt; println(method + ": " + method.id)
  case Head    =&gt; println(method + ": " + method.id)
  case Options =&gt; println(method + ": " + method.id)
  case Post    =&gt; println(method + ": " + method.id)
  case Put     =&gt; println(method + ": " + method.id)
  case Trace   =&gt; println(method + ": " + method.id)
}

List(Connect, Delete, Get, Head, Options, Post, Put, Trace) foreach {
  method =&gt; handle(method)
}</code></pre>

<p>Notate che abbiamo usato un <code>case object</code> per ognuna delle sottoclassi concrete, per avere un vero insieme di costanti. Per imitare il campo <code>id</code> della enumerazione abbiamo aggiunto esplicitamente un campo, ma ora tocca a noi passargli valori validi e unici. I metodi <code>handle</code> nelle due implementazioni sono quasi identici.

<p>Lo script produce l'uscita seguente.

<pre><samp>Main$$anon$1$Connect$: 0
Main$$anon$1$Delete$: 1
Main$$anon$1$Get$: 2
Main$$anon$1$Head$: 3
Main$$anon$1$Options$: 4
Main$$anon$1$Post$: 5
Main$$anon$1$Put$: 6
Main$$anon$1$Trace$: 7</samp></pre>

<p>I nomi degli oggetti non sono molto leggibili, ma potremmo elaborare le stringhe per estrarre la parte che ci interessa realmente.

<p>Entrambi gli approcci supportano il concetto di un insieme finito e costante di valori, fino a quando la gerarchia di classi <code>case</code> rimane sigillata. Un ulteriore vantaggio della gerarchia sigillata di classi <code>case</code> è il fatto che il compilatore vi avvertirà se le istruzioni del pattern matching non esauriscono tutti i casi possibili. Provate a rimuovere una delle clausole <code>case</code> e vedrete proprio questo messaggio di warning. Come abbiamo visto, il compilatore non è in grado di effettuare questo controllo per le enumerazioni.

<p>Il formato delle enumerazioni è più conciso, nonostante la duplicazione dei nomi che abbiamo dovuto usare, e supporta anche la possibilità di iterare attraverso i valori, cosa che abbiamo dovuto fare manualmente nella implementazione con le classi <code>case</code>.
<!-- TODO "accomodate" = "ricevere"? -->
<p>L'implementazione con le classi <code>case</code> <span class=wtf>accomodates</span> altri campi, come per esmepio <code>body</code> nell'implementazione originale, mentre le enumerazioni possono solo <span class=wtf>accomodate</span> oggetti <code>Value</code> costanti insieme ai nomi e agli identificatori associati.

<blockquote class=note>
<p><span class=u>&#x261E;</span>Per i casi in cui vi occorre solo una semplice lista di costanti con un nome o un numero di identificazione usate le enumerazioni. Fate attenzione a seguire gli idiomi d'uso. Per insiemi fissi di oggetti costanti più complessi usate una gerarchia sigillata di <code>case object</code>.
</blockquote>

<h2 id=UsingNullsVsOptions>Un confronto tra <code>null</code> e <code>Option</code></h2>

<p>Quando abbiamo presentato <code>Option</code> nella sezione <a href=cap-2.html#OptionSomeNone><code>Option</code>, <code>Some</code> e <code>None</code>: evitare i valori nulli</a> nel capitolo 2, abbiamo esaminato brevemente il modo in cui vi incoraggia a evitare i riferimenti nulli nel vostro codice, ricordando anche che Tony Hoare, l'inventore del concetto di <code>null</code> nel 1965, li ha definiti come un &#8220;errore da un miliardo di dollari&#8221;. <a href=apa.html#Hoare2009>[Hoare2009]</a>.

<p>Scala deve supportare <code>null</code> perché <code>null</code> è supportato sia dalla <abbr>JVM</abbr> che da .NET e le librerie esistenti su queste piattaforme lo usano. Di fatto, <code>null</code> viene usato da alcune librerie Scala.

<p>E se <code>null</code> non fosse disponibile? Come cambierebbe il vostro modo di scrivere codice? La <abbr>API</abbr> di <code>Map</code> ci offre alcuni esempi interessanti. Considerate questi due metodi di <code>Map</code>.

<pre><code>trait Map[A,+B] {
  &hellip;
  def get(key: A) : Option[B]
  def getOrElse [B2 &gt;: B](key : A, default : =&gt; B2) : B2 = &hellip;
  &hellip;
}</code></pre>

<p>Una mappa potrebbe non contenere un valore per una particolare chiave. In questo caso, entrambi questi metodi evitando di restituire <code>null</code>: le implementazioni concrete di <code>get</code> nelle sottoclassi di <code>Map</code> restituiscono <code>None</code> se nessun valore è associato alla chiave, altrimenti restituiscono un'istanza di <code>Some</code> che racchiude il valore. La firma del metodo vi dice che un valore potrebbe non esistere, e vi obbliga a gestire quella situazione <span class=wtf>gracefully</span>.

<pre><code>val stateCapitals = Map("Alabama" -&gt; "Montgomery", &hellip;)
&hellip;

stateCapitals.get("North Hinterlandia") match {
  case None =&gt; println ("Questo stato non esiste!")
  case Some(x) =&gt; println(x)
}</code></pre>

<p>Similmente, <code>getOrElse</code> vi obbliga a scrivere codice in maniera difensiva: dovete specificare un valore predefinito da usare quando la chiave non è contenuta nella mappa. Notate che il valore predefinito può effettivamente essere un'istanza di un supertipo relativo al tipo dei valori nella mappa.

<pre><code>println(stateCapitals.getOrElse("North Hinterlandia", "Questo stato non esiste!"))</code></pre>

<p>Molte <abbr>API</abbr> di Java e .NET consentono di usare <code>null</code> come argomento per i metodi e come valore di ritorno. Potete scrivere uno strato di codice Scala che racchiuda queste <abbr>API</abbr> e implementi una strategia appropriata per gestire i valori nulli.

<p>Per esempio, rivisitiamo il nostro esempio precedente relativo alla stampa di un file realizzato nella sezione <a href=#Annotations>Annotazioni</a>. Riorganizzeremo la classe <code>FilePrinter</code> e il driver Java in uno script combinato. Affronteremo due problemi: avvolgeremo <code>LineNumberReader.readLine</code> in un metodo che restituisce <code>Option</code> anziché <code>null</code>, e racchiuderemo l'eccezione controllata <code>IOException</code> in una nostra eccezione non controllata che chiameremo <code>ScalaIOException</code>.

<pre><code>// <a href=esempi/cap-13/file-printer-refactored-script.scala>esempi/cap-13/file-printer-refactored-script.scala</a>

import java.io._

class ScalaIOException(cause: Throwable) extends RuntimeException(cause)

class ScalaLineNumberReader(in: Reader) extends LineNumberReader(in) {
  def inputLine() = readLine() match {
    case null =&gt; None
    case line =&gt; Some(line)
  }
}

object ScalaLineNumberReader {
  def apply(file: File) = try {
     new ScalaLineNumberReader(new FileReader(file))
  } catch {
    case ex: IOException =&gt; throw new ScalaIOException(ex)
  }
}

class FilePrinter(val file: File) {
  def print() = {
    val reader = ScalaLineNumberReader(file)
    try {
      loop(reader)
    } finally {
      if (reader != null)
        reader.close
    }
  }

  private def loop(reader: ScalaLineNumberReader): Unit = {
    reader.inputLine() match {
      case None =&gt;
      case Some(line) =&gt; {
        format("%3d: %s\n", reader.getLineNumber, line)
        loop(reader)
      }
    }
  }
}

// Elabora gli argomenti a riga di comando (i nomi dei file):
args.foreach { fileName =&gt;
  new FilePrinter(new File(fileName)).print();
}</code></pre>

<p>La classe <code>ScalaLineNumberReader</code> definisce un nuovo metodo <code>inputLine</code> che invoca <code>LineNumber.readLine</code> ed esegue il pattern matching sul risultato: se è <code>null</code>, allora viene restituito <code>None</code>, altrimenti viene restituita la riga racchiusa in un'istanza di <code>Some[String]</code>.

<p><code>ScalaIOException</code> è una sottoclasse di <code>RuntimeException</code>, quindi è un'eccezione non controllata. La usiamo per racchiudere qualsiasi <code>IOException</code> lanciata in <code>ScalaLineNumberReader.apply</code>.

<p>La classe <code>FilePrinter</code> viene riorganizzata in modo da usare <code>ScalaLineNumberReader.apply</code> nel proprio metodo <code>print</code> e <code>ScalaLineNumberReader.inputLine</code> nel proprio metodo <code>loop</code>. Mentre la versione originale gestiva in maniera appropriata il caso in cui <code>LineNumberReader.readLine</code> restituisse <code>null</code>, ora l'utente di <code>ScalaLineNumberReader</code> non ha altra scelta se non quella di gestire il valore di ritorno <code>None</code>.

<p>Lo script termina con un ciclo sugli argomenti in ingresso, che vengono memorizzati automaticamente nella variabile <code>args</code>. Ogni argomento viene trattato come un nome di file da stampare. Lo script stamperà sé stesso con il seguente comando.

<pre><samp>scala file-printer-refactored-script.scala file-printer-refactored-script.scala</samp></pre>

<h3 id=OptionsAndForComprehensions><code>Option</code> e le espressioni <code>for</code></h3>

<p>Quando <code>Option</code> viene usata in combinazione con le espressioni <code>for</code> possiamo godere di un altro vantaggio: la rimozione automatica degli elementi <code>None</code> dalle espressioni, sotto la maggior parte delle condizioni <a href=apa.html#Pollak2007>[Pollak2007]</a>, <a href=apa.html#Spiewak2009c>[Spiewak2009c]</a>. Considerate questa prima versione di uno script che usa <code>Option</code> in una espressione <code>for</code>.

<pre><code>// <a href=esempi/cap-13/option-for-comp-v1-script.scala>esempi/cap-13/option-for-comp-v1-script.scala</a>

case class User(userName: String, name: String, email: String, bio: String)

val newUserProfiles = List(
  Map("userName" -&gt; "twitspam", "name" -&gt; "Twit Spam"),
  Map("userName" -&gt; "bucktrends", "name" -&gt; "Buck Trends",
      "email" -&gt; "thebuck@stops.he.re", "bio" -&gt; "Il più grande bloviator del mondo"),
  Map("userName" -&gt; "lonelygurl", "name" -&gt; "Lonely Gurl",
      "bio" -&gt; "Chiaramente falso..."),
  Map("userName" -&gt; "deanwampler", "name" -&gt; "Dean Wampler",
      "email" -&gt; "dean@....com", "bio" -&gt; "Passionista di Scala"),
  Map("userName" -&gt; "al3x", "name" -&gt; "Alex Payne",
      "email" -&gt; "al3x@....com", "bio" -&gt; "Genio della API di Twitter"))

// Versione n°1

var validUsers = for {
  user     &lt;- newUserProfiles
  if (user.contains("userName") &amp;&amp; user.contains("name") &amp;&amp;   // #1
      user.contains("email") &amp;&amp; user.contains("bio"))         // #1
  userName &lt;- user get "userName"
  name     &lt;- user get "name"
  email    &lt;- user get "email"
  bio      &lt;- user get "bio" }
    yield User(userName, name, email, bio)

validUsers.foreach (user =&gt; println(user))</code></pre>

<p>Immaginate che questo codice venga usato in un qualche sito di rete sociale. I nuovi utenti presentano i dati del proprio profilo, che vengono passati in blocco a questo servizio per essere elaborati. Per fare un esempio, abbiamo cablato una lista di profili in cui i dati sono inseriti in una mappa. La mappa potrebbe essere stata copiata da una sessione <abbr>HTTP</abbr>.

<p>Il servizio filtra i profili incompleti a cui manca qualche campo, tramite le righe di codice commentate con <code>#1</code>, e crea nuovi oggetti utente a partire dai profili completi.

<p>Se eseguite lo script, verranno stampati tre nuovi utenti dai cinque profili elaborati.

<pre><samp>User(bucktrends,Buck Trends,thebuck@stops.he.re,Il più grande bloviator del mondo)
User(deanwampler,Dean Wampler,dean@....com,Passionista di Scala)
User(al3x,Alex Payne,al3x@....com,Genio della API di Twitter)</samp></pre>

<p>Ora, cancellate le due righe con i commenti <code>#1</code>.

<pre><code>&hellip;
var validUsers = for {
  user     &lt;- newUserProfiles
  userName &lt;- user get "userName"
  name     &lt;- user get "name"
  email    &lt;- user get "email"
  bio      &lt;- user get "bio" }
    yield User(userName, name, email, bio)

validUsers.foreach (user =&gt; println(user))</code></pre>

<p>Prima di rieseguire lo script, cosa vi aspettate che succeda? Verranno stampate cinque righe con alcuni campi vuoti (o contenenti altri tipi di valori)?

<p>Stampa la stessa cosa! Come ha fatto a eseguire il filtraggio che volevamo senza le espressioni condizionali esplicite?

<p>La risposta giace nel modo in cui sono implementate le espressioni <code>for</code>. Ecco un paio di semplici espressioni <code>for</code> seguite dalla loro traduzione <a href=apa.html#ScalaSpec2009>[ScalaSpec2009]</a>. Per prima cosa, esamineremo un semplice <em>generatore</em> con l'istruzione <code>yield</code>.

<pre><code>for (p1 &lt;- e1) yield e2          // espressione for

e1 map ( case p1 =&gt; e2 )         // traduzione</code></pre>

<p>Ecco la traduzione di un singolo <em>generatore</em> seguito da un'espressione arbitraria (che potrebbero essere più espressioni racchiuse tra parentesi, <span class=baa>&amp;</span>c.).

<pre><code>for (p1 &lt;- e1) e2                // espressione for

e1 foreach ( case p1 =&gt; e2 )     // traduzione</code></pre>

<p>Con più di un <em>generatore</em>, <code>map</code> viene sostituito da <code>flatMap</code> nelle espressioni <code>yield</code>, ma <code>foreach</code> rimane inalterato.

<pre><code>for (p1 &lt;- e1; p2 &lt;- e2 ...) yield eN       // espressione for

e1 flatMap ( case p1 =&gt; for (p2 &lt;- e2 ...) yield eN )  // traduzione

for (p1 &lt;- e1; p2 &lt;- e2 ...) eN             // espressione for

e1 foreach ( case p1 =&gt; for (p2 &lt;- e2 ...) eN )       // traduzione</code></pre>

<p>Notate che il secondo degli N generatori diventa una espressione <code>for</code> annidata che necessita di essere tradotta.

<p>Esistono traduzioni simili per le istruzioni <code>for</code> condizionali (che diventano invocazioni di <code>filter</code> e assegnamenti a valori <code>val</code>). Non le mostreremo in questa sede, dato che il nostro scopo principale è quello di descrivere un numero sufficiente di dettagli di implementazione in modo che possiate capire come le espressioni <code>for</code> lavorano insieme a <code>Option</code>. Ulteriori dettagli si possono trovare in <a href=apa.html#ScalaSpec2009>[ScalaSpec2009]</a>, corredati di esempi.

<p>Se seguite questo procedimento di traduzione sul nostro esempio, ottenete l'espansione seguente.

<pre><code>var validUsers = newUserProfiles flatMap {
  case user =&gt; user.get("userName") flatMap {
    case userName =&gt; user.get("name") flatMap {
      case name =&gt; user.get("email") flatMap {
        case email =&gt; user.get("bio") map {
          case bio =&gt; User(name, userName, email, bio)    // #1
        }
      }
    }
  }
}</code></pre>

<p>Notate che <code>flatMap</code> viene invocato fino al caso più interno, dove viene usato <code>map</code> (<code>flatMap</code> e <code>map</code> si comportano allo stesso modo in questo caso).

<p>Ora possiamo capire perché le espressioni condizionali erano superflue. Ricordatevi che <code>user</code> è un'istanza di <code>Map</code> e che <code>user.get(&hellip;)</code> restituisce un'istanza di <code>Option</code>, cioè <code>None</code> oppure <code>Some(valore)</code>. La chiave è il comportamento di <code>flatMap</code> definito su <code>Option</code>, che ci permette di trattare i valori di <code>Option</code> come altre collezioni. Ecco la definizione di <code>flatMap</code>.

<pre><code>def flatMap[B](f: A =&gt; Option[B]): Option[B] =
  if (isEmpty) None else f(this.get)</code></pre>

<p>Se <code>user.get(&hellip;)</code> restituisce <code>None</code>, allora <code>flatMap</code> restituisce semplicemente <code>None</code> e non valuta mai il letterale funzione. Quindi, le iterazioni annidate si fermano e non arrivano mai alla riga segnata con il commento <code>#1</code>, dove avviene la creazione vera e propria di <code>User</code>.

<p>L'invocazione più esterna di <code>flatMap</code> avviene sull'istanza di <code>List</code> in ingresso, <code>newUserProfiles</code>. Su una collezione come questa, che contiene più elementi, il comportamento di <code>flatMap</code> è simile a quello di <code>map</code>, ma &#8220;appiattisce&#8221; la nuova collezione e, a differenza di <code>map</code>, non richiede che la mappa risultante abbia lo stesso numero di elementi della collezione originale.

<p>Infine, ricordando quanto detto nella sezione <a href=cap-8.html#PartialFunctions>Funzioni parziali</a> del capitolo 8, le istruzioni <code>case user =&gt; &hellip;</code>, per esempio, inducono il compilatore a generare un'istanza di <code>PartialFunction</code> da passare a <code>flatMap</code> e <code>map</code>, quindi nessun <span class=wtf>wrapper</span> corrispondente sullo stile <code>foo match {&hellip;}</code> è necessario.

<blockquote class=note>
<p><span class=u>&#x261E;</span>L'uso di <code>Option</code> con le espressioni <code>for</code> elimina la necessità della maggior parte dei controlli per le collezioni vuote o i valori nulli.
</blockquote>

<h2 id=ExceptionsAndTheAlternatives>Le eccezioni e le alternative</h2>

<p>Se <code>null</code> è l'errore &#8220;da un miliardo di dollari&#8221;, come abbiamo detto nella sezione <a href=cap-2.html#OptionSomeNone><code>Option</code>, <code>Some</code> e <code>None</code>: evitare i valori nulli</a> del capitoo 2, cosa dovremmo dire delle eccezioni? Potete sostenere che i valori nulli non dovrebbero mai capitare e potete progettare linguaggi e librerie che non li usano mai. Tuttavia, le eccezioni occupano un posto legittimo, perché <em>separano gli interessi</em> del flusso di esecuzione normale da quelli del flusso di esecuzione &#8220;eccezionale&#8221;. Questa divisione non è sempre <span class=wtf>clear cut</span>. Per esempio, se un utente sbaglia a digitare il proprio nome, questo avvenimento è normale o eccezionale?

<p>Un altra questione è: quando le eccezioni dovrebbero essere catturate e gestite? Le eccezioni controllate di Java sono state progettare per indicare all'utente di una <abbr>API</abbr> quali eccezioni potrebbero essere lanciate da un metodo. Il difetto è che questo ha incoraggiato la gestione delle eccezioni in modi che sono spesso subottimali. Se un metodo invoca un altro metodo che potrebbe lanciare un'eccezione controllata, il metodo chiamante è obbligato a gestire l'eccezione oppure a dichiarare che anch'esso lancia quella eccezione. Più spesso che no, il metodo chiamante è il posto sbagliato per gestire l'eccezione: accade comunemente che i metodi si &#8220;mangino&#8221; un'eccezione che dovrebbe essere rilanciata e gestita in un contesto più appropriato. Questo richiede di aggiungere dichiarazioni <code>throws</code> ai metodi che compongono una catena di invocazioni: un'operazione non solo fastidiosa, ma che inquina i contesti intermedi con nomi di eccezioni che spesso non hanno nulla a che vedere con il contesto locale.

<p>Come abbiamo visto, Scala non dispone di eccezioni controllate. Qualsiasi eccezione può propagarsi fino al punto in cui è più appropriato gestirla. Tuttavia, è necessaria una certa disciplina nella progettazione per implementare questa gestione nei punti appropriati per tutte le eccezioni dalle quali è possibile recuperare l'esecuzione!

<p>Ogni tanto gli sviluppatori appartenenti alla comunità di un particolare linguaggio partecipano ad accesi dibattiti sui meriti di usare le eccezioni come meccanismo di controllo del flusso di esecuzione per la normale elaborazione. A volte questo uso delle eccezioni viene visto come un meccanismo utile simile all'istruzione <code>longjump</code> o a un <code>goto</code> non locale per uscire da un ambito di visibilità profondamente annidato. Una delle ragioni per cui questo dibattito ricompare è che questo uso delle eccezioni si rivela talvolta più efficinete rispetto a un'implementazione più &#8220;convenzionale&#8221;.

<p>Per esempio, potreste implementare <code>Iterable.foreach</code> per attraversare ciecamente una collezione e fermarsi quando cattura una qualsiasi eccezione che indica che ha superato la fine della collezione.

<p>Quando si parla di progettazione di applicazioni, comunicare l'<em>intento</em> è molto importante. Usare le eccezioni come un meccanismo di <code>goto</code> viola il <em>principio di minore sorpresa</em>. Sarà raro il caso in cui il guadagno sulle prestazioni giustificherà la perdita di chiarezza, quindi vi incoraggiamo a usare le eccezioni solo per i casi davvero &#8220;eccezionali&#8221;. Notate che Ruby in effetti fornisce un meccanismo simile a un <code>goto</code> non locale: le parole chiave <code>throw</code> e <code>catch</code> sono riservate a questo scopo, mentre <code>raise</code> e <code>rescue</code> sono le parole chiave per sollevare un'eccezione e gestirla.
<!-- TODO "flip side"?!? -->
<p>Qualunque sia la vostra opinione sull'uso appropriato delle eccezioni, quando state progettando una <abbr>API</abbr> minimizzare la possibilità di sollevare un'eccezione beneficierà i vostri utenti. Questa è l'altra faccia della medaglia di una strategia per la gestione delle eccezioni: in primo luogo, evitare di lanciarle. In questo caso, <code>Option</code> può esservi d'aiuto.

<p>Considerate i due metodi di <code>Seq</code> chiamati <code>first</code> e <code>firstOption</code>.

<pre><code>trait Seq[+A] {
  &hellip;
  def first : A = &hellip;
  def firstOption : Option[A] = &hellip;
  &hellip;
}</code></pre>

<p>Il metodo <code>first</code> lancia una <code>Predef.UnsupportedOperationException</code> se la sequenza è vuota. Restituire <code>null</code> in questo caso non è possibile, perché la sequenza potrebbe avere degli elementi uguali a <code>null</code>! Al contrario, il metodo <code>firstOption</code> restituisce un'istanza di <code>Option</code>, quindi nel caso in cui la sequenza sia vuota restituisce il valore <code>None</code>, che non ha problemi di ambiguità.

<p>Potreste sostenere che la <abbr>API</abbr> di <code>Seq</code> sarebbe più robusta se solo avesse un metodo <code>first</code> che restituisce un'istanza di <code>Option</code>. &Egrave; utile chiedere a sé stessi: &#8220;come potrei evitare un qualsiasi fallimento all'utente?&#8221; Quando i &#8220;fallimenti&#8221; non possono essere prevenuti, usate <code>Option</code> o un costrutto simile per indicare all'utente che è possibile trovarsi in una modalità di fallimento. Ragionando in termini di trasformazioni di stato valide, il metodo <code>first</code>, pur conveniente, non è valido per una sequenza in uno stato vuoto. Forse il metodo <code>first</code> non dovrebbe esistere per questa ragione? Questa scelta è probabilmente troppo draconiana, ma restituendo <code>Option</code> dal metodo <code>firstOption</code> la <abbr>API</abbr> comunica all'utente che esistono circostanze nelle quali il metodo non può soddisfare la richiesta ed è compito dell'utente recuperare il flusso di esecuzione normale. In questo senso, <code>firstOption</code> tratta una sequenza vuota come una situazione non eccezionale.

<p>Se ricordate, abbiamo visto un compromesso di questo tipo in un altro esempio della sezione <a href=cap-2.html#OptionSomeNone><code>Option</code>, <code>Some</code> e <code>None</code>: evitare i valori nulli</a> nel capitolo 2, esaminando due metodi di <code>Option</code> che servono a recuperare il valore racchiuso in un'istanza di <code>Some</code>. Il metodo <code>get</code> lancia un'eccezione se non è presente alcun valore, cioè se l'istanza di <code>Option</code> è un'istanza di <code>None</code>; l'altro metodo, <code>getOrElse</code>, accetta come secondo argomento un valore predefinito da restituire se l'istanza di <code>Option</code> è un'istanza di <code>None</code>, e in questo caso non viene lanciata nessuna eccezione.

<p>Naturalmente, è impossibile evitare tutte le eccezioni. Parte dell'intento originale nella separazione tra eccezioni controllate e non controllate era quello di distinguere i problemi potenzialmente recuperabili dai fallimenti catastrofici come gli errori dovuti alla mancanza di memoria.

<p>Tuttavia, i metodi alternativi di <code>Seq</code> e <code>Option</code> mostrano un modo di &#8220;incoraggiare&#8221; l'utente di una <abbr>API</abbr> a considerare le conseguenze di un possibile fallimento, come richiedere il primo elemento di una sequenza vuota. L'utente può specificare la contingenza nel caso in cui accada un fallimento. Minimizzare la possibilità di eccezioni migliorerà la robustezza delle vostre librerie Scala e delle applicazioni che le usano.

<h2 id=ScalableAbstractions>Astrazioni scalabili</h2>

<p>Per qualche tempo uno degli scopi della nostra industria è stato quello di creare <em>componenti</em> riusabili. Sfortunatamente, non c'è mai stato molto accordo sul significato del termine <em>componente</em> né su quello del termine correlato <em>modulo</em> (che alcune persone considerano sinonimo di componente). Le definizioni proposte di solito partono da assunzioni riguardo alla piattaforma, alla granularità, agli scenari di configurazione e <span class=wtf>deployment</span>, alle questioni di versionamento, <span class=baa>&amp;</span>c. <a href=apa.html#Szyperski1998>[Szyperski1998]</a>.

<p>Eviteremo queste discussioni e useremo il termine <em>componente</em> in maniera informale per riferirci a un gruppo di tipi e di package che espone astrazioni coerenti (preferibilmente una sola) per i servizi offerti, ha un insieme minimo di dipendenze nei confronti di altri componenti, ed è internamente coesivo.

<p>Tutti i linguaggi offrono meccanismi per definire componenti, almeno <span class=wtf>to some degree</span>. Gli oggetti sono i meccanismo di incapsulamento principale nei linguaggi orientati agli oggetti. Tuttavia, gli oggetti da soli non sono sufficienti, perché scopriamo velocemente che si raggruppano naturalmente in aggregati a grana più grossa, soprattutto man mano che le nostre applicazioni crescono. Parlando per sommi capi, un oggetto non è necessariamente un componente e un componente può contenere molti oggetti. Scala e Java offrono i package per aggregare i tipi; i moduli di Ruby servono a uno scopo simile, così come gli spazi di nomi in C# e C++.

<p>In ogni caso, questi meccanismi di impacchettamento hanno ancora alcuni limiti. Un problema comune è che non definiscono chiaramente cos'è pubblicamente visibile al di fuori dei confini del componente e cos'è interno al componente. Per esempio, in Java qualsiasi tipo pubblico o metodo pubblico in un tipo pubblico è visibile al di fuori del confine del package a tutti gli altri componenti. Potete rendere i tipi e i metodi &#8220;privati per il package&#8221;, ma a quel punto sarebbero invisibili agli altri package incapsulati nel componente. Java non ha un senso chiaro dei confini di un componente.

<p>Scala offre un certo numero di meccanismi che migliorano questa situazione, molti dei quali sono già stati esaminati nel corso di questo libro.

<h3 id=FineGrainedVisibilityRules>Regole di visibilità a grana fine</h3>

<p>Nella sezione <a href=cap-5.html#VisibilityRules>Regole di visibilità</a> del capitolo 5 abbiamo visto che Scala offre regole di visibilità che sono a grana più fine rispetto alla maggior parte degli altri linguaggi. Potete controllare la visibilità dei tipi e dei metodi al di fuori dei confini del tipo e del package.

<p>Considerate l'esempio seguente, che mostra un <em>componente</em> nel package <code>encodestring</code>.

<pre><code>// <a href=esempi/cap-13/encoded-string.scala>esempi/cap-13/encoded-string.scala</a>

package encodedstring {

  trait EncodedString {
    protected[encodedstring] val string: String
    val separator: EncodedString.Separator.Delimiter

    override def toString = string

    def toTokens = string.split(separator.toString).toList
  }

  object EncodedString {
    object Separator extends Enumeration {
      type Delimiter = Value
      val COMMA = Value(",")
      val TAB   = Value("\t")
    }

    def apply(s: String, sep: Separator.Delimiter) = sep match {
      case Separator.COMMA =&gt; impl.CSV(s)
      case Separator.TAB   =&gt; impl.TSV(s)
    }

    def unapply(es: EncodedString) = Some(Pair(es.string, es.separator))
  }

  package impl {
    private[encodedstring] case class CSV(override val string: String)
        extends EncodedString {
      override val separator = EncodedString.Separator.COMMA
    }

    private[encodedstring] case class TSV(override val string: String)
        extends EncodedString {
      override val separator = EncodedString.Separator.TAB
    }
  }
}</code></pre>

<p>Questo esempio incapsula la gestione delle stringhe che codificano valori separati da virgole (<abbr>CSV</abbr>, dall'inglese <em>comma-separated values</em>) o da tabulazioni (<abbr>TSV</abbr>). Il package <code>encodestring</code> espone un tratto <code>EncodedString</code> che è visibile ai clienti. Le classi concrete che implementano i <abbr>CSV</abbr> e i <abbr>TSV</abbr> sono dichiarati come <code>private[encodestring]</code> nel package <code>encodestring.impl</code>. Il tratto definisce due campi <code>val</code> astratti: <code>string</code> per memorizzare la stringa codificata, che è protetta dall'accesso dei clienti, e <code>separator</code> per mememorizzare il separatore (per esempio una virgola). Se ricordate quando abbiamo visto nel <a href=cap-6.html>capitolo 6</a>, i campi astratti, così come i metodi e i tipi astratti, devono essere inizializzati nelle istanze concrete. In questo caso, <code>string</code> verrà definito tramite un costruttore concreto e <code>separator</code> viene definito esplicitamente nelle classi concrete <code>CSV</code> e <code>TSV</code>.

<p>Il metodo <code>toString</code> di <code>EncodeString</code> stampa la stringa come una stringa &#8220;normale&#8221;. Nascondendo il valore di <code>string</code> e le classi concrete, siamo completamente liberi di scegliere come memorizzare effettivamente la stringa. Per esempio, per stringhe particolarmente grandi, potremmo volerle suddividere sulla base del delimitatore e memorizzare le sottostringhe in una struttura dati. Questo ci permetterebbe di risparmiare spazio se le stringhe fossero abbastanza grandi e potessimo condividere le sottostringhe tra più stringhe. Inoltre, potremmo scoprire che questa strategia di memorizzazione è utile per varie attività di ricerca, ordinamento, e altri tipi di manipolazione. Tutte queste questioni di implementazione sono trasparenti per il cliente.

<p>Il package espone anche un oggetto con una enumerazione per i separatori noti, un metodo factory <code>apply</code> per costruire nuove stringhe codificate e un metodo estrattore <code>unapply</code> per decomporre le stringhe codificate nella stringa racchiusa e nel delimitatore. In questo caso, il metodo <code>unapply</code> sembra banale, ma se memorizzassimo le stringhe in modo diverso questo metodo potrebbe ricostruire la stringa originale in maniera trasparente.

<p>Quindi, i clienti di questo <em>componente</em> conoscono solo l'astrazione <code>EncodedString</code> e l'enumerazione che rappresenta i tipi supportati di stringhe codificate, mentre tutti i tipi e i dettagli dell'implementazione reale sono privati per il package <code>encodedstring</code>; qui abbiamo messo tutto in un unico file per convenienza, ma normalmente terreste le due cose separate. Quindi, il confine tra le astrazioni esposte e i dettagli dell'implementazione interna è chiaro.

<p>Lo script riportato di seguito mostra il componente in azione.

<pre><code>// <a href=esempi/cap-13/encoded-string-script.scala>esempi/cap-13/encoded-string-script.scala</a>

import encodedstring._
import encodedstring.EncodedString._

def p(s: EncodedString) = {
  println("EncodedString: " + s)
  s.toTokens foreach (x =&gt; println("parola: " + x))
}

val csv = EncodedString("Scala,è,fantastico!", Separator.COMMA)
val tsv = EncodedString("Scala\tè\tfantastico!", Separator.TAB)

p(csv)
p(tsv)

println("\nEstrazione:")
List(csv, "ProgrammareInScala", tsv, 3.14159) foreach {
  case EncodedString(str, delim) =&gt;
    println("EncodedString: \"" + str + "\", delimitatore: \"" + delim + "\"")
  case s: String =&gt; println "String: " + s)
  case x =&gt; println("Valore sconosciuto: " + x)
}</code></pre>

<p>L'esecuzione di questo script produce l'uscita seguente.

<pre><samp>EncodedString: Scala,è,fantastico!
parola: Scala
parola: è
parola: fantastico!
EncodedString: Scala    è      fantastico!
parola: Scala
parola: is
parola: great!

Estrazione:
EncodedString: "Scala,è,fantastico!", delimitatore: ","
String: ProgrammareInScala
EncodedString: "Scala   è      fantastico!", delimitatore: "   "
Unknown Value: 3.14159</samp></pre>

<p>Tuttavia, se per esempio proviamo a usare la classe <code>CSV</code> direttamente, otteniamo l'errore seguente.

<pre><samp>scala&gt; import encodedstring._
import encodedstring._

scala&gt; val csv = impl.CSV("valori,separati,da,virgole")
&lt;console&gt;:6: error: object CSV cannot be accessed in package encodedstring.impl
       val csv = impl.CSV("valori,separati,da,virgole")
                      ^

scala&gt;</samp></pre>

<p>In questo semplice esempio non era essenziale rendere i tipi concreti privati per il componente. Tuttavia, esponiamo ai clienti del componente un'interfaccia davvero minimale e siamo liberi di modificare l'implementazione come crediamo appropriato senza quasi correre il rischio di costringere il cliente a modificare il proprio codice. Una causa comune della paralisi nella manutenzione di applicazioni mature è la presenza di un numero eccessivo di dipendenze tra i tipi concreti, che diventano difficili da modificare dato che obbligano il cliente a cambiare il proprio codice. Quindi, per componenti più grandi e sofisticati, questa chiara separazione tra astrazione e implementazione può mantenere a lungo il codice mantenibile e riusabile.

<h3 id=MixinComposition>La composizione dei mixin</h3>

<p>Nel <a href=cap-4.html>capitolo 4</a> abbiamo visto come i tratti favoriscono la composizione dei mixin. Una classe può concentrarsi sul proprio <em>dominio principale</em> e le altre responsabilità possono essere implementate separatamente nei tratti. Quando le istanze vengono costruite, le classi e i tratti possono essere combinati per comporre l'intero insieme di comportamenti richiesti.

<p>Per esempio, nella sezione <a href=cap-6.html#OverridingAbstractTypes>Ridefinire i tipi astratti</a> del capitolo 6 abbiamo esaminato la nostra seconda versione del pattern Observer.

<pre><code>// <a href=esempi/cap-6/observer/observer2.scala>esempi/cap-6/observer/observer2.scala</a>

package observer

trait AbstractSubject {
  type Observer

  private var observers = List[Observer]()
  def addObserver(observer:Observer) = observers ::= observer
  def notifyObservers = observers foreach (notify(_))

  def notify(observer: Observer): Unit
}

trait SubjectForReceiveUpdateObservers extends AbstractSubject {
  type Observer = { def receiveUpdate(subject: Any) }

  def notify(observer: Observer): Unit = observer.receiveUpdate(this)
}

trait SubjectForFunctionalObservers extends AbstractSubject {
  type Observer = (AbstractSubject) =&gt; Unit

  def notify(observer: Observer): Unit = observer(this)
}</code></pre>

<p>Abbiamo usato questa versione per osservare i &#8220;clic&#8221; sui pulsanti in una interfaccia grafica. Rivisitiamo questa implementazione e risolviamone alcune limitazioni usando il nostro prossimo strumento per creare astrazioni scalabili, le <em>annotazioni self-type</em> combinate con i membri tipo astratti.

<h3 id=SelfTypeAnnotationsAndAbstractTypeMembers>Annotazioni self-type e membri tipo astratti</h3>

<p>Ci sono pochi aspetti della implementazione di <code>AbstractSubject</code> nella nostra seconda versione del pattern Observer che ci lasciano insoddisfatti. Il primo problema si trova in <code>SubjectForReceiveUpdateObservers</ocde>, dove il tipo <code>Observer</code> è definito come il tipo strutturale <code>{ def receiveUpdate(subject: Any) }</code>. Sarebbe meglio restringere il tipo di <code>subject</code> a qualcosa di più specifico di <code>Any</code>.

<p>Il secondo problema, che in realtà è uguale al primo ma si presenta in una forma differente, si trova in <code>SubjectForFunctionalObservers</code>, dove il tipo <code>Observer</code> è definito come il tipo <code>(AbstractSubject) =&gt; Unit</code>. Ci piacerebbe che l'argomento della funzione fosse qualcosa di più specifico di <code>AbstractSubject</code>. Forse questo inconveniente non era così evidente, prima, perché il nostro semplice esempio non ha mai avuto bisogno di accedere ai metodi o allo stato di <code>Button</code>.

<p>In effetti, ci aspettiamo che i tipi reali del soggetto e dell'osservatore vengano specializzati in maniera <em>covariante</em>. Per esempio, quando stiamo osservando un pulsante, ci aspettiamo che i nostri osservatori siano specializzati per <code>Button</code>, in modo da poter accedere allo stato e ai metodi delle istanze di <code>Button</code>. Questa specializzazione <em>covariante</em> viene talvolta chiamata <em>polimorfismo familiare</em> <a href=apa.html#Odersky2005>[Odersky2005]</a>. Correggiamo il nostro codice per supportare questa covarianza.

<p>Per semplificare l'esempio, concentriamoci solo sulla forma <code>receiveUpdate</code> dell'osservatore, che in precedenza avevamo implementato con <code>SubjectForReceiveUpdateObservers</code>. Ecco un <span class=wtf>rework</span> del nostro pattern che segue approssimativamente un esempio contenuto in <a href=apa.html#Odersky2005>[Odersky2005]</a>. Notate che, dal momento in cui l'articolo è stato scritto, la sintassi di Scala è abbastanza cambiata.

<pre><code>// <a href=esempi/cap-13/observer3-wont-compile.scala>esempi/cap-13/observer3-wont-compile.scala</a>
// Non verrà compilato!

package observer

abstract class SubjectObserver {
  type S &lt;: Subject
  type O &lt;: Observer

  trait Subject {
    private var observers = List[O]()
    def addObserver(observer: O) = observers ::= observer
    def notifyObservers = observers foreach (_.receiveUpdate(this)) // ERRORE
  }

  trait Observer {
    def receiveUpdate(subject: S)
  }
}</code></pre>

<p>Spiegheremo l'errore fra un minuto. Notate come sono stati dichiarati i tipi <code>S</code> e <code>O</code>. Come abbiamo visto nella sezione <a href=cap-12.html#ParameterizedTypes>Capire i tipi parametrici</a> del capitolo 12, l'espressione <code>type S &lt;: Subject</code> definisce un tipo astratto <code>S</code> dove i soli tipi concreti permessi saranno i sottotipi di <code>Subject</code>. La dichiarazione di <code>O</code> è simile. Per essere chiari, <code>S</code> e <code>O</code> sono &#8220;segnaposti&#8221; a questo punto, mentre <code>Subject</code> e <code>Observer</code> sono tratti astratti definiti in <code>SubjectObserver</code>.

<p><span class=wtf>By the way</span>, la scelta di dichiarare <code>SubjectObserver</code> come una classe astratta o come un tratto astratto è piuttosto arbitraria. Fra breve ne deriveremo oggetti concreti. <code>SubjectObserver</code> ci occorre principalmente per avere un tipo che &#8220;conservi&#8221; i nostri membri tipo astratti <code>S</code> e <code>O</code>.

<p>Tuttavia, se provate a compilare questo codice nel modo in cui è scritto, ottenete l'errore seguente.

<pre><samp>&hellip; 10: error: type mismatch;
 found   : SubjectObserver.this.Subject
 required: SubjectObserver.this.S
      def notifyObservers = observers foreach (_.receiveUpdate(this))
                                                               ^
one error found</samp></pre>

<p>Nel tratto <code>Observer</code> annidato, <code>receiveUpdate</code> si aspetta un'istanza di tipo <code>S</code>, ma noi gli stiamo passando <code>this</code>, che è di tipo <code>Subject</code>. In altre parole, sitamo passando un'istanza di un tipo genitore del tipo atteso. Una soluzione potrebbe essere modificare la firma per fare in modo che il tipo atteso sia il tipo genitore <code>Subject</code>, ma questo non è desiderabile. Abbiamo appena detto che i nostri osservatori concreti hanno bisogno del tipo più specifico, cioè l'effettivo tipo concreto che infine definiremo per <code>S</code>, in modo che possano invocare metodi su di esso. Per esempio, quando osservano le caselle di controllo in una interfaccia grafica, gli osservatori vorranno leggere se la casella è stata spuntata o meno. Non vogliamo obbligare gli osservatori a usare conversioni di tipo poco sicure.

<p>Abbiamo esaminato la composizione attraverso le <em>annotazioni self-type</em> nel capitolo 12, e ora usiamo quella funzionalità per risolvere il nostro attuale problema di compilazione. Ecco ancora lo stesso codice, ma questa volta con una annotazione self-type.

<pre><code>// <a href=esempi/cap-13/observer3.scala>esempi/cap-13/observer3.scala</a>

package observer

abstract class SubjectObserver {
  type S &lt;: Subject
  type O &lt;: Observer

  trait Subject {
    self: S =&gt;  // #1
    private var observers = List[O]()
    def addObserver(observer: O) = observers ::= observer
    def notifyObservers = observers foreach (_.receiveUpdate(self))  // #2
  }

  trait Observer {
    def receiveUpdate(subject: S)
  }
}</code></pre>

<p>Il commento <code>#1</code> mostra l'annotazione self-type <code>self: S =&gt;</code>. Ora possiamo usare <code>self</code> come un alias di <code>this</code>, ma ogni volta che apparirà, il tipo verrà assunto essere <code>S</code>, non <code>Subject</code>. &Egrave; come se stessimo dicendo a <code>Subject</code> di impersonare un altro tipo, ma in modo type-safe, come vedremo.

<p>In effetti, avremmo potuto usare <code>this</code> anziché <code>self</code> nell'annotazione, ma <code>self</code> è abbastanza convenzionale. Un nome differente ci ricorda anche che stiamo lavorando con un tipo differente.

<p>Le annotazioni self-type sono una funzionalità sicura da usare? Quando viene definito un sottotipo concreto di <code>SubjectObserver</code>, <code>S</code> e <code>O</code> verranno specificati e il controllo di tipo verrà effettuato per assicurarsi che i tipi concreti di <code>S</code> e <code>O</code> siano compatibili con <code>Subject</code> e <code>Observer</code>. In questo caso, dato che abbiamo anche definito <code>S</code> come sottotipo di <code>Subject</code> e <code>O</code> come sottotipo di <code>Observer</code>, una qualsiasi coppia di tipi derivati rispettivamente da <code>Subject</code> e <code>Observer</code> andrà bene.

<p>Il commento <code>#2</code> mostra che passiamo <code>self</code> anziché <code>this</code> a <code>receiveUpdate</code>.

<p>Ora che abbiamo una implementazione generica del pattern, possiamo specializzarla per osservare i clic sui pulsanti.

<pre><code>// <a href=esempi/cap-13/button-observer3.scala>esempi/cap-13/button-observer3.scala</a>

package ui
import observer._

object ButtonSubjectObserver extends SubjectObserver {
  type S = ObservableButton
  type O = ButtonObserver

  class ObservableButton(name: String) extends Button(name) with Subject {
    override def click() = {
      super.click()
      notifyObservers
    }
  }

  trait ButtonObserver extends Observer {
    def receiveUpdate(button: ObservableButton)
  }
}</code></pre>

<p>Dichiariamo un oggetto <code>ButtonSubjectObserver</code> in cui definiamo <code>S</code> e <code>O</code> rispettivamente come <code>ObservableButton</code> e <code>ButtonObserver</code>, che sono entrambi definiti nell'oggetto. Usiamo un <code>object</code> ora, in modo da poter fare riferimento facilmente ai tipi annidati, come vedremo fra breve.

<p><code>ObservableButton</code> è una classe concreta che ridefinisce <code>click</code> per <span class=wtf>notificare</span> gli osservatori, in maniera simile a quanto accadeva nella nostra precedente implementazione vista nel <a href=cap-4.html>capitolo 4</a>. Tuttavia, <code>ButtonObserver</code> è ancora un tratto astratto, perché <code>receiveUpdate</code> non è definito. Notate che il parametro di <code>receiveUpdate</code> ora è di tipo <code>ObservableButton</code>, che è il valore assegnato a <code>S</code>.

<p>L'ultimo pezzo del puzzle consiste nel definire un osservatore concreto. Come prima, conteremo i clic sul pulsante. Tuttavia, per enfatizzare il valore di avere un tipo specifico di istanza passato all'osservatore, <code>Button</code> in questo caso, <span class=wtf>we'll enhance</span> l'osservatore per tenere traccia dei clic su più pulsanti usando una mappa le cui chiavi siano le etichette dei pulsanti. Le conversioni di tipo non ci servono!

<pre><code>// <a href=esempi/cap-13/button-click-observer3.scala>esempi/cap-13/button-click-observer3.scala</a>

package ui
import observer._

class ButtonClickObserver extends ButtonSubjectObserver.ButtonObserver {
  val clicks = new scala.collection.mutable.HashMap[String,Int]()

  def receiveUpdate(button: ButtonSubjectObserver.ObservableButton) = {
    val count = clicks.getOrElse(button.label, 0) + 1
    clicks.update(button.label, count)
  }
}</code></pre>

<p>Ogni volta che <code>ButtonClickObserver.receiveUpdate</code> viene invocato, preleva il conto attuale per il pulsante, se esiste, e aggiorna la mappa con un conto incrementato. Notate che ora è impossibile invocare <code>receiveUpdate</code> con una normale istanza di <code>Button</code>: dobbiamo usare un'istanza di <code>ObservableButton</code>. Questa restrizione elimina i possibili bug per i quali non riceviamo le notifiche che ci aspettiamo. Inoltre, abbiamo accesso a tutte le funzioni &#8220;migliorate&#8221; di cui <code>ObservableButton</code> potrebbe disporre.

<p>Infine, ecco una specifica per esercitare il codice.

<pre><code>// <a href=esempi/cap-13/button-observer3-spec.scala>esempi/cap-13/button-observer3-spec.scala</a>

package ui
import org.specs._
import observer._

object ButtonObserver3Spec extends Specification {
  "Un osservatore che conta i clic su un pulsante" should {
    "vedere tutti i clic" in {
      val button1 = new ButtonSubjectObserver.ObservableButton("pulsante1")
      val button2 = new ButtonSubjectObserver.ObservableButton("pulsante2")
      val button3 = new ButtonSubjectObserver.ObservableButton("pulsante3")
      val buttonObserver = new ButtonClickObserver
      button1.addObserver(buttonObserver)
      button2.addObserver(buttonObserver)
      button3.addObserver(buttonObserver)
      clickButton(button1, 1)
      clickButton(button2, 2)
      clickButton(button3, 3)
      buttonObserver.clicks("pulsante1") mustEqual 1
      buttonObserver.clicks("pulsante2") mustEqual 2
      buttonObserver.clicks("pulsante3") mustEqual 3
    }
  }

  def clickButton(button: Button, nClicks: Int) =
    for (i &lt;- 1 to nClicks)
      button.click()
}</code></pre>

<p>Abbiamo creato tre pulsanti e un osservatore per tutti e tre. Poi facciamo clic sui pulsanti un numero differente di volte, e infine confermiamo che i clic sono stati correttamente conteggiati per ogni bottone.

<p>Ancora una volta, vediamo come i tipi astratti, combinati con le annotazioni self-type, offrono un'astrazione riusabile che è facile da estendere in modo type-safe per necessità particolari. Anche se abbiamo definito un protocollo generale per osservare un &#8220;evento&#8221; dopo che è accaduto, siamo stati in grado di definire sottotipi specifici di <code>Button</code> senza ricorrere a conversioni di tipo poco sicure a partire dalle astrazioni <code>Subject</code>.

<p>Lo stesso compilatore Scala è implementato usando questo meccanismo <a href=apa.html#Odersky2005>[Odersky2005]</a> per renderlo modulare in modi utili. Per esempio, è relativamente facile implementare plug-in per il compilatore.

<p>Rivisiteremo questi idiomi nella sezione <a href=#DependencyInjectionInScala>L'iniezione di dipendenza in Scala: il pattern torta</a> più avanti.

<h2 id=EffectiveTraitsDesign>La progettazione efficace dei tratti</h2>
<!-- TODO "diamante" vs. "rombo" -->
<p>Una delle ragioni per cui molti linguaggi (come Java) non implementano l'ereditarietà multipla è a causa dei problemi osservati con l'ereditarietà multipla in C++. Uno di questi problemi è il cosiddetto <em>diamante della morte</em>, illustrato nella <a href=#diamond-of-death>figura 13.1</a>.

<div class=figure id=diamond-of-death>
<p class=ft>Figura 13.1. Il diamante della morte nei linguaggi con ereditarietà multipla.
<p><img src=i/diamond-of-death.png alt="" width=432>
</div>

<p>In C++, ogni costruttore di <code>C</code> invocherà un costruttore di <code>B1</code> e un costruttore di <code>B2</code> (in maniera esplicita o implicita). Ogni costruttore di <code>B1</code> e ogni costruttore di <code>B2</code> invocherà un costruttore di <code>A</code>. Quindi, in una implementazione ingenua della ereditarietà multipla, i campi <code>a1</code> e <code>a2</code> di <code>A</code> potrebbero venire inizializzati <em>due volte</em> e potenzialmente in modo inconsistente, oppure potrebbero esserci due &#8220;pezzi&#8221; <code>A</code> differenti nell'istanza di <code>C</code>, uno per <code>B1</code> e uno per <code>B2</code>! C++ è dotato di meccanismi che chiarificano cosa dovrebbe succedere, ma tocca allo sviluppatore capire i dettagli e fare la cosa corretta.

<p>L'ereditarietà singola di Scala e il suo supporto per i tratti evitano questi problemi, pur offrendo il beneficio più importanti della ereditarietà multipla, cioè la composizione dei <em>mixin</em>. L'ordine di costruzione non è ambiguo (si veda la sezione <a href=cap-7.html#Linearization>Linearizzare la gerarchia di un oggetto</a> nel capitolo 7). I tratti non possono avere liste di argomenti per il costruttore, ma Scala si assicura che i loro campi siano inizializzati in maniera appropriata quando le istanze vengono create, come abbiamo visto nella sezione <a href=cap-4.html#ConstructingTraits>Costruire i tratti</a> del capitolo 4 e nella sezione <a href=cap-6.html#OverridingFieldsInTraits>Ridefinire i campi astratti e concreti nei tratti</a> del capitolo 6. Abbiamo visto un altro esempio di inizializzazione dei valori <code>val</code> in un tratto nella sezione <a href=#FineGrainedVisibilityRules>Regole di visibilità a grana fine</a> più sopra., dove abbiamo definito classi concrete che ridefinivano le definizioni dei due campi astratti del tratto <code>EncodedString</code>.

<p>Quindi, Scala gestisce molti problemi potenziali che sorgono quadno mescola i contributi di tratti diversi nell'insieme dei possibili stati di un'istanza. Rimane comunque importante considerare come i contributi di tratti diversi interagiscono tra loro.

<p>Nel considerare lo stato di un'istanza, è utile considerare l'istanza come se possedesse una <em>macchina a stati</em>, dove <em>eventi</em> (per esempio, l'invocazione di un metodo e la scrittura di un campo) causano transizioni da uno stato a un altro. L'insieme di tutti i possibili stati forma uno <em>spazio</em>. Potete pensare a ogni <em>campo</em> come se contribuisse una <em>dimensione</em> a questo spazio.

<p>Prendiamo come esempio il nostro tratto <code>VetoableClicks</code> usato nella sezione <a href=cap-4.html#StackableTraits>Tratti impilabili</a> del capitolo 4, dove i clic sui pulsanti venivano contati e i clic aggiuntivi venivano vietati dopo che un certo numero di clic era avvenuto. La nostra semplice classe <code>Button</code> contribuiva solo una <em>dimensione</em> <code>label</code>, mentre <code>VetoableClicks</code> contribuiva una <em>dimensione</em> <code>count</code> e una costante <code>maxAllowed</code>. Ecco una ricapitolazione di questi tipi, raccolti insieme in un singolo script che esercita anche il codice.

<pre><code>// <a href=esempi/cap-13/vetoable-clicks1-script.scala>esempi/cap-13/vetoable-clicks1-script.scala</a>

trait Clickable {
  def click()
}

class Widget
class Button(val label: String) extends Widget with Clickable {
  def click() = println("clic!")
}

trait VetoableClicks extends Clickable {
  val maxAllowed = 1
  private var count = 0
  abstract override def click() = {
    if (count &lt; maxAllowed) {
      count += 1
      super.click()
    }
  }
}

val button1 = new Button("cliccami!")
println("new Button(...)")
for (i &lt;- 1 to 3 ) button1.click()

val button2 = new Button("cliccami!") with VetoableClicks
println("new Button(...) with VetoableClicks")
for (i &lt;- 1 to 3 ) button2.click()</code></pre>

<p>Questo script stampa l'uscita seguente.

<pre><samp>new Button(...)
clic!
clic!
clic!
new Button(...) with VetoableClicks
clic!</samp></pre>

<p>Notate che <code>maxAllowed</code> è una costante, ma può essere ridefinita all'atto di creazione di ogni istanza. Quindi, due istanze possono differire solo nel valore di <code>maxAllowed</code>, perciò anche <code>maxAllowed</code> contribuisce una dimensione allo stato, ma con un solo valore per ogni istanza!

<p>Quindi, per un pulsante etichettato &#8220;Invia&#8221; con <code>maxAllowed</code> impostato a 3, e su cui è stato cliccato due volte (in modo che <code>count</code> sia uguale a 2), il proprio stato può essere rappresentato dalla tupla <code>("Invia", 2, 3)</code>.

<p>In generale, un singolo tratto può essere senza stato, cioè non contribuire alcuna dimensione allo stato dell'istanza, o può contribuire dimensioni <em>ortogonali</em> allo stato dell'istanza, cioè dimensioni che sono indipendenti dai contributi allo stato provenienti da altri tratti e dalla classe genitore. Nello script, <code>Clickable</code> è chiaramente senza stato (se ignoriamo l'etichetta del pulsante), mentre <code>VetoableClicks</code> contribuisce <code>maxAllowed</code> e <code>count</code>. I tratti con stato ortogonale spesso hanno anche metodi ortogonali. Per esempio, i tratti del pattern observer che abbiamo usato nel <a href=cap-4.html>capitolo 4</a> contenevano metodi per gestire la propria lista di osservatori.

<p>Indipendentemente dal fatto che un tratto contribuisca o meno dimensioni allo stato, un tratto può anche modificare i valori possibili per una dimensione contribuita da un tratto differente o dalla classe genitore. Per vedere un esempio, riorganizziamo lo script per spostare <code>count</code> nel tratto <code>Clickable</code>.

<pre><code>// <a href=esempi/cap-13/vetoable-clicks2-script.scala>esempi/cap-13/vetoable-clicks2-script.scala</a>

trait Clickable {
  private var clicks = 0
  def count = clicks

  def click() = { clicks += 1 }
}

class Widget
class Button(val label: String) extends Widget with Clickable {
  override def click() = {
    super.click()
    println("clic!")
  }
}

trait VetoableClicks extends Clickable {
  val maxAllowed = 1
  abstract override def click() = {
    if (count &lt; maxAllowed)
      super.click()
  }
}

val button1 = new Button("cliccami!")
println("new Button(...)")
for (i &lt;- 1 to 3 ) button1.click()

val button2 = new Button("cliccami!") with VetoableClicks
println("new Button(...) with VetoableClicks")
for (i &lt;- 1 to 3 ) button2.click()</code></pre>

<p>Questo script stampa la stessa uscita di prima. Ora <code>Clickable</code> contribuisce una dimensione per <code>count</code> (che ora è un metodo che restituisce il valore del campo privato <code>clicks</code>). <code>VetoableClicks</code> <em>modifica</em> questa dimensione riducendo il numero di possibili valori per <code>count</code> da <code>0</code> a infinito a solo <code>0</code> e <code>1</code>. Quindi, un tratto influenza il <em>comportamento</em> di un altro. Potremmo dire che <code>VetoableClicks</code> è <em>invasivo</em>, perché modifica il comportamento di altri mixin.

<p>Perché tutto questo è importante? Sebbene i problemi della ereditarietà multipla siano eliminati nel modello di ereditarietà singola più i tratti di Scala, è necessario fare attenzione quando si mescolano i contributi in termini di stato e comportamento per creare applicazioni <span class=wtf>well-behaved</span>. Per esempio, se avete una serie di test che <code>Button</code> passa con successo, un'istanza di <code>Button with VetoableClicks</code> passerà la stessa serie di test? La risposta è negativa se i testi presumono che voi possiate cliccare sui pulsanti tutte le volte che volete. Questi due tipi di pulsanti hanno &#8220;specifiche&#8221; differenti. Questa differenza viene espressa dal <em>principio di sostituzione di Liskov</em> <a href=apa.html#Martin2003>[Martin2003]</a>. Un'istanza di <code>Button with VetoableClicks</code> non sarà <em>sostituibile</em> in tutte le situazioni in cui viene usata una normale istanza di <code>Button</code>. Questa è una conseguenza della natura invasiva di <code>VetoableClicks</code>.

<p>Quando un tratto aggiunge solo stato e comportamento ortogonale senza influenzare il resto dello stato e del comportamento dell'istanza, rende il riuso e la composizione molto più semplici, e riduce le possibilità di bug. Le implementazioni del pattern Observer che abbiamo visto sono piuttosto riusabili. L'unico requisito per poterle riutilizzare è quello di fornire un po' di &#8220;colla&#8221; per adattare i tratti generici del soggetto e dell'osservatore alle particolari circostante.

<p>Questo non significa che i mixin invasivi siano un male, ma solo che dovrebbero essere usati a ragion veduta. Il pattern degli &#8220;eventi vietabili&#8221; può rivelarsi molto utile.

<h2 id=DesignPatterns>I pattern di progettazione</h2>

<p>Ultimamente i pattern di progettazione sono stati <span class=wtf>beating</span>. I critici li accantonano considerandoli <span class=wtf>workaround</span> per le caratteristiche mancanti di un linguaggio. In effetti, alcuni dei pattern della <em>Gang of Four</em> <a href=apa.html#GOF1995>[GOF1995]</a> non sono davvero necessari in Scala, dato che le caratteristiche native offrono sostituti migliori. Altri pattern sono parte del linguaggio stesso, quindi non è necessario organizzare il codice in un modo particolare. Naturalmente, non è colpa dei pattern se di loro si fa spesso un cattivo uso.

<p>Riteniamo che le critiche abbiano spesso trascurato un punto importante: la distinzione tra un'idea e il modo in cui viene implementata e usata in una certa situazione. I pattern di progettazione documentano idee ricorrenti e assai utili. Queste idee sono parte del <em>vocabolario</em> che gli sviluppatori di software usano per descrivere i loro progetti.

<p>Alcuni pattern comuni sono caratteristiche native del linguaggio in Scala, come gli oggetti <em>singleton</em> che eliminano il bisogno di implementare il pattern <em>Singleton</em> <a href=apa.html#GOF1995>[GOF1995]</a> nel modo in cui si vede spesso nel codice Java.

<p>Il pattern <em>Iterator</em> <a href=apa.html#GOF1995>[GOF1995]</a> è talmente pervasivo che la maggior parte dei linguaggi di programmazione includono un meccanismo di iterazione per qualsiasi tipo possa essere trattato come una collezione. Per esempio, in Scala potete iterare attraverso i caratteri di una stringa usando il metodo <code>foreach</code> di <code>String</code>.

<pre><code>"Programmare in Scala" foreach {c =&gt; println(c)}</code></pre>

<p>In effetti, in questo caso viene invocata una conversione implicita per convertire l'istanza di <code>java.lang.String</code> in un'istanza di <code>RichString</code> dotata del metodo <code>foreach</code>. Questo è un esempio di un pattern chiamato <em>decora la mia libreria</em>, che abbiamo menzionato nella sezione <a href=cap-8.html#ImplicitConversions>Conversioni implicite</a> del capitolo 8.

<p>Altri pattern comuni hanno alternative migliori in Scala. Esamineremo un'alternativa migliore al pattern <em>Visitor</em> <a href=apa.html#GOF1995>[GOF1995]</a> fra un momento.

<p>Infine, altri pattern ancora possono essere implementati in Scala e rimangono molto utili. Per esempio, il pattern <em>Observer</em> che abbiamo esaminato in precedenza sia in questo capitolo sia nel <a href=cap-4.html>capitolo 4</a> è un pattern molto utile per risolvere numerosi problemi di progettazione. Può essere implementato in maniera molto elegante usando la composizione dei mixin.

<p>Non esamineremo tutti i pattern più conosciuti, come quelli contenuti in <a href=apa.html#GOF1995>[GOF1995]</a>. Un certo numero di pattern catalogati dalla <em>Gang of Four</em> vengono analizzati in <a href=apa.html#ScalaWikiPatterns>[ScalaWiki:Patterns]</a> insieme ad altri pattern che sono piuttosto specifici per Scala. Invece, esamineremo alcuni esempi illustrativi, cominciando da un rimpiazzo per il pattern <em>Visitor</em> che usa idiomi funzionali e conversioni implicite. Poi esamineremo un modo potente per implementare la <em>iniezione di dipendenza</em> in Scala usando il pattern <em>Cake</em>.

<h3 id=VisitorAlternativeInScala>Il pattern Visitor: un'alternativa migliore</h3>

<p>Il pattern <em>Visitor</em> <a href=apa.html#GOF1995>[GOF1995]</a> risolve il problema di aggiungere una nuova operazione a una gerarchia di classi senza modificare il codice sorgente delle classi nella gerarchia. Per un certo numero di ragioni pratiche, potrebbe non essere fattibile o desiderabile modificare la gerarchia per supportare la nuova operazione.

<p>Esaminiamo un esempio di questo pattern usando la gerarchia di classi <code>Shape</code> che abbiamo visto in precedenza. Cominceremo con la versione a classi <code>case</code> illustrata nella sezione <a href=cap-6.html#CaseClasses>Classi <code>case</code></a> del capitolo 6.

<pre><code>// <a href=esempi/cap-6/shapes/shapes-case.scala>esempi/cap-6/shapes/shapes-case.scala</a>

package shapes {
  case class Point(x: Double, y: Double)

  abstract class Shape() {
    def draw(): Unit
  }

  case class Circle(center: Point, radius: Double) extends Shape() {
    def draw() = println("Circle.draw: " + this)
  }

  case class Rectangle(lowerLeft: Point, height: Double, width: Double)
      extends Shape() {
    def draw() = println("Rectangle.draw: " + this)
  }

  case class Triangle(point1: Point, point2: Point, point3: Point)
      extends Shape() {
    def draw() = println("Triangle.draw: " + this)
  }
}</code></pre>

<p>Supponete di non volere che il metodo <code>draw</code> sia presente nelle classi. Questa è una decisione di progetto ragionevole, dato che il metodo di disegno dipenderà grandemente dal particolare contesto d'uso, come per esempio i dettagli delle librerie grafiche della piattaforma sulla quale l'applicazione verrà eseguita. Per garantire un'elevata riusabilità, vorremmo che il disegno fosse un'operazione disaccoppiata dalle forme geometriche.

<p>Prima di tutto, riorganizziamo la gerarchia di <code>Shape</code> per supportare il pattern <em>Visitor</em>, seguendo l'esempio contenuto in <a href=apa.html#GOF1995>[GOF1995]</a>.

<pre><code>// <a href=esempi/cap-13/shapes-visitor.scala>esempi/cap-13/shapes-visitor.scala</a>

package shapes {
  trait ShapeVisitor {
    def visit(circle: Circle): Unit
    def visit(rect: Rectangle): Unit
    def visit(tri: Triangle): Unit
  }

  case class Point(x: Double, y: Double)

  sealed abstract class Shape() {
    def accept(visitor: ShapeVisitor): Unit
  }

  case class Circle(center: Point, radius: Double) extends Shape() {
    def accept(visitor: ShapeVisitor) = visitor.visit(this)
  }

  case class Rectangle(lowerLeft: Point, height: Double, width: Double)
        extends Shape() {
    def accept(visitor: ShapeVisitor) = visitor.visit(this)
  }

  case class Triangle(point1: Point, point2: Point, point3: Point)
        extends Shape() {
    def accept(visitor: ShapeVisitor) = visitor.visit(this)
  }
}</code></pre>

<p>Abbiamo definito un tratto <code>ShapeVisitor</code> dotato di un metodo per ogni classe concreta nella gerarchia, per esempio <code>visit(circle: Circle)</code>. Ognuno di questi metodi accetta un parametro del tipo corrispondente da visitare. Le classi concrete derivate implementeranno ognuno di questi metodi per effettuare l'operazione appropriata sul particolare tipo passato come argomento.

<p>Il pattern richiede una singola modifica alla gerarchia delle classi: è necessario aggiungere un metodo ridefinito chiamato <code>accept</code>, che prende come parametro un <code>Visitor</code>. Questo metodo deve essere ridefinito in ogni classe per invocare il metodo corrispondente definito nell'istanza del visitatore passandogli <code>this</code> come argomento.

<p>Infine, notate che abbiamo dichiarato <code>Shape</code> come <code>sealed</code>. Questo non ci aiuterà a evitare alcuni bug nella implementazione del pattern, ma si dimostrerà utile fra breve.

<p>Ecco un visitatore concreto che supporta la nostra operazione <code>draw</code> originale.

<pre><code>// <a href=esempi/cap-13/shapes-drawing-visitor.scala>esempi/cap-13/shapes-drawing-visitor.scala</a>

package shapes {
  class ShapeDrawingVisitor extends ShapeVisitor {
    def visit(circle: Circle): Unit =
      println("Circle.draw: " + circle)

    def visit(rect: Rectangle): Unit =
      println("Rectangle.draw: " + rect)

    def visit(tri: Triangle): Unit =
      println("Triangle.draw: " + tri)
  }
}</code></pre>

<p>Per ogni metodo <code>visit</code>, la classe &#8220;disegna&#8221; l'istanza di <code>Shape</code> in maniera appropriata. Infine, ecco uno script che esercita il codice.

<pre><code>// <a href=esempi/cap-13/shapes-drawing-visitor-script.scala>esempi/cap-13/shapes-drawing-visitor-script.scala</a>

import shapes._

val p00 = Point(0.0, 0.0)
val p10 = Point(1.0, 0.0)
val p01 = Point(0.0, 1.0)

val list = List(Circle(p00, 5.0),
                Rectangle(p00, 2.0, 3.0),
                Triangle(p00, p10, p01))

val shapesDrawer = new ShapeDrawingVisitor
list foreach { _.accept(shapesDrawer) }</code></pre>

<p>L'esecuzione di questo script produce l'uscita seguente.

<pre><samp>draw: Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))</samp></pre>

<p>Il pattern Visitor è stato criticato per essere piuttosto inelegante e per violare il <em>principio aperto-chiuso</em> (anche noto come <abbr>OCP</abbr>, dall'inglese <em>Open-Closed Principle</em>) <a href=apa.html#Martin2003>[Martin2003]</a>, perché se la gerarchia cambia siete obbligati a modificare (e collaudare e <span class=wtf>redeploy</span>) <em>tutti</em> i visitatori di quella gerarchia. Notate che tutti i tratti <code>ShapeVisitor</code> dispongono di metodi in cui sono cablate le informazioni su ogni tipo derivato da <code>Shape</code>. Questo genere di modifiche è anche soggetto a errore.

<p>In linguaggi con &#8220;tipi aperti&#8221; come Ruby l'alternativa al pattern Visitor consiste nel creare un nuovo file sorgente che riapre le definizioni di tutti i tipi della gerarchia e inserisce l'implementazione di un metodo appropriato in ognuna di esse.

<p>Scala non supporta i tipi aperti, naturalmente, ma offre alcune alternative. Il primo approccio che esamineremo combina il pattern matching con le conversioni implicite. Cominciamo col riorganizzare il codice di <code>ShapeVisitor</code> per rimuovere la logica del pattern Visitor.

<pre><code>// <a href=esempi/cap-13/shapes.scala>esempi/cap-13/shapes.scala</a>

package shapes2 {
  case class Point(x: Double, y: Double)

  sealed abstract class Shape()

  case class Circle(center: Point, radius: Double) extends Shape()

  case class Rectangle(lowerLeft: Point, height: Double, width: Double)
      extends Shape()

  case class Triangle(point1: Point, point2: Point, point3: Point)
      extends Shape()
}</code></pre>

<p>Se volessimo invocare <code>draw</code> come un metodo su qualsiasi istanza di <code>Shape</code>, allora dovremmo usare una conversione implicita verso una classe avvolgente che dispone del metodo <code>draw</code>.

<pre><code>// <a href=esempi/cap-13/shapes-drawing-implicit.scala>esempi/cap-13/shapes-drawing-implicit.scala</a>

package shapes2 {
  class ShapeDrawer(val shape: Shape) {
    def draw = shape match {
      case c: Circle    =&gt; println("Circle.draw: " + c)
      case r: Rectangle =&gt; println("Rectangle.draw: " + r)
      case t: Triangle  =&gt; println("Triangle.draw: " + t)
    }
  }

  object ShapeDrawer {
    implicit def shape2ShapeDrawer(shape: Shape) = new ShapeDrawer(shape)
  }
}</code></pre>

<p>Le istanze di <code>ShapeDrawer</code> racchiudono un oggetto <code>Shape</code>. Quando <code>draw</code> viene invocato, il pattern matching determina il modo appropriato di disegnare la forma geometrica sulla base del tipo della forma.

<p>Un oggetto associato dichiara una conversione implcita che avvolge un'istanza di <code>Shape</code> in un'istanza di <code>ShapeDrawer</code>.

<p>Questo script esercita il codice.

<pre><code>// <a href=esempi/cap-13/shapes-drawing-implicit-script.scala>esempi/cap-13/shapes-drawing-implicit-script.scala</a>

import shapes2._

val p00 = Point(0.0, 0.0)
val p10 = Point(1.0, 0.0)
val p01 = Point(0.0, 1.0)

val list = List(Circle(p00, 5.0),
                Rectangle(p00, 2.0, 3.0),
                Triangle(p00, p10, p01))

import shapes2.ShapeDrawer._

list foreach { _.draw }</code></pre>

<p>Lo script produce la stessa uscita dell'esempio che usava il pattern Visitor.

<p>Questa implementazione di <code>ShapeDrawer</code> ha alcune analogie con il pattern Visitor, ma è più concisa, elegante, e non richiede modifiche al codice della gerarchia di <code>Shape</code> originale.

<p>Tecnicamente, questa implementazione ha gli stessi problemi di <abbr>OCP</abbr> del pattern Visitor. Una modifica alla gerarchia di <code>Shape</code> richiede una modifica alla espressione di pattern matching. Tuttavia, le modifiche richieste sono isolate in un unico punto e sono più concise. In effetti, tutta la logica per il disegno ora è contenuta in un unico luogo piuttosto che separata nei metodi <code>draw</code> di ogni classe derivata da <code>Shape</code> e potenzialmente sparpagliata in file differenti. Notate che, avendo sigillato la gerarchia, otterremo un errore di compilazione in <code>draw</code> se ci dimentichiamo di modificarlo quando la gerarchia cambia.

<p>Se non ci piace il pattern matching nel metodo di disegno, potremmo implementare una classe &#8220;disegnatrice&#8221; e una conversione implicita separata per ogni classe derivata da <code>Shape</code>. Questo ci permetterebbe di mantenere ogni operazione di disegno in un file separato, per la modularità, con lo svantaggio di avere più codice e più file da gestire.

<p>Se, d'altra parte, non ci importa molto di usare la sintassi orientata agli oggetti nella invocazione di <code>shape.draw</code>, potremmo eliminare la conversione implicita ed eseguire lo stesso pattern matching che viene fatto nel metodo <code>ShapeDrawer.draw</code>. Questo approccio potrebbe risultare più semplice, in particolare quando il comportamento aggiuntivo può essere isolato in un unico punto. In effetti, questo approccio sarebbe un approccio funzionale convenzionale, come illustrato nello script seguente.

<pre><code>// <a href=esempi/cap-13/shapes-drawing-pattern-script.scala>esempi/cap-13/shapes-drawing-pattern-script.scala</a>

import shapes2._

val p00 = Point(0.0, 0.0)
val p10 = Point(1.0, 0.0)
val p01 = Point(0.0, 1.0)

val list = List(Circle(p00, 5.0),
                Rectangle(p00, 2.0, 3.0),
                Triangle(p00, p10, p01))

val drawText = (shape:Shape) =&gt; shape match {
  case circle: Circle =&gt;  println("Circle.draw: " + circle)
  case rect: Rectangle =&gt; println("Rectangle.draw: " + rect)
  case tri: Triangle =&gt;   println("Triangle.draw: " + tri)
}

def pointToXML(point: Point) =
  "&lt;point&gt;&lt;x&gt;%.1f&lt;/x&gt;&lt;y&gt;%.1f&lt;/y&gt;&lt;/point&gt;".format(point.x, point.y)

val drawXML = (shape:Shape) =&gt; shape match {
  case circle: Circle =&gt;  {
    println("&lt;circle&gt;")
    println("  &lt;center&gt;" + pointToXML(circle.center) + "&lt;/center&gt;")
    println("  &lt;radius&gt;" + circle.radius + "&lt;/radius&gt;")
    println("&lt;/circle&gt;")
  }
  case rect: Rectangle =&gt; {
    println("&lt;rectangle&gt;")
    println("  &lt;lower-left&gt;" + pointToXML(rect.lowerLeft) + "&lt;/lower-left&gt;")
    println("  &lt;height&gt;" + rect.height + "&lt;/height&gt;")
    println("  &lt;width&gt;" + rect.width + "&lt;/width&gt;")
    println("&lt;/rectangle&gt;")
  }
  case tri: Triangle =&gt; {
    println("&lt;triangle&gt;")
    println("  &lt;point1&gt;" + pointToXML(tri.point1) + "&lt;/point1&gt;")
    println("  &lt;point2&gt;" + pointToXML(tri.point2) + "&lt;/point2&gt;")
    println("  &lt;point3&gt;" + pointToXML(tri.point3) + "&lt;/point3&gt;")
    println("&lt;/triangle&gt;")
  }
}

list foreach (drawText)
println("")
list foreach (drawXML)</code></pre>

<p>Abbiamo definito due <em>valori funzione</em> e li abbiamo assegnati alle variabili <code>drawText</code> e <code>drawXML</code>, rispettivamente. Ogni funzione <code>drawX</code> accetta in ingresso un'istanza di <code>Shape</code>, ne esegue il pattern matching sul tipo, e la &#8220;disegna&#8221; correttamente. Abbiamo anche definito un metodo di utilità per convertire un'istanza di <code>Point</code> nel formato <abbr>XML</abbr> che vogliamo.

<p>Infine, iteriamo due volte attraverso la lista delle forme geometriche. La prima volta passiamo <code>drawText</code> come argomento a <code>foreach</code>, la seconda volta passiamo <code>drawXML</code>. L'esecuzione di questo script riproduce il risultato precedente per il disegno &#8220;testuale&#8221;, seguito dal nuovo risultato in formato <abbr>XML</abbr>.

<pre><samp>Circle.draw: Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))

&lt;circle&gt;
  &lt;center&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/center&gt;
  &lt;radius&gt;5.0&lt;/radius&gt;
&lt;/circle&gt;
&lt;rectangle&gt;
  &lt;lower-left&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/lower-left&gt;
  &lt;height&gt;2.0&lt;/height&gt;
  &lt;width&gt;3.0&lt;/width&gt;
&lt;/rectangle&gt;
&lt;triangle&gt;
  &lt;point1&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/point1&gt;
  &lt;point2&gt;&lt;point&gt;&lt;x&gt;1.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/point2&gt;
  &lt;point3&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;1.0&lt;/y&gt;&lt;/point&gt;&lt;/point3&gt;
&lt;/triangle&gt;</samp></pre>

<p>Ognuno di questi idiomi offre un modo potente per aggiungere ulteriori funzionalità particolari che potrebbero non essere necessarie &#8220;ovunque&#8221; nell'applicazione. &Egrave; un modo fantastico per rimuovere metodi che non <em>devono assolutamente essere presenti</em> negli oggetti.

<p>Un'applicazione per il disegno dovrebbe solo aver bisogno di sapere come prendere in ingresso e restituire in uscita le forme geometriche, sia che le stia serializzando in un formato di testo per memorizzarle su disco o che le stia mostrando sullo schermo. Possiamo separare l'&#8220;interesse&#8221; del disegno dal resto delle funzioni per le forme geometriche e possiamo isolare la logica per il disegno, il tutto senza modificare la gerarchia di <code>Shape</code> o i punti in cui viene usata all'interno dell'applicazione. Il pattern Visitor ci offre una parte di questa separazione e isolamento, ma ci obbliga ad aggiungere logica alle implementazioni dei visitatori per ogni sottotipo di <code>Shape</code>.

<p>Per concludere, esaminiamo una delle altre opzioni disponibili in alcuni contesti. Se avete il controllo completo su come le forme geometriche vengono costruite, per esempio tramite una singola factory, potete modificare la factory per mescolare tratti che aggiungono nuovi comportamenti <span class=wtf>as needed</span>.

<pre><code>// <a href=esempi/cap-13/shapes-drawing-factory.scala>esempi/cap-13/shapes-drawing-factory.scala</a>

package shapes2 {
  trait Drawing {
    def draw: Unit
  }

  trait CircleDrawing extends Drawing {
    def draw = println("Circle.draw " + this)
  }
  trait RectangleDrawing extends Drawing {
    def draw = println("Rectangle.draw: " + this)
  }
  trait TriangleDrawing extends Drawing {
    def draw = println("Triangle.draw: " + this)
  }

  object ShapeFactory {
    def makeShape(args: Any*) = args(0) match {
      case "cerchio" =&gt; {
        val center = args(1).asInstanceOf[Point]
        val radius = args(2).asInstanceOf[Double]
        new Circle(center, radius) with CircleDrawing
      }
      case "rettangolo" =&gt; {
        val lowerLeft = args(1).asInstanceOf[Point]
        val height    = args(2).asInstanceOf[Double]
        val width     = args(3).asInstanceOf[Double]
        new Rectangle(lowerLeft, height, width) with RectangleDrawing
      }
      case "triangolo" =&gt; {
        val p1 = args(1).asInstanceOf[Point]
        val p2 = args(2).asInstanceOf[Point]
        val p3 = args(3).asInstanceOf[Point]
        new Triangle(p1, p2, p3) with TriangleDrawing
      }
      case x =&gt; throw new IllegalArgumentException("sconosciuto: " + x)
    }
  }
}</code></pre>
<!-- TODO "hack" = "espedienti"? (più modifica del verbo "minimizzare"? -->
<p>Abbiamo definito un tratto <code>Drawing</code> e un tratto concreto derivato per ognuna delle classi nella gerarchia di <code>Shape</code>. Poi abbiamo definito un oggetto <code>ShapeFactory</code> con un metodo factory <code>makeShape</code> che prende una lista di argomenti a lunghezza variabile. Questo metodo esegue il pattern matching sul primo argomento per deterinare quale forma geometrica creare. Gli argomenti che seguono vengono convertiti ai tipi appropriati per costruire ogni forma, mescolando il corrispondente tratto per il disegno. Una factory simile potrebbe essere scritta per aggiungere metodi di disegno che generano codice <abbr>XML</abbr>. (La lista di valori <code>Any</code> a lunghezza variabile, l'uso esteso delle conversioni di tipo, e il controllo minimale sugli errori sono stati impiegati per convenienza. Una implementazione reale potrebbe minimizzare questi &#8220;<span class=wtf>hack</span>&#8221;.)

<p>Lo script seguente esercita la factory.

<pre><code>// <a href=esempi/cap-13/shapes-drawing-factory-script.scala>esempi/cap-13/shapes-drawing-factory-script.scala</a>

import shapes2._

val p00 = Point(0.0, 0.0)
val p10 = Point(1.0, 0.0)
val p01 = Point(0.0, 1.0)

val list = List(
    ShapeFactory.makeShape("cerchio", p00, 5.0),
    ShapeFactory.makeShape("rettangolo", p00, 2.0, 3.0),
    ShapeFactory.makeShape("triangolo", p00, p10, p01))

list foreach { _.draw }</code></pre>

<p>Rispetto ai nostri script precedenti, ora la lista di forme geometriche viene costruita usando la factory. Quando vogliamo disegnare le forme nell'istruzione <code>foreach</code>, invochiamo semplicemente <code>draw</code> su ogni forma. Come prima, il risultato è il seguente.

<pre><samp>Circle.draw Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))</samp></pre>

<p>Questo approccio ha una sottigliezza che dovremmo considerare. Notate che lo script non assegna mai il risultato di una invocazione di <code>ShapeFactory.makeShape</code> a una variabile di tipo <code>Shape</code>. Se lo facesse, non sarebbe in grado di invocare il metodo <code>draw</code> sull'istanza!

<p>In questo script, Scala ha inferito un supertipo comune leggermente diverso per la lista parametrica. Potete vedere quel tipo se usate il comando <code>:load</code> per caricare lo script dall'interno dell'interprete interattivo <kbd>scala</kbd>, come nella sessione seguente.

<pre><samp>$ scala -cp &hellip;
Welcome to Scala version 2.8.0.final (Java &hellip;).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; :load shapes-drawing-factory-script.scala
Loading shapes-drawing-factory-script.scala...
import shapes2._
p00: shapes2.Point = Point(0.0,0.0)
p10: shapes2.Point = Point(1.0,0.0)
p01: shapes2.Point = Point(0.0,1.0)
list: List[Product with shapes2.Shape with shapes2.Drawing] = List(&hellip;)
Circle.draw Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))

scala&gt;</code></pre>

<p>Notate la riga che comincia con <code>list: List[Product with shapes2.Shape with shapes2.Drawing]</code>. Questa riga è stata stampata dopo che la lista di forme geometriche è stata riconosciuta. Il supertipo comune inferito è <code>Product with shapes2.Shape with shapes2.Drawing</code>. <code>Product</code> è un tratto mescolato in tutte le classi <code>case</code>, come le nostre sottoclassi concrete di <code>Shape</code>. Non dimenticate che, per evitare i problemi con l'ereditarietà tra le classi <code>case</code>, la classe <code>Shape</code> alla radice della gerarchia non è una classe <code>case</code> (si veda la sezione <a href=cap-6.html#CaseClasses>Classi <code>case</code></a> del capitolo 6 per una motivazione dettagliata per cui l'ereditarietà tra le classi <code>case</code> dovrebbe essere evitata). Quindi, il nostro supertipo comune è una classe anonima che incorpora <code>Shape</code>, <code>Product</code> e il tratto <code>Drawing</code>.

<p>Se volete assegnare una di queste forme geometriche disegnabili a una varibile e nello stesso tempo essere in grado di invocare <code>draw</code>, potete usare una dichiarazione come quella riportata di seguito (mostrata nel contesto della stessa sessione interattiva di <kbd>scala</kbd>).

<pre><code>scala&gt; val s: Shape with Drawing = ShapeFactory.makeShape("cerchio", p00, 5.0)
s: shapes2.Shape with shapes2.Drawing = Circle(Point(0.0,0.0),5.0)

scala&gt; s.draw
Circle.draw Circle(Point(0.0,0.0),5.0)

scala&gt;</code></pre>

<h3 id=DependencyInjectionInScala>L'iniezione di dipendenza in Scala: il pattern Cake</h3>

<p>La <em>iniezione di dipendenza</em> (anche nota come <abbr>DI</abbr>, dall'inglese <em>Dependency Injection</em>), una forma di <em>inversione del controllo</em> (<abbr>IoC</abbr>), è una tecnica potente per risolvere le dipendenze tra i &#8220;componenti&#8221; di applicazioni più grandi. Essa supporta la minimizzazione delle dipendenze tra questi componenti, quindi è relativamente facile sostituire componenti differenti in circostanze differenti.

<p>Di solito capitava che, quando un oggetto cliente aveva bisogno di un oggetto per accedere a un database, per esempio, l'oggetto cliente lo avrebbe creato. Pur conveniente, questo approccio ha reso il collaudo di unità molto difficile, perché vi obbligava a effettuare i test su un vero database. Inoltre, comprometteva la riusabilità, in quelle situazioni alternative in cui era necessario un altro meccanismo di persistenza (o in cui la persistenza non era richiesta). L'inversione del controllo risolve questo problema ribaltando la responsabilità di soddifare le dipendenze tra l'oggetto e la connessione al database.

<p>Un esempio di inversione del controllo è <abbr>JNDI</abbr>. Anziché istanziare un oggetto di accesso, l'oggetto cliente chiede a <abbr>JNDI</abbr> di fornirgliene uno. Al cliente non interessa qual è il tipo dell'oggetto di accesso restituito, perciò non è più legato a una implementazione concreta della dipendenza. Il cliente dipende solo da un'<em>astrazione</em> appropriata per l'accesso alla persistenza, cioè da una interfaccia Java o un tratto Scala.

<p>L'iniezione di dipendenza porta l'inversione del controllo alla sua conclusione logica. Ora l'oggetto non fa nulla per risolvere la dipendenza. Invece, è un meccanismo esterno che conosce l'intero sistema a &#8220;iniettare&#8221; l'oggetto di accesso appropriato usando un argomento del costruttore o un metodo di scrittura di un valore. Questo avviene quando il cliente viene costruito. La <abbr>DI</abbr> elimina le dipendenze dai meccanismi di inversione del controllo nel codice (per esempio, non ci sono più le invocazioni a <abbr>JNDI</abbr>) e mantiene gli oggetti relativamente semplici, con una dipendenza minimale nei confronti degli altri oggetti.

<p>Tornando al collaudo di unità, è preferibile usare un <em class=wtf>test double</em> per le dipendenze più pesanti, in modo da minimizzare il costo aggiuntivo e le ulteriori compilcazioni del collaudo. Il nostro oggetto cliente con una dipendenza nei confronti di un oggetto per accedere al database è un esempio classico. Nel collaudare il cliente, il costo aggiuntivo e le complicazioni di usare un vero database sono proibitive. Usare un <span class=wtf>test double</span> leggero con dati campione cablati offre una preparazione e una <span class=wtf>demolizione</span> più semplice, un'esecuzione più veloce e un comportamento predicibile da parte dell'oggetto di accesso ai dati da cui dipende il cliente.

<p>In Java, di solito la <abbr>DI</abbr> viene realizzata usando un contenitore per l'inversione del controllo, come il framework Spring <a href=apa.html#SpringFramework>[SpringFramework]</a>, o una <abbr>API</abbr> Java equivalente, come la <abbr>API</abbr> Guice di Google <a href=apa.html#Guice>[Guice]</a>. Queste opzioni possono essere usate con il codice Scala, in particolare quando state introducendo Scala in un ambiente Java maturo.

<p>Tuttavia, Scala vi offre alcune opzioni uniche per implementare la <abbr>DI</abbr> nel codice Scala, esaminate in <a href=apa.html#Boner2008b>[Bon&#233;r2008b]</a>. Tra queste, ci concentreremo sul pattern <em>Cake</em>, che può sostituire o complementare questi altri meccanismi di iniezione di dipendenza. Vedremo che è simile all'implementazione del pattern Observer che abbiamo esaminato verso l'inizio di questo capitolo, nella sezione <a href=#SelfTypeAnnotationsAndAbstractTypeMembers>Annotazioni self-type e membri tipo astratti</a>. Il pattern Cake è stato descritto in <a href=apa.html#Odersky2005>[Odersky2005]</a>, anche se gli è stato dato questo nome dopo la pubblicazione dell'articolo. <a href=apa.html#Boner2008b>[Bon&#233;r2008b]</a> ne esamina anche alcune alternative.

<p>Costruiamo un semplice modello a componenti per un client Twitter estramamente semplificato. Vogliamo una interfaccia utente configurabile, una memoria locale configurabile per i messaggi passati, e una connessione configurabile al servizio offerto da Twitter. Ognuno di questi &#8220;componenti&#8221; verrà specificato separatamente, insieme a un componente cliente che funzionerà come &#8220;middleware&#8221; per legare insieme le parti dell'applicazione. Il componente cliente dipenderà dagli altri componenti. Quando creaimo un cliente concreto, lo configuereremo nei pezzi concreti degli altri componenti di cui abbiamo bisogno.

<pre><code>// <a href=esempi/cap-13/twitter-client.scala>esempi/cap-13/twitter-client.scala</a>

package twitterclient
import java.util.Date
import java.text.DateFormat

class TwitterUserProfile(val userName: String) {
  override def toString = "@" + userName
}

case class Tweet(
  val tweeter: TwitterUserProfile,
  val message: String,
  val time: Date) {

  override def toString = "(" +
    DateFormat.getDateInstance(DateFormat.FULL).format(time) + ") " +
    tweeter + ": " + message
}

trait Tweeter {
  def tweet(message: String)
}

trait TwitterClientUIComponent {
  val ui: TwitterClientUI

  abstract class TwitterClientUI(val client: Tweeter) {
    def sendTweet(message: String) = client.tweet(message)
    def showTweet(tweet: Tweet): Unit
  }
}

trait TwitterLocalCacheComponent {
  val localCache: TwitterLocalCache

  trait TwitterLocalCache {
    def saveTweet(tweet: Tweet): Unit
    def history: List[Tweet]
  }
}

trait TwitterServiceComponent {
  val service: TwitterService

  trait TwitterService {
    def sendTweet(tweet: Tweet): Boolean
    def history: List[Tweet]
  }
}

trait TwitterClientComponent {
  self: TwitterClientUIComponent with
        TwitterLocalCacheComponent with
        TwitterServiceComponent =&gt;

  val client: TwitterClient

  class TwitterClient(val user: TwitterUserProfile) extends Tweeter {
    def tweet(msg: String) = {
      val twt = new Tweet(user, msg, new Date)
      if (service.sendTweet(twt)) {
        localCache.saveTweet(twt)
        ui.showTweet(twt)
      }
    }
  }
}</code></pre>

<p>La prima classe, chiamata <code>TwitterUserProfile</code>, incapsula il profilo di un utente, che limitiamo al solo nome. La seconda classe, chiamata <code>Tweet</code>, è una classe <code>case</code> che incapsula un singolo &#8220;cinguettio&#8221; (un messaggio di Twitter, limitato a 140 caratteri dal servizio di Twitter). Oltre alla stringa che contiene il messaggio, incapsula l'utente che lo ha inviato e la data e l'ora a cui è stato inviato. Abbiamo scelto di definire questa classe come una classe <code>case</code> per il comodo supporto che le classi <code>case</code> offrono per creare oggetti ed eseguire su di loro il pattern matching. La classe che rappresenta il profilo non è stata resa una classe <code>case</code> perché è più probabile che venga usata come genitore di classi di profilo più dettagliate.

<p>Subito dopo troviamo il tratto <code>Tweeter</code>, che dichiara un singolo metodo chiamato <code>tweet</code>. Questo tratto è definito unicamente per eliminare una potenziale dipendenza circolare tra i due componenti <code>TwitterClientComponent</code> e <code>TwitterClientUIComponent</code>. Tutti i componenti sono definiti nella parte rimanente del file.

<p>I &#8220;componenti&#8221; sono quattro. Notate che sono implementati come tratti.

<ul>
<li><code>TwitterClientUIComponent</code>, per l'interfaccia utente.
<li><code>TwitterLocalCacheComponent</code>, per la memoria locale dei messaggi precedenti.
<li><code>TwitterServiceComponent</code>, per accedere al servizio di Twitter.
<li><code>TwitterClientComponent</code>, il cliente che mette insieme tutti i pezzi.
</ul>

<p>Tutti i componenti hanno una struttura simile. Ognuno dichiara un tratto o una classe annidata che incapsula il comportamento del componente., e dichiara un valore <code>val</code> a cui è assegnata un'istanza del tipo annidato.

<p>In Java, spesso i package vengono informalmente associati con i componenti. Questo è comune anche in altri linguaggi, che usano il loro equivalente per i package, come per esempio i moduli o gli spazi di nomi. Qui definiamo una nozione più precisa di componente e i tratti sono il miglior mezzo per veicolarla, perché i tratti sono progettati per essere composti tra loro.

<p><code>TwitterClientUIComponent</code> dichiara un campo <code>val</code> chiamato <code>ui</code> che contiene un'istanza del tipo annidato <code>TwitterClientUI</code>. Questa classe dispone di un campo <code>client</code> che deve essere inizializzato con un'istanza di <code>Tweeter</code>. In effetti, questa sarà un'istanza di <code>TwitterClient</code> (definita in <code>TwitterClientComponent</code>), che estende <code>Tweeter</code>.

<p><code>TwitterClientUI</code> definisce due metodi: il primo è <code>sendTweet</code>, progettato per essere usato dall'interfaccia per invocare l'oggetto <code>client</code> quando l'utente invia un nuovo messaggio; il secondo metodo è <code>showTweet</code>, speculare al primo metodo e invocato ogni volta che un nuovo messaggio (inviato da un altro utente, per esempio) deve essere mostrato. Questo secondo metodo è astratto, poiché la &#8220;decisione&#8221; sul tipo di interfaccia di usare rimane irrisolta.

<p>Similmente, <code>TwitterLocalCacheComponent</code> contiene la dichiarazione di <code>TwitterLocalCache</code> e una sua istanza. Le istanze con questo tratto salvano i messaggi nella memoria persistente locale quando <code>saveTweet</code> viene invocato. Potete recuperare i messaggi salvati invocando <code>history</code>.

<p><code>TwitterServiceComponent</code> è molto simile. Il suo tipo annidato dispone del metodo <code>sendTweet</code> per inviare un messaggio a Twitter e di un metodo <code>history</code> per recuperare tutti i messaggi dell'utente corrente.

<p>Infine, <code>TwitterClientComponent</code> contiene una classe concreta, chiamata <code>TwitterClient</code>, che integra i componenti. Il suo metodo <code>tweet</code> invia nuovi messaggi al servizio di Twitter, e se ha successo invia il messaggio anche all'interfaccia e alla memoria persistente locale.

<p><code>TwitterClientComponent</code> contiene anche la seguente <em>annotazione self-type</em>.

<pre><code>self: TwitterClientUIComponent with
      TwitterLocalCacheComponent with
      TwitterServiceComponent =&gt;</code></pre>

<p>L'effetto di questa dichiarazione è quello di indicare che ogni <code>TwitterClientComponent</code> concreto deve comportarsi anche come quegli altri tre componenti, componendo quindi tutti i componenti in una singola istanza dell'applicazione client. Questa composizione verrà realizzata mescolando questi componenti, che sono tratti, quando creiamo i client concreti, come vedremo fra breve.

<p>L'annotazione self-type significa anche che possiamo fare riferimento ai campi <code>val</code> dichiarati in quei componenti. Notate come <code>TwitterClient.tweet</code> fa riferimento a <code>service</code>, <code>localCache</code> e <code>ui</code> come se fossero variabili visibili nell'ambito di questo metodo. In effetti, <em>sono</em> visibili, grazie all'annotazione self-type.

<p>Notate anche che tutti i metodi che invocano altri componenti sono concreti. Quelle relazioni tra i componenti sono completamente specificate. Le astrazioni sono dirette &#8220;all'esterno&#8221;, verso l'interfaccia utente, il meccanismo di persistenza, <span class=baa>&amp;</span>c.

<p>Ora definitiamo un client Twitter concreto che usa una interfaccia testuale a riga di comando, una cache locale in memoria, e finge di interagire con il servizio Twitter.

<pre><code>// <a href=esempi/cap-13/twitter-text-client.scala>esempi/cap-13/twitter-text-client.scala</a>

package twitterclient

class TextClient(userProfile: TwitterUserProfile)
    extends TwitterClientComponent
    with TwitterClientUIComponent
    with TwitterLocalCacheComponent
    with TwitterServiceComponent {

  // Da TwitterClientComponent:

  val client = new TwitterClient(userProfile)

  // Da TwitterClientUIComponent:

  val ui = new TwitterClientUI(client) {
    def showTweet(tweet: Tweet) = println(tweet)
  }

  // Da TwitterLocalCacheComponent:

  val localCache = new TwitterLocalCache {
    private var tweets: List[Tweet] = Nil

    def saveTweet(tweet: Tweet) = tweets ::= tweet

    def history = tweets
  }

  // Da TwitterServiceComponent

  val service = new TwitterService() {
    def sendTweet(tweet: Tweet) = {
      println("Invio il messaggio al quartier generale di Twitter")
      true
    }
    def history = List[Tweet]()
  }
}</code></pre>

<p>La nostra classe concreta <code>TextClient</code> estende <code>TwitterClientComponent</code> e mescola gli altri tre componenti, soddisfando in questo modo le annotazioni self-type di <code>TwitterClientComponent</code>. In altre parole, <code>TextClient</code> <em>è</em> anche un <code>TwitterClientUIComponent</code>, un <code>TwitterLocalCacheComponent</code> e un <code>TwitterServiceComponent</code>, oltre a essere un <code>TwitterClientComponent</code>.

<p>Il costruttore di <code>TextClient</code> accetta come argomento un profilo utente, che verrà passato alla classe client annidata.

<p><code>TextClient</code> deve definire quattro campi <code>val</code>, uno per <code>TwitterClientComponent</code> e tre dagli altri mixin. Per quanto riguarda <code>client</code>, si limita a creare una nuova istanza di <code>TwitterClient</code>, passandole il profilo utente contenuto in <code>userProfile</code>.

<p>Per quanto riguarda <code>ui</code>, istanzia una classe anonima derivata da <code>TwitterClientUI</code> che definisce <code>showTweet</code> per stampare il messaggio.

<p>Per quanto riguarda <code>localCache</code>, istanzia una classe anonima derivata da <code>TwitterLocalCache</code> che mantiene la cronologia dei messaggi in una lista.

<p>Infine, per quanto riguarda <code>service</code>, istanzia una classe anonima derivata da <code>TwitterService</code>. Questo oggetto &#8220;finto&#8221; definisce <code>sendTweet</code> per stampare un messaggio e restituire una lista vuota come cronologia.

<p>Mettiamo alla prova il nostro client usando lo script seguente.

<pre><code>// <a href=esempi/cap-13/twitter-text-client-script.scala>esempi/cap-13/twitter-text-client-script.scala</a>

import twitterclient._

val client = new TextClient(new TwitterUserProfile("BuckTrends"))
client.ui.sendTweet("Il mio primo messaggio. Come funziona questa cosa?")
client.ui.sendTweet("Questa cosa funziona?")
client.ui.sendTweet("Vado in bagno...")
println("Cronologia dei messaggi:")
client.localCache.history.foreach {t =&gt; println(t)}</code></pre>

<p>Abbiamo creato un'istanza di <code>TextClient</code> per l'utente &#8220;BuckTrends&#8221;. Il vecchio Buck invia tre messaggi perspicaci tramite l'interfaccia. Concludiamo stampando la cronologia dei messaggi, in ordine inverso, che sono memorizzati localmente. L'esecuzione di questo script produce l'uscita seguente.

<pre><samp>Invio il messaggio al quartier generale di Twitter
(Sunday, May 3, 2009) @BuckTrends: Il mio primo messaggio. Come funziona questa cosa?
Invio il messaggio al quartier generale di Twitter
(Sunday, May 3, 2009) @BuckTrends: Questa cosa funziona?
Invio il messaggio al quartier generale di Twitter
(Sunday, May 3, 2009) @BuckTrends: Vado in bagno...
Cronologia dei messaggi:
(Sunday, May 3, 2009) @BuckTrends: Vado in bagno...
(Sunday, May 3, 2009) @BuckTrends: Questa cosa funziona?
(Sunday, May 3, 2009) @BuckTrends: Il mio primo messaggio. Come funziona questa cosa?</samp></pre>

<p>Le date varieranno, naturalmente. Ricordatevi che la riga <code>Invio il messaggio al quartier generale di Twitter</code> viene stampata dal servizio finto.

<p>Per riassumere, ogni componente principale nel client Twitter è stato dichiarato nel proprio tratto, con un tipo annidato per i campi e i metodi del componente. Il componente client ha dichiarato le proprie dipendenze verso gli altri componenti usando un'annotazione self-type. La classe client concreta ha mescolato questi componenti e definito il campo <code>val</code> di ogni componente come un sottotipo appropriato delle classi astratte e dei tratti corrispondenti che erano stati dichiarati nel componente.

<p>Abbiamo ottenuto un &#8220;collegamento&#8221; type-safe tra i componenti, un modello a componenti flessibile, e abbiamo realizzato il tutto in codice Scala! Esistono alternative al pattern Cake per implementare l'iniezione di dipendenza in Scala: si veda <a href=apa.html#Boner2008b>[Bon&#233;r2008b]</a> per altri esempi.

<h2 id=DesignByContractExample>Una progettazione migliore con la progettazione per contratto</h2>

<p>Concluderemo questo capitolo con una breve disamina di un approccio alla programmazione chiamato <em>progettazione per contratto</em> <a href=apa.html#DesignByContract>[DesignByContract]</a>, sviluppato da Bertrand Meyer per i linguaggio Eiffel <a href=apa.html#Eiffel>[Eiffel]</a>. (Si veda anche il capitolo 4 di <a href=apa.html#Hunt2000>[Hunt2000]</a>.). La progettazione per contratto è stata in giro per almeno vent'anni. &Egrave; abbastanza caduta fuori dal favore, ma è ancora molto utile per ragionare sulla progettazione.

<p>Quando considerate il &#8220;contratto&#8221; di un modulo, potete specificare tre tipi di condizioni. Primo, potete specificare gli ingressi richiesti affinché un modulo possa eseguire un servizio con successo (per esempio, quando un metodo viene invocato). Questi vincoli vengono chiamati <em>precondizioni</em>. Possono anche includere requisiti di sistema, come per esempio dati globali (che normalmente dovreste evitare, naturalmente).

<p>Potete anche specificare i risultati che il modulo garantisce di consegnare, cioè le <em>postcondizioni</em>, se le precondizioni sono state soddisfatte.

<p>Infine, potete specificare le <em>invarianti</em> che devono essere vere prima e dopo l'invocazione di un servizio.

<p>La particolare aggiunta che la progettazione per contratto porta è l'idea che questi vincoli contrattuali dovrebbero essere specificati come codice eseguibile, in modo da poter essere fatti rispettare automaticamente a tempo di esecuzione, ma di solito solo durante il collaudo.

<p>Il fallimento di un vincolo dovrebbe terminare immediatamente l'esecuzione, obbligandovi a correggere il problema. Altrimenti, è molto facile ignorare questi problemi.

<p>Scala non offre un supporto esplicito per la progettazione per contratto, ma esistono diversi metodi di <code>Predef</code> che pososno essere usati a questo scopo. L'esempio seguente mostra come usare <code>require</code> e <code>assume</code> per far rispettare un contratto.

<pre><code>// <a href=esempi/cap-13/bank-account.scala>esempi/cap-13/bank-account.scala</a>

class BankAccount(val balance: Double) {
  require(balance &gt;= 0.0)
  def debit(amount: Double) = {
    require(amount &gt; 0.0, "L'addebito deve essere maggiore di 0.0")
    assume(balance - amount &gt; 0.0, "I conti scoperti non sono ammessi")
    new BankAccount(balance - amount)
  }
  def credit(amount: Double) = {
    require(amount &gt; 0.0, "L'accredito deve essere maggiore di 0.0")
    new BankAccount(balance + amount)
  }
}</code></pre>

<p>La classe <code>BankAccount</code> usa <code>require</code> per garantire che un saldo non negativo venga specificato per il costruttore. Similmente, i metodi <code>debit</code> e <code>credit</code> usano <code>require</code> per garantire che l'argomento <code>amount</code> specificato sia positivo.

<p>La specifica seguente conferma che il &#8220;contratto&#8221; viene rispettato.

<pre><code>// <a href=esempi/cap-13/bank-account-spec.scala>esempi/cap-13/bank-account-spec.scala</a>

import org.specs._

object BankAccountSpec extends Specification {
  "La creazione di un conto con un saldo negativo" should {
    "fallire perché il saldo iniziale deve essere positivo." in {
      new BankAccount(-100.0) must throwAn[IllegalArgumentException]
    }
  }

  "Addebitare una somma su un conto" should {
    "fallire se l'addebito è minore di 0" in {
      val account = new BankAccount(100.0)
      (account.debit(-10.0)) must throwAn[IllegalArgumentException]
    }
  }

  "Addebitare una somma su un conto" should {
    "fallire se l'addebito è maggiore del saldo" in {
      val account = new BankAccount(100.0)
      (account.debit(110.0)) must throwAn[AssertionError]
    }
  }
}</code></pre>

<p>Se tentiamo di creare un'istanza di <code>BankAccount</code> con un saldo negativo, verrà lanciata una eccezione di tipo <code>IllegalArgumentException</code>. Similmente, lo stesso tipo di eccezione viene lanciato se l'addebito è inferiore a zero. Entrambe le condizioni sono imposte usando <code>require</code>, che lancia una <code>IllegalArgumentException</code> quando la condizione specificata è falsa.

<p>Il metodo <code>assume</code>, che viene usato per garantire che non siano ammessi conti scoperti, funziona in maniera quasi identica a <code>require</code>, ma lancia un <code>AssertionError</code> anziché una <code>IllegalArgumentException</code>.

<p>Sia <code>require</code> sia <code>assume</code> vengono in due forme: una che accetta solo una condizione booleana e una che accetta anche una stringa che contiene un messaggio di errore.

<p>Esiste anche una coppia di metodi <code>assert</code> che si comporta in maniera identica ad <code>assume</code>, tranne per un leggero cambiamento nel messaggio di fallimento generato. La scelta tra <code>assert</code> o <code>assume</code> dipende da quali di questi due &#8220;nomi&#8221; è più adatto dal punto di vista concettuale a un certo contesto.

<p>L'oggetto <code>Predef</code> definisce anche una classe <code>Ensuring</code>, che può essere usata per generalizzare le funzionalità di questi metodi. <code>Ensuring</code> dispone di un solo metodo sovraccaricato, <code>ensure</code>, alcune versioni del quale accettano un letterale funzione come &#8220;predicato&#8221;.

<p>Uno svantaggio di usare questi metodi ed <code>Ensuring</code> è che non potete disabilitare questi controlli nel codice di produzione. Potrebbe <em>non</em> essere accettabile terminare bruscamente l'esecuzione se una condizione fallisce, sebbene il sistema potrebbe crollare più tardi se gli viene permesso di procedere &#8220;zoppicando&#8221; e il problema sarebbe più difficile da scoprire e correggere. Il costo aggiuntivo imposto alle prestazioni potrebbe essere un'altra ragione per disabilitare i controlli sul contratto durante l'esecuzione.

<p>Di questi tepmi, gli scopi della progettazione per contratto sono ampiamente soddisfatti dallo sviluppo guidato dal collaudo (noto come <em>Test-Driven Development</em>, o <abbr>TDD</abbr>). Tuttavia, ragionare nei termini della progettazione per contratto completa i benefici offerti dal <abbr>TDD</abbr>. Se decidete di usare la progettazione per contratto per il vostro codice, considerate la creazione di un modulo personalizzato che vi permetta di disabilitare i controlli nel codicd di produzione.

<h2 id=_recap_and_what_s_next_4>Riepilogo, e poi?</h2>

<p>Abbiamo imparato un certo numero di tecniche pratiche, pattern e idiomi per sviluppare applicazioni in maniera efficace con Scala.

<p>Per costruire applicazioni in qualsiasi linguaggio è importante usare strumenti e librerie valide. Il prossimo capitolo offre maggiori dettagli sugli strumenti di Scala a riga di comando, descrive lo stato del supporto per Scala in diversi <abbr>IDE</abbr> e vi presenta alcune librerie Scala importanti.

<p class=v><a rel=prev href=cap-12.html title='indietro a &#8220;...&#8221;'><span class=u>&#x261C;</span></a> <a rel=next href=cap-14.html title='avanti a &#8220;Strumenti, librerie e IDE per Scala&#8221;'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2008&ndash;9 O&#8217;Reilly Media<br>
&copy; 2009&ndash;10 Giulio Piancastelli per la traduzione italiana
