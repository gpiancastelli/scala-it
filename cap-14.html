<!DOCTYPE html>
<meta charset=utf-8>
<title>Strumenti, librerie e IDE per Scala - Programmare in Scala</title>
<link rel=stylesheet href=styles.css>
<style>
body{counter-reset:h1 14}
</style>

<div id=book>
<p>Voi siete qui: <a href=index.html>Inizio</a> <span class=u>&#8227;</span> <a href=indice.html#cap-10>Programmare in Scala</a> <span class=u>&#8227;</span>

<h1>Strumenti, librerie e <abbr>IDE</abbr> per Scala</h1>

<p>Nell'ultimo capitolo, abbiamo visto come progettare applicazioni scalabili in Scala. In questo capitolo, discutiamo gli strumenti e le librerie che sono essenziali per gli sviluppatori di applicazioni in Scala.

<p>Vi abbiamo brevemente introdotto agli strumenti di Scala sulla riga di comando nel <a href=cap-1.html>capitolo 1</a>. Ora esploriamo questi strumenti maggiormente in dettaglio e impariamo altri strumenti che sono essenziali per lo sviluppatore Scala. Discuteremo plug-in consapevoli del linguaggio per editor e <abbr>IDE</abbr>, strumenti di collaudo e varie librerie e framework. Non copriremo questi argomenti esaustivamente, ma vi diremo dove guardare per maggiori informazioni.

<h2 id=CommandLineTools>Strumenti a riga di comando</h2>

<p>Anche se svolgete la maggior parte del vostro lavoro in un <abbr>IDE</abbr>, capire come funzionano gli strumenti a riga di comando vi dà flessibilità aggiuntiva, così come un <span class=wtf>fallback</span> se gli strumenti grafici dovessero fallire per voi. In questo capitolo, vi daremo alcuni consigli pratici per interagire con questi strumenti. Tuttavia, non descriveremo tutte le singole opzioni a riga di comando. Per questi dettagli sanguinolenti, vi raccomandiamo di scaricare e consultare il pacchetto di documentazione per gli strumenti chiamato <code>scala-devel-docs</code>, come descritto nella sezione <a href=cap-1.html#ForMoreInformation>Per maggiori informazioni</a> del capitolo 1, e anche nella sezione <a href=#CommandLineToolSbaz>Lo strumento <kbd>sbaz</kbd> a riga di comando</a> più avanti in questo capitolo.

<p>Tutti gli strumenti a riga di comando vengono installati nella directory <code class=var>scala-home</code><span class=file>/bin</span> (si veda la sezione <a href=cap-1.html#InstallingScala>Installare Scala</a> nel capitolo 1).

<h3 id=CommandLineToolScalac>Lo strumento <kbd>scalac</kbd> a riga di comando</h3>

<p>Il comando <kbd>scalac</kbd> compila i file sorgente Scala e genera file di classe per la <abbr>JVM</abbr>. In contrasto con i requisiti di Java, il nome del file sorgente non deve corrispondere al nome della classe pubblica contenuta nel file. In effetti, in un file potete definire tutte le classi pubbliche che volete, e potete anche usare dichiarazioni di package arbitrarie senza collocare i file nelle directory corrispondenti.

<p>Tuttavia, in modo da conformarsi ai requisiti della <abbr>JVM</abbr>, un file di classe separato verrà generato per ogni tipo con un nome che corrisponde al nome del tipo (a volte codificato, per esempio per le definizioni di tipo annidate). In più, i file di classe verranno scritti nelle directory che corrispondono alle dichiarazioni di package. Vedremo un esempio dei tipi di file di classe generati nella prossima sezione, quando discuteremo il comando <kbd>scala</kbd>.

<p>Il comando <kbd>scalac</kbd> è solo uno script di shell che racchiude un'invocazione del comando <kbd>java</kbd> a cui viene passato il nome dell'oggetto <code>Main</code> del compilatore Scala. Lo script aggiunge i file <abbr>JAR</abbr> di Scala al <code>CLASSPATH</code> e definisce diverse proprietà di sistema relative a Scala. Il comando si invoca in questo modo.

<p><kbd>scalac</kbd> <code class=var>[opzioni &hellip;] [file-sorgente]</code>

<p>Per esempio, abbiamo usato la seguente invocazione del comando <kbd>scalac</kbd> nella sezione <a href=cap-1.html#ATasteOfScala>Un assaggio di Scala</a> del Capitolo 1, dove abbiamo creato un semplice strumento a riga di comando per convertire le stringhe in ingresso in maiuscolo.

<pre><samp>scalac upper3.scala</samp></pre>

<p>La <a href=#scalac-command-options>tabella 14.1</a> mostra la lista delle <code class=var>opzioni</code> per il comando <kbd>scalac</kbd>, come riportate da <kbd>scalac -help</kbd>.

<div class=table id=scalac-command-options>
<p class=tt>Tabella 14.1. Le opzioni del comando <kbd>scalac</kbd>
<table summary="Le opzioni del comando scalac." border=0>
<colgroup>
<col align="left">
<col align="left">
</colgroup>
<thead valign="top"><tr>
<th align="left" valign="top">Opzione</th>
<th align="left" valign="top">Descrizione</th>
</tr></thead>
<tbody valign="top">
<tr>
<td align="left" valign="top"><p><code>-X</code>
<td align="left" valign="top"><p>Stampa una sinossi delle opzioni avanzate.
</tr>
<tr>
<td align="left" valign="top"><p><code>-bootclasspath</code> <code class=var>percorso</code>
<td align="left" valign="top"><p>Sostituisce l'ubicazione dei file di classe di avvio.
</tr>
<tr>
<td align="left" valign="top"><p><code>-classpath</code> <code class=var>percorso</code>
<td align="left" valign="top"><p>Specifica dove trovare i file di classe dell'utente.
</tr>
<tr>
<td align="left" valign="top"><p><code>-d</code> <code class=var>directory</code>
<td align="left" valign="top"><p>Specifica dove collocare i file di classe generati.
</tr>
<tr>
<td align="left" valign="top"><p><code>-dependencyfile</code> <code class=var>file</code>
<td align="left" valign="top"><p>Specifica il file in cui si tiene traccia delle dipendenze (versione 2.8).
</tr>
<tr>
<td align="left" valign="top"><p><code>-deprecation</code>
<td align="left" valign="top"><p>Mostra in uscita i punti del codice sorgente in cui vengono usate <abbr>API</abbr> deprecate.
</tr>
<tr>
<td align="left" valign="top"><p><code>-encoding</code> <code class=var>codifica</code>
<td align="left" valign="top"><p>Specifica la codifica di carattere usata dai file sorgente.
</tr>
<tr>
<td align="left" valign="top"><p><code>-explaintypes</code>
<td align="left" valign="top"><p>Spiega gli errori di tipo più dettagliatamente.
</tr>
<tr>
<td align="left" valign="top"><p><code>-extdirs</code> <code class=var>directory</code>
<td align="left" valign="top"><p>Sostituisce l'ubicazione delle estensioni del compilatore installate.
</tr>
<tr>
<td align="left" valign="top"><p><code>-g:</code><code class=var>livello</code>
<td align="left" valign="top"><p>Specifica il <code class=var>livello</code> delle informazioni di debug generate: <code>none</code>, <code>source</code>, <code>line</code>, <code>vars</code>, <code>notailcalls</code>.
</tr>
<tr>
<td align="left" valign="top"><p><code>-help</code>
<td align="left" valign="top"><p>Stampa una sinossi delle opzioni standard.
</tr>
<tr>
<td align="left" valign="top"><p><code>-make:</code><code class=var>strategia</code>
<td align="left" valign="top"><p>Specifica la strategia di <span class=wtf>detection</span> di ricompilazione (versione 2.8): <code>all</code>, <code>changed</code>, <code>immediate</code>, <code>transitive</code>.
</tr>
<tr>
<td align="left" valign="top"><p><code>-nowarn</code>
<td align="left" valign="top"><p>Evita di generare avvertimenti.
</tr>
<tr>
<td align="left" valign="top"><p><code>-optimise</code>
<td align="left" valign="top"><p>Genera bytecode più veloce applicando ottimizzazioni al programma.
</tr>
<tr>
<td align="left" valign="top"><p><code>-print</code>
<td align="left" valign="top"><p>Stampa il programma rimuovendo tutte le caratteristiche specifiche di Scala.
</tr>
<tr>
<td align="left" valign="top"><p><code>-sourcepath</code> <code class=var>percorso</code>
<td align="left" valign="top"><p>Specifica dove trovare i file sorgente di ingresso.
</tr>
<tr>
<td align="left" valign="top"><p><code>-target:</code><code class=var>obiettivo</code>
<td align="left" valign="top"><p>Specifica per quale <abbr>JVM</abbr> obiettivo i file oggetto devono essere generati: <code>jvm-1.5</code>, <code>jvm-1.4</code>, <code>msil</code>.
</tr>
<tr>
<td align="left" valign="top"><p><code>-unchecked</code>
<td align="left" valign="top"><p>Abilita gli avvertimenti <span class=wtf>unchecked</span> dettagliati.
</tr>
<tr>
<td align="left" valign="top"><p><code>-uniqid</code>
<td align="left" valign="top"><p>Stampa gli identificatori con un nome unico per aiutare il debug.
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">-verbose</code>
<td align="left" valign="top"><p>Mostra messaggi che descrivono le operazioni compiute dal compilatore.
</tr>
<tr>
<td align="left" valign="top"><p><code>-version</code>
<td align="left" valign="top"><p>Stampa la versione del prodotto ed esce.
</tr>
<tr>
<td align="left" valign="top"><p><code>@</code> <code class=var>file</code>
<td align="left" valign="top"><p>Un file di testo contenente gli argomenti per il compilatore (opzioni e file sorgente).
</tr>
</tbody>
</table>
</div>

<blockquote class=note>
<p><span class=u>&#x261E;</span>Raccomandiamo l'uso di <span class=wtf>routine</span> delle opzioni <code>-deprecation</code> e <code>-unchecked</code>: aiutano a prevenire alcuni bug e vi incoraggiano a eliminare l'uso di librerie obsolete.
</blockquote>

<p>Le opzioni avanzate attivate da <code>-X</code> controllano l'uscita verbosa, calibrano il comportamento del compilatore, compreso l'uso di plug-in ed estensioni sperimentali, <i class=baa>&amp;</i>c. Discuteremo l'opzione <code>-Xscript</code> quando discuteremo il comando <kbd>scala</kbd> nella prossima sezione.

<p>Alcune altre opzioni, <code>-Xfuture</code> e <code>-Xcheckinit</code>, sono utili per il problema della ridefinizione dei valori <code>val</code> descritto nella sezione <a href=cap-6.html#OverridingFieldsInTraits>Ridefinire i campi astratti e concreti nei tratti</a> che <span class=wtf>affects</span> le versioni 2.7.X di Scala. Similmente, l'opzione <code>-Xexperimental</code> abilita modifiche sperimentali e genera avvertimenti per le modifiche di comportamento potenzialmente rischiose. Si veda la sezione <a href=cap-6.html#OverridingFieldsInTraits>Ridefinire i campi astratti e concreti nei tratti</a> per i dettagli.

<p>Una caratteristica importante di <kbd>scalac</kbd> è la sua architettura a plug-in, che è stata significativamente migliorata nella versione 2.8. I plug-in del compilatore possono essere inseriti in ogni fase della compilazione, abilitando trasformazioni di codice, analisi, <i class=baa>&amp;</i>c. Per esempio, Scala 2.8 includerà un plug-in per le continuazioni che gli sviluppatori potranno usare per generare bytecode che usa uno stile basato sul passaggio di continuazioni (<abbr>CPS</abbr>) invece di uno stile basato su stack. Altri plug-in che sono <span class=wtf>under development</span> includono un analizzatore di &#8220;effetti&#8221;, utile per determinare se le funzioni sono davvero prive di effetti collaterali, se le variabili vengono modificate, <i class=baa>&amp;</i>c. Infine, una versione preliminare dello strumento di documentazione <kbd>sxr</kbd> <a href=apa.html#SXR>[SXR]</a> usa un plug-in del compilatore per generare documentazione del codice Scala sotto forma di ipertesto.

<p>Potete leggere maggiori informazioni su <kbd>scalac</kbd> nella documentazione degli strumenti per gli sviluppatori che potete installare con il comando <kbd>sbaz</kbd>, discusso più avanti nella sezione <a href=#CommandLineToolSbaz>Lo strumento <kbd>sbaz</kbd> a riga di comando</a>. In particolare, la <a href=#sbaz-commands>tabella 14.4</a> mostra un'invocazione di esempio del comando <kbd>sbaz</kbd> che installa la documentazione <code>scala-devel-docs</code>.

<blockquote class=warning>
<p><span class=u>&#x2762;</span>Il bytecode generato da Scala 2.8 non sarà pienamente compatibile con il bytecode generato dalla versione 2.7.5. La compatibilità s livello di codice sorgente verrà preservata nella maggior parte dei casi. Se avete realizzato le vostre implementazioni delle collezioni, potrebbero richiedere alcune modifiche.
</blockquote>

<h3 id=CommandLineToolScala>Lo strumento <kbd>scala</kbd> a riga di comando</h3>

<p>Anche il comando <kbd>scala</kbd> è uno script di shell che racchiude un'invocazione al comando <kbd>java</kbd>. Lo script aggiunge i file <abbr>JAR</abbr> di Scala al <code>CLASSPATH</code> e definisce diverse proprietà di sistema relative a Scala. Il comando si invoca in questo modo.

<p><kbd>scala</kbd> <code class=var>[opzioni &hellip;] [script-od-oggetto] [argomenti]</code>

<p>Per esempio, dopo aver compilato il nostro file <span class=file>upper3.scala</span> nella sezione <a href=cap-1.html#ATasteOfScala>Un assaggio di Scala</a> del capitolo 1, che abbiamo rivisitato nella discussione precedente di <kbd>scalac</kbd>, possiamo eseguire l'&#8220;applicazione&#8221; come segue.

<pre><samp>scala -cp . Upper Ciao Mondo!</samp></pre>

<p>L'opzione <code>-cp .</code> aggiuge la directory di lavoro corrente al percorso di ricerca delle classi. <code>Upper</code> è il nome della classe con un metodo <code>main</code> da eseguire. <code>Ciao Mondo!</code> sono gli argomenti passati a <code>Upper</code>. Questo comando produce l'uscita seguente.

<pre><samp> CIAO MONDO!</samp></pre>

<p>Il comando decide cosa fare sulla base dello <code class=var>script-od-oggetto</code> specificato. Se non specificate uno script o un oggetto, <kbd>scala</kbd> viene eseguito come un interprete interattivo in cui digitate codice che viene valutato sul momento, un <span class=wtf>setup</span> talvolta chiamato <abbr>REPL</abbr> (Read-Evaluate-Print Loop, letteralmente ciclo di lettura-valutazione-stampa). Ci sono alcuni comandi speciali disponibili nella modalità interattiva. Digitate <kbd>:help</kbd> per vederne l'elenco.

<blockquote class=note>
<p><span class=u>&#x261E;</span>La versione 2.8 aggiunge molti miglioramenti al <abbr>REPL</abbr>, incluso il completamento di codice.
</blockquote>

<p>Il nostro esempio di <code>Upper</code> illustra il caso in cui specificate il nome completamente qualificato di un <code>object</code> (o il nome di una classe Java). In questo caso, <kbd>scalac</kbd> si comporta proprio come il comando <kbd>java</kbd>: cerca il codice corrispondente nel <code>CLASSPATH</code> e si aspetta di trovare un metodo <code>main</code> nel tipo. Ricordatevi che per i tipi Scala dovete definire i metodi <code>main</code> negli <code>object</code>. Gli <code class=var>argomenti</code> vengono passati come argomenti al metodo <code>main</code>.

<p>Se specificate un file sorgente Scala per <code class=var>script-od-oggetto</code>, <kbd>scala</kbd> interpreta il file come uno script (cioè lo compila e lo esegue). Molti esempi nel libro vengono invocati in questo modo. Gli <code class=var>argomenti</code> vengono resi disponibili allo script nell'array <var>args</var>. Ecco uno script di esempio che implementa la stessa funzione di trasformazione in maiuscolo.

<pre><code>// <a href=esempi/cap-14/upper-script.scala>esempi/cap-14/upper-script.scala</a>

args.map(_.toUpperCase()).foreach(printf("%s ",_))
println("")</code></pre>

<p>Se eseguiamo questo script con il comando <kbd>scala upper.scala Ciao Mondo</kbd>, otteniamo la stessa uscita di prima, <code>HELLO WORLD</code>.

<p>Infine, se invocate <kbd>scala</kbd> senza un file di script o il nome di un oggetto come argomento, <kbd>scala</kbd> viene eseguito in modalità interattiva. Ecco un esempio di una sessione interattiva.

<pre><samp>$ scala
Welcome to Scala version 2.8.0.final (Java &hellip;).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; "Programmare in Scala" foreach { c =&gt; println(c) }
P
r
o
g
&hellip;</samp></pre>

<p>Il comando <kbd>scalac</kbd> accetta tutte le <code class=var>opzioni</code> accettate da <kbd>scalac</kbd> (si veda la <a href=#scalac-command-options>tabella 14.1</a>) più le opzioni elencate nella <a href=#scala-command-options>tabella 14.2</a>.

<div class=table id=scala-command-options>
<p class=tt>Tabella 14.2. Le opzioni del comando <kbd>scala</kbd> (in aggiunta alle opzioni del comando <kbd>scalac</kbd>).
<table summary="Le opzioni del comando scala (in aggiunta alle opzioni del comando scalac)." border=0>
<colgroup>
<col align="left">
<col align="left">
</colgroup>
<thead valign="top"><tr>
<th align="left" valign="top">Opzione</th>
<th align="left" valign="top">Descrizione</th>
</tr></thead>
<tbody valign="top">
<tr>
<td align="left" valign="top"><p><code>-howtorun script</code>
<td align="left" valign="top"><p>Interpreta esplicitamente <code class=var>script-od-oggetto</code> come un file di script.
</tr>
<tr>
<td align="left" valign="top"><p><code>-howtorun object</code>
<td align="left" valign="top"><p>Interpreta esplicitamente <code class=var>script-od-oggetto</code> come un oggetto compilato.
</tr>
<tr>
<td align="left" valign="top"><p><code>-howtorun guess</code>
<td align="left" valign="top"><p>Indovina che cos'è <code class=var>script-od-oggetto</code> (predefinito).
</tr>
<tr>
<td align="left" valign="top"><p><code>-i</code> <code class=var>file</code>
<td align="left" valign="top"><p>Precarica <code class=var>file</code>. Ha significato solo per le shell interattive.
</tr>
<tr>
<td align="left" valign="top"><p><code>-e</code> <code class=var>argomento</code>
<td align="left" valign="top"><p>Riconosci <code class=var>argomento</code> come codice Scala.
</tr>
<tr>
<td align="left" valign="top"><p><code>-savecompiled</code>
<td align="left" valign="top"><p>Salva lo script compilato per uso futuro.
</tr>
<tr>
<td align="left" valign="top"><p><code>-nocompdaemon</code>
<td align="left" valign="top"><p>Non usare <code>fsc</code>, il compilatore offline. (Si veda la sezione <a href=#CommandLineToolFsc>Lo strumento <kbd>fsc</kbd> a riga di comando</a>.)
</tr>
<tr>
<td align="left" valign="top"><p><code>-D</code><code class=var>proprietà</code><code>=</code><code class=var>valore</code>
<td align="left" valign="top"><p>Imposta una <code class=var>proprietà</code> di sistema Java a <code class=var>valore</code>.
</tr>
</tbody>
</table>
</div>

<p>Usate l'opzione <code>-i</code> <code class=var>file</code> nella modalità interattiva quando volete precaricare un file prima di digitare comandi. Una volta nella shell, potete anche caricare un file usando il comando <kbd>:load</kbd> <code class=var>nomefile</code>. La <a href=#scala-interactive-special-commands>tabella 14.3</a> elenca gli speciali comandi <code>:X</code> disponibili nell'ambito della modalità interattiva di <kbd>scala</kbd>.

<div class=table id=scala-interactive-special-commands>
<p class=tt>Tabella 14.3. Comandi disponibili nell'ambito della modalità interattiva di <kbd>scala</kbd>.
<table summary="Comandi disponibili nell'ambito della modalità interattiva di scala." border=0>
<colgroup>
<col align="left">
<col align="left">
</colgroup>
<thead valign="top"><tr>
<th align="left" valign="top">Opzione </th>
<th align="left" valign="top">Descrizione</th>
</tr></thead>
<tbody valign="top">
<tr>
<td align="left" valign="top"><p><code>:help</code>
<td align="left" valign="top"><p>Stampa un messaggio di aiuto a proposito di questi comandi.
</tr>
<tr>
<td align="left" valign="top"><p><code>:load</code>
<td align="left" valign="top"><p>Seguito dal nome di un file, carica un file Scala.
</tr>
<tr>
<td align="left" valign="top"><p><code>:replay</code>
<td align="left" valign="top"><p>Resetta l'esecuzione e riesegue tutti i comandi precedenti.
</tr>
<tr>
<td align="left" valign="top"><p><code>:quit</code>
<td align="left" valign="top"><p>Esce dall'interprete.
</tr>
<tr>
<td align="left" valign="top"><p><code>:power</code>
<td align="left" valign="top"><p>Abilità la modalità utente potenziata di Scala 2.8.
</tr>
</tbody>
</table>
</div>

<p>La nuova &#8220;modalità utente potenziata&#8221; aggiunge comandi aggiuntivi per vedere i dati in memoria, come l'albero sintattico astratto e le proprietà dell'interprete, e per eseguire ulteriori operazioni.

<p>Per l'esecuzione in <em>modalità batch</em> usate l'opzione <code>-e</code> <code class=var>argomento</code> per specificare il codice Scala da interpretare. Se state usando una shell che supporta la redirezione I/O (per esempio la shell Bourne, la shell C, o i loro discendenti) e avete bisogno di costruire dinamicamente righe di codice, potete anche <span class=wtf>pipe</span> codice nell'interprete <kbd>scala</kbd>, come mostrato nel seguente esempio di uno script <em>bash</em> abbastanza artificioso.

<pre><code>#!/usr/bin/env bash
# <a href=esempi/cap-14/pipe-example.sh>esempi/cap-14/pipe-example.sh</a>

h=Hello
w=World
function commands {
cat &lt;&lt;-EOF
println("$h")
println("$w")
EOF
}

commands | scala</code></pre>

<p>Invocare gli script con <kbd>scala</kbd> è fastidioso quando li usate frequentemente. Su Windows e sui sistemi <abbr>UNIX</abbr> potete creare script Scala che non richiedono l'uso dell'invocazione <kbd>scala</kbd> <code class=var>nome-file-script</code>.

<p>Per i sistemi <abbr>UNIX</abbr>, l'esempio seguente mostra come realizzare uno script eseguibile. Ricordatevi che dovete rendere il file eseguibile, per esempio attraverso il comando <kbd>chmod +x secho</kbd>.

<pre><code>#!/bin/sh
exec scala "$0" "$@"
!#
print("Hai digitato: ")
argv.toList foreach { s =&gt; format("%s ", s) }
println</code></pre>

<p>Ecco come potreste usarlo.

<pre><samp>$ secho Hello World
Hai digitato: Hello World</samp></pre>

<p>Similmente, ecco un esempio di comando <code>.bat</code> in Windows.

<pre><code>::#!
@echo off
call scala %0 %*
goto :eof
::!#
print("Hai digitato: ")
argv.toList foreach { s =&gt; format("%s ", s) }
println</code></pre>

<p>Si veda la pagina di manuale relativa a <kbd>scala</kbd> nel pacchetto di documentazione per lo sviluppatore <code>scala-devel-docs</code> per trovare maggiori informazioni su tutte le opzioni a riga di comando per <kbd>scala</kbd>.

<h4 id=LimitationsOfScalaVsScalac>Limitazioni di <kbd>scala</kbd> vs. <kbd>scalac</kbd></h4>

<p>Ci sono alcune limitazioni quando eseguite un file sorgente con <kbd>scala</kbd> rispetto alla compilazione con <kbd>scalac</kbd>.

<p>Qualsiasi script eseguito con <kbd>scala</kbd> viene racchiuso in un <code>object</code> anonimo che somiglia più o meno all'esempio seguente.

<pre><code>// <a href=esempi/cap-14/script-wrapper.scala>esempi/cap-14/script-wrapper.scala</a>

object Script {
  def main(args: Array[String]): Unit = {
    new AnyRef {
      // Il codice del vostro script viene inserito qui.
    }
  }
}</code></pre>

<p>Al momento della scrittura, gli <code>object</code> Scala non possono racchiudere dichiarazioni di package, e quindi non potete dichiarare package negli script. Questo è il motivo per cui gli esempi di questo libro che dichiarano package devono essere compilati ed eseguiti separatamente, come accade per questo esempio proveniente dal <a href=cap-2.html>capitolo 2</a>.

<pre><code>// <a href=esempi/cap-2/package-example1.scala>esempi/cap-2/package-example1.scala</a>

package com.example.mypkg

class MyClass {
  // ...
}</code></pre>

<p>Specularmente, ci sono script validi che non possono essere compilati con <kbd>scalac</kbd> a meno di non usare una speciale opzione <code>-X</code>. Per esempio, le definizioni di funzione e le invocazioni di funzione al di fuori dei tipi non sono permesse. L'esempio seguente viene eseguito senza problemi da <kbd>scala</kbd>.

<pre><code>// <a href=esempi/cap-14/example-script.scala>esempi/cap-14/example-script.scala</a>

case class Message(name: String)

def printMessage(msg: Message) = {
  println(msg)
}

printMessage(new Message(
    "Bisogna compilare questo script con scalac -Xscript &lt;nome&gt;!"))</code></pre>

<p>Come ci aspettiamo, l'esecuzione di questo script con <kbd>scala</kbd> produce l'uscita seguente.

<pre><samp>Message(Bisogna compilare questo script con scalac -Xscript &lt;nome&gt;!)</samp></pre>

<p>Tuttavia, se provate a compilare lo script con <kbd>scalac</kbd> (senza l'opzione <code>-Xscript</code>), ottenete il seguente errore.

<pre><samp>example-script.scala:3: error: expected class or object definition
def printMessage(msg: Message) = {
^
example-script.scala:7: error: expected class or object definition
printMessage(new Message("Bisogna compilare questo script con scalac -Xscript &lt;nome&gt;!"))
^
two errors found</samp></pre>

<p>&Egrave; lo stesso script a descrivere la soluzione: per compilarlo con <kbd>scalac</kbd>, dovete aggiungere l'opzione <code>-Xscript</code> <code class=var>nome</code>, dove <code class=var>nome</code> è il nome che volete dare al file di classe compilato. Per esempio, usare <code>MessagePrinter</code> per <code class=var>nome</code> risulterà nella creazione di diversi file di classe il cui nome contiene il prefisso <code>MessagePrinter</code>.

<pre><samp>scalac -Xscript MessagePrinter example-script.scala</samp></pre>

<p>Ora potete eseguire il codice compilato con il comando:

<pre><samp>scala -classpath . MessagePrinter</samp></pre>

<p>La directory corrente conterrà i seguenti file di classe.

<pre><samp>MessagePrinter$$anon$1$Message$.class
MessagePrinter$$anon$1$Message.class
MessagePrinter$$anon$1.class
MessagePrinter$.class
MessagePrinter.class</samp></pre>

<p>Cosa sono tutti questi file? <code>MessagePrinter</code> e <code>MessagePrinter$</code> vengono generati da <kbd>scalac</kbd> per racchiudere il punto di ingresso dello script come &#8220;applicazione&#8221;. Ricordatevi che abbiamo specificato <code>MessagePrinter</code> come <code class=var>nome</code> per l'argomento di <code>-Xscript</code>. Perciò, <code>MessagePrinter</code> contiene il metodo <code>static main</code> che ci serve.

<p><code>MessagePrinter$$anon$1</code> è una classe generata che racchiude l'intero script. Il metodo <code>printMessage</code> nello script è un metodo di questa classe. <code>MessagePrinter$$anon$1$Message</code> e <code>MessagePrinter$$anon$1$Message$</code> sono la classe <code>Message</code> e il suo oggetto associato, rispettivamente, che sono dichiarati nello script. Sono annidati dentro la classe <code>MessagePrinter$$anon$1</code> generata per l'intero script. Se volete vedere il contenuto di questi file di classe, usate uno dei decompilatori che descriveremo nella prossima sezione.

<h3 id=CommandLineToolDecompilers>Gli strumenti <kbd>scalap</kbd>, <kbd>javap</kbd> e <kbd>jad</kbd> a riga di comando</h3>

Quando state imparando Scala e volete capire come i costrutti Scala vengono mappati sulla macchina virtuale sottostante, ci sono diversi decompilatori che sono molto utili. Sono particolarmente utili quando avete bisogno di invocare codice Scala da Java e volete sapere come i nomi Scala vengono <em class=wtf>mangled</em> in nomi compatibili con la <abbr>JVM</abbr> o volete capire come il compilatore Scala traduce le caratteristiche del linguaggio in bytecode valido.

<p>Discutiamo tre decompilatori e i benefici che offrono. Dato che i file di classe generati da <kbd>scalac</kbd> cotengono bytecode valido per la <abbr>JVM</abbr>, potete usare gli strumenti di decompilazione offerti da Java.

<ul>
<li><kbd>scalap</kbd> è incluso nella distribuzione Scala. Mostra in uscita le dichiarazioni come apparirebbero nel codice sorgente Scala.
<li><kbd>javap</kbd> è incluso nel <abbr>JDK</abbr>. Mostra le dichiarazioni come apparirebbero nel codice sorgente Java. Di conseguenza, eseguire <kbd>javap</kbd> su file di classe generati da Scala è un buon modo per vedere come le definizioni Scala vengono mappate in bytecode valido.
<li><kbd>jad</kbd> è uno strumento open source a riga di comando <a href=apa.html#JAD>[JAD]</a> che cerca di ricostruire un intero file sorgente Java a partire dal file di classe, incluse le definizioni di metodo così come le dichiarazioni.
</ul>

<p><span class=file>MessagePrinter.class</span> è uno dei file di classe generati dallo script di esempio della sezione precedente. Eseguiamo <kbd>scalap -classpath . MessagePrinter</kbd>. Otteniamo la seguente uscita.

<pre><samp>package MessagePrinter;
final class MessagePrinter extends scala.AnyRef {
}
object MessagePrinter {
  def main(scala.Array[java.lang.String]): scala.Unit;
  def $tag(): scala.Int;
    throws java.rmi.RemoteException
}</samp></pre>

<p>Notate che il primo metodo all'interno di <code>object MessagePrinter</code> è il metodo <code>main</code>. Il metodo <code>$tag</code> è parte dell'implementazione interna di Scala. &Egrave; un metodo astratto definito da <code>ScalaObject</code>. Il compilatore ne genera automaticamente implementazioni per i tipi concreti. Il metodo <code>$tag</code> è stato originariamente introdotto per ottimizzare il pattern matching, ma ora è deprecato e potrebbe essere rimosso in una prossima versione di Scala.

<p>Confrontiamo l'uscita di <kbd>scalap</kbd> con quello che otteniamo quando eseguiamo <kbd>javap -classpath . MessagePrinter</kbd>.

<pre><samp>Compiled from "(virtual file)"
public final class MessagePrinter extends java.lang.Object{
  public static final void main(java.lang.String[]);
  public static final int $tag()       throws java.rmi.RemoteException;
}</samp></pre>

<p>Ora vediamo la dichiarazione di <code>main</code> così come la vedremmo in un tipico file sorgente Java.

<p>Infine, per usare <kbd>jad</kbd>, dategli semplicemente il nome del file di classe. Genera un file di uscita corrispondente con l'estensione <span class=file>.jad</span>. Se eseguite <kbd>jad MessagePrinter.class</kbd>, ottenete un lungo file chiamato <span class=file>MessagePrinter.jad</span>. Otterrete anche diversi avvertimenti che <kbd>jad</kbd> non ha potuto decompilare completamente alcuni metodi. Non riprodurremo l'uscita qui, ma il file <span class=file>.jad</span> conterrà normali istruzioni Java <span class=wtf>interspersed</span> con diverse sezioni di istruzioni in bytecode per la <abbr>JVM</abbr> nei punti in cui lo strumento non è riuscito a decompilare il bytecode.

<p>Tutti questi strumenti hanno un aiuto a riga di comando.

<ul>
<li><kbd>scalap -help</kbd>
<li><kbd>javap -help</kbd>
<li><kbd>jad --help</kbd>
</ul>

<p>La documentazione per lo sviluppatore Scala contiene la documentazione per <kbd>scalap</kbd>. Una documentazione simile per <kbd>javap</kbd> accompagna il <abbr>JDK</abbr>. La distribuzione di <kbd>jad</kbd> include un file <span class=file>README</span> con la documentazione. Le distribuzioni per Mac OS X e Linux includono anche una pagina <code>man</code>.

<p>Infine, come esercizio, compilate la seguente classe <code>Complex</code> molto semplice che rappresenta i numeri complessi. Poi eseguite <kbd>scalap</kbd>, <kbd>javap</kbd> e <kbd>jad</kbd> sui file di classe risultanti.

<pre><code>// <a href=esempi/cap-14/complex.scala>esempi/cap-14/complex.scala</a>

case class Complex(real: Double, imaginary: Double) {
  def +(that: Complex) =
    new Complex(real + that.real, imaginary + that.imaginary)
  def -(that: Complex) =
    new Complex(real - that.real, imaginary - that.imaginary)
}</code></pre>

<p>Come vengono codificati i metodi <code>+</code> e <code>-</code>? Quali sono i nomi dei metodi di lettura per i cmapi <var>real</var> e <var>imaginary</var>? Quali tipi Java vengono usati per i campi?

<h3 id=CommandLineToolScaladoc>Lo strumento <kbd>scaladoc</kbd> a riga di comando</h3>

<p>Il comando <kbd>scaladoc</kbd> è analogo a <kbd>javadoc</kbd>. Viene usato per generare documentazione a partire dai file sorgente Scala; questa documentazione viene chiamata <em>Scaladoc</em>. Il riconoscitore di <kbd>scaladoc</kbd> supporta le stesse annotazioni (indicate dal simbolo <code>@</code>) di <kbd>javadoc</kbd>, come <code>@author</code>, <code>@param</code>, <i class=baa>&amp;</i>c.

<p>Se usate <kbd>scaladoc</kbd> per la vostra documentazione, potreste voler investigare <kbd>vscaladoc</kbd>, uno strumento <kbd>scaladoc</kbd> migliorato che è disponibile all'indirizzo <a class=url href=http://code.google.com/p/vscaladoc/>http://code.google.com/p/vscaladoc/</a>. Potete anche trovare documentazione su <kbd>vscaladoc</kbd> a <a href=apa.html#ScalaTools>[ScalaTools]</a>.

<h3 id=CommandLineToolSbaz>Lo strumento <kbd>sbaz</kbd> a riga di comando</h3>

<p>Lo Scala Bazaar System (<kbd>sbaz</kbd>) è un systema di impacchettamento che aiuta a mantenere automaticamente un'installazione di Scala. &Egrave; analogo al sistema di impacchettamento <em>gem</em> per Ruby, a <em>CPAN</em> per Perl, <i class=baa>&amp;</i>c.

<p>Il sito di Scala ospita un piacevole riassunto di come usare <kbd>sbaz</kbd> all'indirizzo <a class=url href=http://www.scala-lang.org/node/93>http://www.scala-lang.org/node/93</a>. Tutte le opzioni a riga di comando sono descritte nella documentazione per lo sviluppatore. La tabella seguente riassume le opzioni più utili.

<div class=table id=sbaz-commands>
<p class=tt>Tabella 14.4. Le opzioni più utili per il comando <kbd>sbaz</kbd>.
<table summary="Le opzioni più utili per il comando sbaz." border=0>
<colgroup>
<col align="left">
<col align="left">
</colgroup>
<thead valign="top"><tr>
<th align="left" valign="top">Comando</th>
<th align="left" valign="top">Descrizione</th>
</tr></thead>
<tbody valign="top">
<tr>
<td align="left" valign="top"><p><kbd>sbaz showuniverse</kbd>
<td align="left" valign="top"><p>Mostra l'&#8220;universo&#8221; corrente (il repository remoto). L'ubicazione predefinita è <a class=url href=http://scala-webapps.epfl.ch/sbaz/scala-dev>http://scala-webapps.epfl.ch/sbaz/scala-dev</a>.
</tr>
<tr>
<td align="left" valign="top"><p><kbd>sbaz setuniverse</kbd> <code class=var>univ</code>
<td align="left" valign="top"><p>Punta a un nuovo &#8220;universo&#8221; <code class=var>univ</code>.
</tr>
<tr>
<td align="left" valign="top"><p><kbd>sbaz installed</kbd>
<td align="left" valign="top"><p>Quali pacchetti sono già installati localmente?
</tr>
<tr>
<td align="left" valign="top"><p><kbd>sbaz available</kbd>
<td align="left" valign="top"><p>Quali meraviglie attendono su Internet?
</tr>
<tr>
<td align="left" valign="top"><p><kbd>sbaz install scala-devel-docs</kbd>
<td align="left" valign="top"><p>Installa l'impagabile pacchetto <code>scala-devel-docs</code> (per esempio).
</tr>
<tr>
<td align="left" valign="top"><p><kbd>sbaz upgrade</kbd>
<td align="left" valign="top"><p>Aggiorna tutti i pacchetti installati all'ultima versione.
</tr>
</tbody>
</table>
</div>

<p>Notate che un repository remoto usato da <kbd>sbaz</kbd> viene chiamato &#8220;universo&#8221;.

<h3 id=CommandLineToolFsc>Lo strumento <kbd>fsc</kbd> a riga di comando</h3>

<p>Il compilatore Scala veloce (in inglese, <em>fast scala compiler</em>, dalle cui iniziali deriva il nome dello strumento) viene messo in esecuzione come un processo demone per abilitare invocazioni più veloci del compilatore, soprattutto eliminando il costo aggiuntivo di avvio. &Egrave; particolarmente utile quando si eseguono script ripetutamente (per esempio, quando rieseguite una serie di test fino a riprodurre un bug). In effetti, <kbd>fsc</kbd> viene invocato automaticamente dal comando <kbd>scala</kbd>. Potete anche invocarlo direttamente.

<h2 id=BuildTools>Strumenti di assemblaggio</h2>

<p>Sono stati implementati plug-in Scala per diversi strumenti di assemblaggio comunemente usati, compresi <em>ant</em> (<a class=url href=http://ant.apache.org/>http://ant.apache.org/</a>), <em>maven</em> (<a class=url href=http://maven.apache.org/>http://maven.apache.org/</a>) e <em>buildr</em> (<a class=url href=http://buildr.apache.org/>http://buildr.apache.org/</a>). Esistono anche diversi strumenti di assemblaggio scritti in Scala e destinati specificamente allo sviluppo con Scala. Forse l'esempio più noto di questi strumenti è <em>sbt</em> (&#8220;Simple Build Tool&#8221; <a href=apa.html#SBT>[SBT]</a>).

<p>Questi plug-in e strumenti sono documentati molto bene sui rispettivi siti web, quindi vi rimandiamo a quei siti per i dettagli.

<p>La distribuzione Scala include <em>task</em> utilizzabili da <em>ant</em> per <kbd>scalac</kbd>, <kbd>fsc</kbd> e <kbd>scaladoc</kbd>. Questi sono usati in modo molto simile ai loro corrispondenti Java. Sono descritti all'indirizzo <a class=url href=http://scala-lang.org/node/98>http://scala-lang.org/node/98</a>.

Il plug-in Scala per <em>maven</em> è disponibile all'indirizzo <a class=url href=http://scala-tools.org/mvnsites/maven-scala-plugin/>http://scala-tools.org/mvnsites/maven-scala-plugin/</a>. Non richiede che Scala sia installato, dato che lo scaricherà per voi. Diversi progetti Scala di terze parti, come Lift (si veda la sezione <a href=#Lift>Lift</a> più avanti in questo capitolo), usano <em>maven</em>.

<p><em>Buildr</em> è un progetto Apache disponibile all'indirizzo <a class=url href=http://buildr.apache.org/>http://buildr.apache.org/</a>. &Egrave; destinato ad applicazioni scritte per la <abbr>JVM</abbr> in qualsiasi linguaggio, con un supporto predefinito per Scala e Groovy, così come per Java. &Egrave; compatibile con i repository e i layout di progetto di <em>maven</em>. Dato che i programmi di assemblaggio sono scritti in Ruby, tendono a essere molto più succinti rispetto ai corrispondenti file <em>maven</em>. <em>Buildr</em> è anche utile per collaudare applicazioni <abbr>JVM</abbr> con gli strumenti di collaudo di Ruby, come <em>RSpec</em> (<a class=url href=http://rspec.info/>http://rspec.info</a>) e Cucumber (<a class=url href=http://cukes.info/>http://cukes.info</a>), se usate JRuby (<a class=url href=http://jruby.codehaus.org/>http://jruby.codehaus.org/</a>) per eseguire i vostri assemblaggi.

<p>Il semplice strumento di assemblaggio <em>sbt</em> orientato a Scala, disponibile all'indirizzo <a class=url href=http://code.google.com/p/simple-build-tool/>http://code.google.com/p/simple-build-tool/</a>, presenta alcune somiglianze con <em>buildr</em>. &Egrave; anche compatibile con <em>maven</em>, ma usa Scala come linguaggio per scrivere gli script di assemblaggio. Ha anche un supporto predefinito per generare la documentazione <em>Scaladoc</em> e per effettuare il collaudo con <em>ScalaTest</em>, <em>Specs</em> e <em>ScalaCheck</em>.

<h2 id=IntegrationWithIDEs>Integratione con gli <abbr>IDE</abbr></h2>

<p>Se provenite da una formazione in Java, siete probabilmente un po' <span class=wtf>spoiled</span> dalle ricche funzionalità degli attuali <abbr>IDE</abbr> per Java. Il supporto degli <abbr>IDE</abbr> per Scala non è ancora così buono, ma si sta evolvendo rapidamente in Eclipse, IntelliJ IDEA e NetBeans. Al momento della scrittura, tutti i plug-in Scala per questi tre <abbr>IDE</abbr> supportano la colorazione della sintassi, la gestione dei progetti, un numero limitato di refactoring automatici, <i class=baa>&amp;</i>c. Sebbene ognuno dei plug-in abbia particolari vantaggi rispetto agli altri, sono tutti abbastanza prossimi nelle funzionalità che probabilmente troverete accettabile adottare il plug-in per il vostro <abbr>IDE</abbr> preferito.

<p>Questa sezione descrive come usare il supporto per Scala disponibile in Eclipse, IntelliJ IDEA e NetBeans. Presumiamo che sappiate già come usare questi <abbr>IDE</abbr> per lo sviluppo in altri linguaggi, come Java.

<h3 id=_eclipse>Eclipse</h3>

<h4 id=_installing_the_scala_plugin>Installare il plug-in per Scala</h4>

<p>Per i dettagli sul plugin di Eclipse per Scala, partite dalla pagina web <a class=url href=http://www.scala-lang.org/node/94>http://www.scala-lang.org/node/94</a>. Se siete interessati a contribuire allo sviluppo del plug-in, guardate la pagina web <a class=url href=http://lampsvn.epfl.ch/trac/scala/wiki/EclipsePlugin>http://lampsvn.epfl.ch/trac/scala/wiki/EclipsePlugin</a>.

<p>Il plug-in richiede il <abbr>JDK</abbr> versione 5 o superiore (viene raccomandata la 6) ed Eclipse 3.3 o superiore (viene raccomandata la versione 3.4). Il plug-in installa da solo lo <abbr>SDK</abbr> per Scala. Per installare il plug-in, invocate il comando <em>Software Updates</em> nel menu <em>Help</em>.

<p>Cliccate la scheda <em>Available Software</em> e cliccate il bottone &#8220;Add Site&hellip;&#8221; sul lato destro. Vedrete la finestra di dialogo mostrata in <a href=#eclipse-add-site>figura 14.1</a>.

<div class=figure id=eclipse-add-site>
<p class=ft>Figura 14.1. La finestra di dialogo <em>Add site</em> di Eclipse.
<p><img src=i/eclipse-add-site.png alt="" width=432>
</div>

<p>Digitate l'<abbr>URL</abbr> mostrato in figura, <a class=url href=http://www.scala-lang.org/scala-eclipse-plugin>http://www.scala-lang.org/scala-eclipse-plugin</a>. Alcune persone preferiscono lavorare con i rilasci <em>notturni</em> che si trovano all'indirizzo <a class=url href=http://www.scala-lang.org/scala-eclipse-plugin-nightly>http://www.scala-lang.org/scala-eclipse-plugin-nightly</a>, ma dovreste essere consapevoli che non c'è alcuna garanzia che funzioneranno!

<p>Selezionate la <span class=wtf>check box</span> vicino al sito di aggiornamento appena aggiunto e cliccate il bottone <em>Install</em>, come indicato nella <a href=#eclipse-install-scala2>figura 14.2</a>. <b>Non</b> cliccate il bottone &#8220;predefinito&#8221; <em>Close</em>!

<div class=figure id=eclipse-install-scala2>
<p class=ft>La finestra di dialogo <em>Software Updates and Add-ons</em>.
<p><img src=i/eclipse-install-scala2.png alt="" width=432>
</div>

<blockquote class=warning>
<p><span class=u>&#x2762;</span>&Egrave; facile venire confusi dalla povera usabilità della finestra di dialogo <em>Software Updates</em>.
</blockquote>

<p>Dopo che il plug-in è stato trovato sul sito di aggiornamento, una finestra di dialogo <em>Install</em> viene presentata. Cliccate attraverso la sequenza di schermate per completare l'installazione. Vi verrà chiesto di riavviare Eclipse per completare l'installazione.

<h4 id=_developing_scala_applications>Sviluppare applicazioni in Scala</h4>

<p>Una volta che il plug-in è stato installato, potete creare progetti Scala usando la voce di menu <em>File &rarr; New &rarr; Other &hellip;</em>. Troverete una cartella <em>Scala Wizards</em> che contiene un <span class=wtf>wizard</span> chiamato <em>Scala Project</em>. Questo <span class=wtf>wizard</span> funziona proprio come il familiare <span class=wtf>wizard</span> <em>Java Project</em>.

<p>Potete lavorare con il vostro progetto Scala usando la maggior parte degli stessi comandi che usereste con un tipico progetto Java. Per esempio, potete creare un nuovo tratto, una nuova classe o un nuovo oggetto usando il menu contestuale.

<p>Il plug-in Eclipse per Scala ha ancora alcuni &#8220;<span class=wtf>rough edges</span>&#8221;, ma gli sviluppatori Scala che usano Eclipse dovrebbero trovarlo accettabile per le loro necessità quotidiane.

<h3 id=_intellij>IntelliJ</h3>

<h4 id=_installing_the_scala_plugins>Installare il plug-in per Scala</h4>

<p>Il gruppo di IntelliJ IDEA offre un plug-in Scala di qualità <em>beta</em>. Per i dettagli, cominciate dalla pagina web <a class=url href=http://www.jetbrains.net/confluence/display/SCA/Scala+Plugin+for+IntelliJ+IDEA>http://www.jetbrains.net/confluence/display/SCA/Scala+Plugin+for+IntelliJ+IDEA</a>.

<p>Per usareil plug-in, dovete usare IntelliJ versione 8.0.X o successiva. Consdierate la possibilità di usare il rilascio &#8220;EAP&#8221; più recente per godere degli ultimi aggiornamenti alle funzioni. Dovete anche avere lo <abbr>SDK</abbr> Scala a riga di comando già installato, come discusso nella sezione <a href=cap-1.html#InstallingScala>Installare Scala</a> del capitolo 1.

<p>Per installare il plug-in Scala, avviate IDEA. Aprite il pannello <em>Settings</em>, per esempio usando la voce di menu <em>File &rarr; Settings</em>. Sul lato sinistro, <span class=wtf>scroll down</span> e cliccate l'elemento <em>Plugins</em>, come mostrato nella <a href=#idea-settings-plugins>figura 14.3</a>.

<div class=figure id=idea-settings-plugins>
<p class=tt>Figura 14.3. La voce per le impostazioni dei plug-in in IntelliJ IDEA.
<p><img src=i/idea-settings-plugins1a.png alt="" width=432>
</div>

<p>Selezionate la scheda <em>Available</em> sul lato destro. <span class=wtf>Scroll down</span> fino al plug-in <em>Scala</em>, come mostrato nella <a href=#idea-settings-plugins-scala>figura 14.4</a>.

<div class=figure id=idea-settings-plugins-scala>
<p class=ft>Figura 14.4. Il plug-in Scala disponibile per IntelliJ IDEA.
<p><img src=i/idea-settings-plugins1b.png alt="" width=432>
</div>

<p>Cliccate con il tasto destro il nome del plug-in <em>Scala</em> e selezionate <em>Download and Install</em> dal menu. Ripetete l'operazione per il plug-in <em>Scala Application</em>. Dovrete riavviare IDEA per abilitare i plug-in.

<p>Dopo aver riavviato IDEA, verificate che i due plug-in siano stati installati correttamente riaprendo il <em>Plugin Manager</em>. Cliccate la scheda <em>Installed</em> e <span class=wtf>scroll down</span> per trovare i due plug-in per Scala. Dovrebbero essere elencati con un carattere nero e le <span class=wtf>check box</span> al loro fianco dovrebbero essere spuntate, come mostrato in <a href=#idea-settings-plugins-confirm>figura 14.5</a>.

<div class=figure id=idea-settings-plugins-confirm>
<p class=ft>Figura 14.5. I plug-in IntelliJ IDEA per Scala installati.
<p><img src=i/idea-settings-plugins-confirm.png alt="" width=432>
</div>

<p>Se il carattere è rosso o le <span class=wtf>check box</span> non sono spuntate, fate riferimento alla pagina web del plug-in Scala già citata per aiutarvi a capire cosa non ha funzionato.

<h4 id=_developing_scala_applications_2>Sviluppare applicazioni in Scala</h4>

<p>Per creare un progetto Scala in IDEA cominciate col selezionare la voce di menu <em>File &rarr; New Project</em>. Nella finestra di dialogo, selezionate l'appropriato pulsante radio per la vostra situazione, per esempio &#8220;Create New Project from Scratch&#8221;.

<p>Nella schermata successiva, selezionate <em>Java Module</em> e fornite le solite informazioni di progetto. Un esempio viene mostrato nella <a href=#idea-new-project1a>figura 14.6</a>.

<div class=figure id=idea-new-project1a>
<p class=ft>Figura 14.6. Specificare i dettagli per un progetto Scala in IntelliJ IDEA.
<p><img src=i/idea-new-project1a.png alt="" width=432>
</div>

<p>Cliccate attraverso la schermata intitolata <em>Please Select Desired Technology</em>. Spuntate le <span class=wtf>check box</span> <em>Scala</em> e <em>New Scala <abbr>SDK</abbr></em>. Cliccate il pulsante etichettato &#8220;&hellip;&#8221; per raggiungere l'ubicazione in cui si trova la vostra installazione dello <abbr>SDK</abbr> Scala, come mostrato in <a href=#idea-new-project1b>figura 14.7</a>. Sarà necessario specificare lo <abbr>SDK</abbr> solo la prima volta che create un progetto o quando installate un nuovo <abbr>SDK</abbr> in una posizione differente.

<div class=figure id=idea-new-project1b>
<p class=ft>Figura 14.7. Aggiungere Scala a un progetto IntelliJ IDEA.
<p><img src=i/idea-new-project1b.png alt="" width=432>
</div>

<p>Cliccate <em>Finish</em>. Vi verrà chiesto se volete creare un <em>Project</em> o una <em>Application</em>. Selezionate <em>Application</em> se volete condividere questo progetto con altri progetti Scala sulla stessa macchina.

<p>Ora potete lavorare con il vostro progetto Scala usando la maggior parte degli stessi comandi che usereste con un tipico progetto Java. Per esempio, potete creare un nuovo tratto, una nuova classe o un nuovo oggetto usando il menu contestuale, come per i progetti Java.

<p>Il plug-in IntelliJ IDEA per Scala è ancora in qualità <em>beta</em>, ma gli sviluppatori Scala che usano IDEA dovrebbero trovarlo accettabile per le loro esigenze quotidiane.

<h3 id=_netbeans>NetBeans</h3>

<h4 id=_installing_the_scala_plugins_2>Installare il plug-in per Scala</h4>

<p>NetBeans è dotato di un plug-in per Scala di qualità <em>beta</em>. Per i dettagli, cominciate dalla pagina web <a class=url href=http://wiki.netbeans.org/Scala>http://wiki.netbeans.org/Scala</a>. Viene richiesta la versione 6.5 di NetBeans, o un rilascio notturno più recente. Il plug-in Scala contiene una versione dello <abbr>SDK</abbr> Scala. La pagina wiki fornisce istruzioni per usare un <abbr>SDK</abbr> differente, quando desiderato.

<p>Per installare il plug-in, scaricate il file compresso che lo contiene da  <a class=url href="http://sourceforge.net/project/showfiles.php?group_id=192439&amp;package_id=256544">http://sourceforge.net/project/showfiles.php?group_id=192439&amp;package_id=256544</a>. Estraetene i contenuti in una directory conveniente.

<p>Avviate NetBeans e invocate la voce di menu <em>Tools &rarr; Plugins</em>. Selezionate la scheda <em>Downloaded</em> e clicate il pulsante <em>Add Plugins&hellip;</em>. Scegliete la directory dove avete estratto il plug-in Scala e selezionate tutti i file <span class=file>.nbm</span> elencati, come mostrato nella <a href=#netbeans-add-plugins>figura 14.8</a>. Cliccate <em>Open</em>.

<div class=figure id=netbeans-add-plugins>
<p class=ft>Figura 14.8. Aggiungere il plug-in Scala per l'installazione.
<p><img src=i/netbeans-add-plugins.png alt="" width=432>
</div>

<p>Tornati nella finestra di dialogo <em>Plugins</em>, assicuratevi che le <span class=wtf>check box</span> per tutti i nuovi plug-in siano spuntate. Cliccate <em>Install</em>.

<p>Cliccate attraverso la finestra di dialogo per l'installazione e riavviate NetBeans quando il processo è terminato.

<h4 id=_developing_scala_applications_3>Sviluppare applicazioni in Scala</h4>

<p>Per creare un progetto Scala in NetBeans cominciate col selezionare la voce di menu <em>File &rarr; New Project</em> o cliccate il pulsante <em>New Project</em>. Nella finestra di dialogo, selezionate <em>Scala</em> sotto <em>Categories</em> e <em>Scala Application</em> sotto <em>Projects</em>, come mostrato in <a href=#netbeans-new-project1>figura 14.9</a>. Cliccate <em>Next</em>.

<div class=figure id=netbeans-new-project1>
<p class=ft>Figura 14.9. Creare un progetto Scala in NetBeans.
<p><img src=i/netbeans-new-project1.png alt="" width=432>
</div>

<p>Fornite il nome del progetto, l'ubicazione, <i class=baa>&amp;</i>c. e cliccate <em>Finish</em>.

<p>Una volta che il progetto è stato creato, potete lavorare su di esso usando la maggior parte degli stessi comandi che usereste con un tipico progetto Java. Ci sono alcune differenze. Per esempio, quando invocate l'elemento <em>New</em> nel menu contestuale, il sottomenu non mostra le voci per creare nuovi tipi Scala. Invece, dovete invocare la voce di menu <em>Other &hellip;</em> e attraversare una finestra di dialogo. Questo verrà cambiato in una futura versione.

<p>Nonostante alcuni probemi minori come questo, il plug-in NetBeans per Scala è abbastanza maturo per l'uso regolare.

<h3 id=_text_editors>Editor di testo</h3>

<p>Lo strumento <kbd>sbaz</kbd> gestisce il pacchetto <code>scala-tool-support</code> che include plug-in Scala per diversi editor, compresi <em>Emacs</em>, <em>Vim</em>, <em>TextMate</em> e altri. Come <kbd>sbaz</kbd>, anche il pacchetto <code>scala-tool-support</code> è incluso nell'installazione del linguaggio. Si vedano le directory in <code class=var>scala-home</code><span class=file>/misc/scala-tool-support</span> per gli editor supportati. La maggior parte delle directory specifiche per un editor contiene istruzioni per installare il plug-in. In altri casi, consultate le istruzioni del vostro editor per installare plug-in di terze parti.

<p>Alcuni dei pacchetti sono piuttosto immaturi. Se volete contribuire alla comunità Scala, vi preghiamo di considerare la possibilità di migliorare la qualità dei plug-in esistenti o di contribuire nuovi plug-in.

<blockquote class=note>
<p><span class=u>&#x261E;</span>Al momento della scrittura, ci sono diverse variazioni di un &#8220;bundle&#8221; Scala per l'editor <em>TextMate</em>, che è un popolare editor di testi per Mac OS X. Questi bundle sono attualmente gestiti da Paul Phillips su GitHub all'indirizzo <a class=url href=http://github.com/paulp/scala-textmate/>http://github.com/paulp/scala-textmate/</a>. Sperabilmente, le migliori caratteristiche di ogni bundle verranno unificate in un bundle &#8220;autoritativo&#8221; e integrate nel pacchetto <code>scala-tool-support</code>.
</blockquote>

<h2 id=_test_driven_development_in_scala>Sviluppo guidato dai test in Scala</h2>

<p>Una delle pratiche di sviluppo più importanti introdotte nell'ultima decade è lo <em>sviluppo guidato dai test</em> (in inglese, <em>test-driven development</em> o <abbr>TDD</abbr>). La comunità Scala ha creato diversi strumenti per supportare la <abbr>TDD</abbr>.

<p>Se lavorate in un'azienda Java &#8220;pura&#8221;, considerate la possibilità di introdurre uno o più di questi strumenti di collaudo scritti in Scala per guidare attraverso i test lo sviluppo del vostro codice Java. Questo approccio è un modo a basso rischio di introdurre Scala nel vostro ambiente, così potete acquisire esperienza con il linguaggio prima di <span class=wtf>making the commitment</span> a Scala come linguaggio per il codice di produzione. In particolare, potreste fare esperimenti con <em>ScalaTest</em> (si veda la prossima sezione, intitolata <a href=#ScalaTest>ScalaTest</a>), che può essere usato con <em>JUnit</em> <a href=apa.html#JUnit>[JUnit]</a> e <em>TestNG</em> <a href=apa.html#TestNG>[TestNG]</a>. Potreste anche considerare <em>ScalaCheck</em> o <em>Reductio</em> (si veda la sezione <a href=#ScalaCheck>ScalaCheck</a> più avanti), che offrono innovazioni che potrebbero non essere disponibili nei framework di collaudo di Java. Tutti gli strumenti che descriviamo qui si integrano con gli strumenti di collaudo e di assemblaggio di Java, come <em>JUnit</em>, <em>TestNG</em>, varie librerie di <em class=wtf>mocking</em>, <em>Ant</em>, <em>Maven</em> <a href=apa.html#Maven>[Maven]</a>. Tutti offrono anche convenienti <abbr>DSL</abbr> in Scala per il collaudo.

<h3 id=ScalaTest>ScalaTest</h3>

<p>La versione Scala del venerabile strumento <em>XUnit</em> è <em>ScalaTest</em>, disponibile dal sito <a class=url href=http://www.artima.com/scalatest/>http://www.artima.com/scalatest/</a>.
<!-- TODO "funziona" vs. "si integra" -->
<p>Potete guidare i vostri test utilizzando la classe <code>Runner</code> predefinita oppure usare l'integrazione offerta con <em>JUnit</em> o <em>TestNG</em>. <em>ScalaTest</em> include anche un task per <em>Ant</em> e funziona con lo strumento di collaudo <em>ScalaCheck</em> descritto più avanti.

<p>Oltre a supportare la sintassi nel tradizionale stile <em>XUnit</em> con metodi di test e asserzioni, <em>ScalaTest</em> offre una sintassi per lo <em>sviluppo guidato dal comportamento</em> <a href=apa.html#BDD>[BDD]</a> che sta diventando sempre più popolare. Il sito web di <em>ScalaTest</em> presenta alcuni esempi per queste e altre opzioni.

<p>Ecco un esempio di un test <em>ScalaTest</em> per la semplice classe <code>Complex</code> che abbiamo usato in precedenza nella sezione <a href=#CommandLineToolDecompilers>Gli strumenti <kbd>scalap</kbd>, <kbd>javap</kbd> e <kbd>jad</kbd> a riga di comando</a>.

<pre><code>// <a href=esempi/cap-14/complex-test.scala>esempi/cap-14/complex-test.scala</a>

import org.scalatest.FunSuite

class ComplexSuite extends FunSuite {

  val c1 = Complex(1.2, 3.4)
  val c2 = Complex(5.6, 7.8)

  test("addizione con (0, 0)") {
    assert(c1 + Complex(0.0, 0.0) === c1)
  }

  test("sottrazione con (0, 0)") {
    assert(c1 - Complex(0.0, 0.0) === c1)
  }

  test("addizione") {
    assert((c1 + c2).real === (c1.real + c2.real))
    assert((c1 + c2).imaginary === (c1.imaginary + c2.imaginary))
  }

  test("sottrazione") {
    assert((c1 - c2).real === (c1.real - c2.real))
    assert((c1 - c2).imaginary === (c1.imaginary - c2.imaginary))
  }
}</code></pre>

<p>Questo particolare esempio usa per ogni test la sintassi a &#8220;valori funzione&#8221; che viene fornita dal tratto genitore <code>FunSuite</code>. Ogni invocazione a <code>test</code> riceve come argomenti una stringa di descrizione e un <em>letterale funzione</em> con l'effettivo codice di collaudo.

<p>Il comando seguente compila <span class=file>complex.scala</span> e <span class=file>complex-test.scala</span>, collocando i file di classe nella directory <span class=file>build</span>, e poi esegue i test. Notate che supponiamo che <span class=file>scalatest-0.9.5.jar</span> (l'ultima versione al momento della scrittura) si trovi nella directory <span class=file>../lib</span>. La distribuzione scaricabile degli esempi di codice è organizzata in questo modo.

<pre><samp>scalac -classpath ../lib/scalatest-0.9.5.jar -d build complex.scala complex-test.scala
scala -classpath build:../lib/scalatest-0.9.5.jar org.scalatest.tools.Runner -p build -o -s ComplexSuite</samp></pre>

<p>L'uscita prodotta è la seguente.

<pre><samp>Run starting. Expected test count is: 4
Suite Starting - ComplexSuite: The execute method of a nested suite is about to be invoked.
Test Starting - ComplexSuite: addizione con (0, 0)
Test Succeeded - ComplexSuite: addizione con (0, 0)
Test Starting - ComplexSuite: sottrazione con (0, 0)
Test Succeeded - ComplexSuite: sottrazione con (0, 0)
Test Starting - ComplexSuite: addizione
Test Succeeded - ComplexSuite: addizione
Test Starting - ComplexSuite: sottrazione
Test Succeeded - ComplexSuite: sottrazione
Suite Completed - ComplexSuite: The execute method of a nested suite returned normally.
Run completed. Total number of tests run was: 4
All tests passed.</samp></pre>

<h3 id=ScalaSpecs>Specs</h3>

<p>La libreria <em>Specs</em> <a href=apa.html#ScalaSpecsTool>[ScalaSpecsTool]</a> è uno strumento di collaudo per Scala orientato allo <em>sviluppo guidato dal comportamento</em> <a href=apa.html#BDD>[BDD]</a>. &Egrave; ispirato alla libreria <em>RSpec</em> <a href=apa.html#RSpec>[RSpec]</a> di Ruby. <span class=wtf>In a nutshell</span>, lo scopo del <abbr>BDD</abbr> è di <span class=wtf>recast</span> la sintassi tradizionale dei test in una forma che enfatizzi meglio il ruolo del <abbr>TDD</abbr> come processo che guida la <em>progettazione</em>, che a sua volta dovrebbe implementare la &#8220;specifica&#8221; dei <em>requisiti</em>. La sintassi degli strumenti tradizionali per il <abbr>TDD</abbr> come i framework <em>XUnit</em> tende a enfatizzare il ruolo di <em>collaudo</em> del <abbr>TDD</abbr>. Con la sintassi riallineata, si crede che sia più probabile che lo sviluppatore stia concentrato sul ruolo <em>principale</em> del <abbr>TDD</abbr>: guidare la progettazione dell'applicazione.

<p>Potete anche trovare la documentazione di <em>Specs</em> a <a href=apa.html#ScalaTools>[ScalaTools]</a>.

<p>Abbiamo già usato <em>Specs</em> in diversi esempi nel corso del libro, per esempio <code>ButtonObserverSpec</code> nella sezione <a href=cap-4.html#TraitsAsMixins>I tratti come mixin</a> del capitolo 4. Ecco un altro esempio per la semplice classe <code>Complex</code> che abbiamo precedentemente mostrato.

<pre><code>// <a href=esempi/cap-14/complex-spec.scala>esempi/cap-14/complex-spec.scala</a>

import org.specs._

object ComplexSpec extends Specification {
  "L'addizione complessa con (0.0, 0.0)" should {
    "restituire un numero N' che è identico al numero originale N" in {
      val c1 = Complex(1.2, 3.4)
      (c1 + Complex(0.0, 0.0)) mustEqual c1
    }
  }
  "La sottrazione complessa con (0.0, 0.0)" should {
    "restituire un numero N' che è identico al numero originale N" in {
      val c1 = Complex(1.2, 3.4)
      (c1 - Complex(0.0, 0.0)) mustEqual c1
    }
  }
  "L'addizione complessa" should {
    """restituire un nuovo numero in cui
    le parti reale e immaginaria sono la somma delle parti
    reale e immaginaria dei valori in ingresso, rispettivamente.""" in {
      val c1 = Complex(1.2, 3.4)
      val c2 = Complex(5.6, 7.8)
      (c1 + c2).real mustEqual (c1.real + c2.real)
      (c1 + c2).imaginary mustEqual (c1.imaginary + c2.imaginary)
    }
  }
  "La sottrazione complessa" should {
    """restituire un nuovo numero in cui
    le parti reale e immaginaria sono la differenza delle parti
    reale e immaginaria dei valori in ingresso, rispettivamente.""" in {
      val c1 = Complex(1.2, 3.4)
      val c2 = Complex(5.6, 7.8)
      (c1 - c2).real mustEqual (c1.real - c2.real)
      (c1 - c2).imaginary mustEqual (c1.imaginary - c2.imaginary)
    }
  }
}</code></pre>

<p>Un <code>object</code> che estende <code>Specification</code> è l'analogo di una serie di test. Il livello successivo di raggruppamento, per esempio la clausola <code>"L'addizione complessa con (0.0, 0.0)" should (&hellip;)</code>, incapsula le informazioni al livello del tipo che viene collaudato o forse un &#8220;<span class=wtf>cluster</span>&#8221; di comportamenti che vanno insieme per il tipo.

<p>La clausola al livello successivo, per esempio la clausola <code>"restituire un numero N' che è identico al numero originale N" in (&hellip;)</code> viene chiamata &#8220;esempio&#8221; nella terminologia <abbr>BDD</abbr>. &Egrave; analoga a un singolo test. Come nei tipici framework <em>XUnit</em>, il collaudo viene effettuato usando &#8220;esempi rappresentativi&#8221; piuttosto che tramite l'esplorazione esaustiva dell'intero &#8220;spazio&#8221; degli stati possibili, da cui il termine &#8220;esempio&#8221;. (Tuttavia, si veda la discussione di <em>ScalaCheck</em> più avanti.)

<p>Istruzioni come <code>(c1 + Complex(0.0, 0.0)) mustEqual c1</code> vengono chiamate &#8220;aspettative&#8221;. Eseguono l'effettiva verifica che le condizioni siano soddisfatte. Quindi, le &#8220;aspettative&#8221; sono analoghe alle asserzioni negli strumenti <em>XUnit</em>.

<p>Ci sono diversi modi di eseguire le vostre &#8220;specifiche&#8221;. Dopo aver compilato il file <span class=file>complex-spec.scala</span> appena illustrato, possiamo eseguire la &#8220;specifica&#8221; nel modo seguente.

<pre><samp>scala -classpath ../lib/specs-1.4.3.jar:build ComplexSpec</samp></pre>

<p>Qui, come prima, supponiamo il file <abbr>JAR</abbr> di <em>Specs</em> si trovi nella directory <span class=file>../lib</span> e supponiamo che i file di classe compilati siano nella directory <span class=file>build</span>. Otteniamo la seguente uscita.

<pre><samp>Specification "ComplexSpec"
  L'addizione complessa con (0.0, 0.0) should
  + restituire un numero N' che è identico al numero originale N

  Total for SUT "L'addizione complessa con (0.0, 0.0)":
  Finished in 0 second, 0 ms
  1 example, 1 expectation, 0 failure, 0 error

  La sottrazione complessa con (0.0, 0.0) should
  + restituire un numero N' che è identico al numero originale N

  Total for SUT "La sottrazione complessa con (0.0, 0.0)":
  Finished in 0 second, 0 ms
  1 example, 1 expectation, 0 failure, 0 error

  L'addizione complessa should
  + restituire un nuovo numero in cui
        le parti reale e immaginaria sono la somma delle parti
        reale e immaginaria dei valori in ingresso, rispettivamente.

  Total for SUT "L'addizione complessa":
  Finished in 0 second, 0 ms
  1 example, 2 expectations, 0 failure, 0 error

  La sottrazione complessa should
  + restituire un nuovo numero in cui
        le parti reale e immaginaria sono la differenza delle parti
        reale e immaginaria dei valori in ingresso, rispettivamente.

  Total for SUT "La sottrazione complessa":
  Finished in 0 second, 0 ms
  1 example, 2 expectations, 0 failure, 0 error

Total for specification "ComplexSpec":
Finished in 0 second, 37 ms
4 examples, 6 expectations, 0 failure, 0 error</samp></pre>
<!-- TODO Rimanda alla nota in un capitolo precedente... sì, cioè, 'sti cazzi. -->
<p>Notate che le stringhe nella specifica sono scritte in una forma che si legge abbastanza come una specifica dei requisiti.

<pre><samp>&hellip;
L'addizione complessa con (0.0, 0.0) should
  + restituire un numero N' che è identico al numero originale N
&hellip;</samp></pre>

<p>Ci sono molti modi di eseguire le specifiche, incluso usare un task <em>Ant</em> o l'integrazione <span class=wtf>built-in</span> con <em>ScalaTest</em> o <em>JUnit</em>. <em>JUnit</em> è l'approccio migliore per eseguire le specifiche in qualche <abbr>IDE</abbr>. Queste e altre opzioni sono descritte nella <em>Guida per l'utente</em> di <em>Specs</em>, disponibile all'indirizzo <a class=url href=http://code.google.com/p/specs/wiki/RunningSpecs>http://code.google.com/p/specs/wiki/RunningSpecs</a>.

<h3 id=ScalaCheck>ScalaCheck</h3>
<!-- TODO Terminologia? -->
<p><em>ScalaCheck</em> <a href=apa.html#ScalaCheckTool>[ScalaCheckTool]</a> è una conversione in Scala dell'innovativo strumento Haskell <em>QuickCheck</em> <a href=apa.html#QuickCheck>[QuickCheck]</a> che supporta il <em>collaudo automatico basato sulla specifica</em>, a volte chiamato <em>collaudo di &#8220;proprietà&#8221; basate sul tipo</em> nella letteratura Haskell (per esempio, si veda <a href=apa.html#OSullivan2009>[O'Sullivan2009]</a>).

<p><em>ScalaCheck</em> può essere installato usando <kbd>sbaz</kbd> tramite il comando <kbd>sbaz install scalacheck</kbd>.

<p>Usando <em>ScalaCheck</em> (o <em>QuickCheck</em> per Haskell), vengono specificate le condizioni per un tipo che dovrebbero essere vere per qualsiasi istanza di quel tipo. Lo strumento prova le condizioni usando istanze del tipo generate automaticamente e verifica che le condizioni siano soddisfatte.

<p>Ecco un test <em>ScalaCheck</em> per il tipo <code>Complex</code>.

<pre><code>// <a href=esempi/cap-14/complex-check-script.scala>esempi/cap-14/complex-check-script.scala</a>

import org.scalacheck._
import org.scalacheck.Prop._

def toD(i: Int) = i * .1

implicit def arbitraryComplex: Arbitrary[Complex] = Arbitrary {
  Gen.sized {s =&gt;
    for {
      r &lt;- Gen.choose(-toD(s), toD(s))
      i &lt;- Gen.choose(-toD(s), toD(s))
    } yield Complex(r, i)
  }
}

object ComplexSpecification extends Properties("Complex") {
  def additionTest(a: Complex, b: Complex) =
    (a + b).real.equals(a.real + b.real) &amp;&amp;
    (a + b).imaginary.equals(a.imaginary + b.imaginary)

  def subtractionTest(a: Complex, b: Complex) =
    (a - b).real.equals(a.real - b.real) &amp;&amp;
    (a - b).imaginary.equals(a.imaginary - b.imaginary)

  val zero = Complex(0.0, 0.0)

  specify("addizione con (0,0)", (a: Complex)  =&gt; additionTest(a, zero))
  specify("sottrazione con (0,0)", (a: Complex)  =&gt; subtractionTest(a, zero))

  specify("addizione", (a: Complex, b: Complex) =&gt; additionTest(a,b))
  specify("sottrazione", (a: Complex, b: Complex) =&gt; subtractionTest(a,b))
}
ComplexSpecification.check</code></pre>

<p>La funzione <code>toD</code> converte semplicemente un <code>Int</code> in un <code>Double</code> dividendo per <code>0.1</code>. Serve per convertire un indice intero fornito da <em>ScalaCheck</em> in valori reali che verranno usati per costruire istanze di <code>Complex</code>.

<p>Abbiamo anche bisogno di una conversione implicita che sia visibile nell'ambito del test che genera nuovi valori di <code>Complex</code>. La funzione <code>arbitraryComplex</code> ci fornisce questo generatore. Un oggetto <code>Arbitrary[Complex]</code> (parte della <abbr>API</abbr> di <em>ScalaCheck</em>) viene resituito da questo metodo. <em>ScalaCheck</em> invoca un altro metodo della propria <abbr>API</abbr>, <code>Gen[Complex].sized</code>. Forniamo un <em>letterale funzione</em> che assegna un valore intero <span class=wtf>passed-in</span> a una variabile <var>s</var>. Poi usiamo un'espressione <code>for</code> per restituire numeri complessi con parti reale e immaginaria che vanno da <code>-toD(s)</code> a <code>toD(s)</code> (cioè da <code>-(s * .1)</code> a <code>(s * .1)</code>). Fortunatamente, non dovete definire conversioni implicite o generatori per la maggior parte dei tipi Scala e Java comunemente usati.

<p>La parte più interessante è la definizione e l'uso di <code>ComplexSpecification</code>. Questo oggetto definisce alcuni metodi di aiuto, <code>additionTest</code> e <code>subtractionTest</code>, che restituiscono <code>true</code> se la condizione che definiscono è vera. Per <code>additionTest</code>, se un nuovo numero complesso è la somma di due altri numeri complessi, allora la parte reale di questo numero deve essere uguale alla somma delle parti reali degi due numeri originali. Allo stesso modo, una condizione simile deve verificarsi per la parte immaginaria dei numeri. Per <code>subtractionTest</code>, le stesse condizioni devono verificarsi con la sottrazione sostituita all'addizione.

<p>Poi, due clausole <code>specify</code> asseriscono che le condizioni per l'addizione e la sottrazione dovrebbero verificarsi per ogni numero complesso quando <code>Complex(0.0, 0.0)</code> viene aggiunto o sottratto da quel numero, rispettivamente. Due ulteriori clausole <code>specify</code> asseriscono che le condizioni devono anche verificarsi per qualsiasi coppia di numeri complessi.

<p>Infine, quando <code>ComplexSpecification.check</code> viene invocato, i test vengono eseguiti con differenti valori per i numeri complessi, verificando che le proprietà specificate siano valide per ogni combinazione di numeri passata ai metodi di aiuto.

<p>Possiamo eseguire il controllo usando il comando seguente (ancora una volta, stiamo ipotizzando che <code>Complex</code> sia già stato compilato nella directory <span class=file>build</span>).

<pre><samp>scala -classpath ../lib/scalacheck.jar:build complex-check-script.scala</samp></pre>

<p>L'esecuzione produce l'uscita seguente.

<pre><samp>+ Complex.addizione con (0,0): OK, passed 100 tests.
+ Complex.addizione: OK, passed 100 tests.
+ Complex.sottrazione con (0,0): OK, passed 100 tests.
+ Complex.sottrazione: OK, passed 100 tests.</samp></pre>

<p>Notate che <em>ScalaCheck</em> ha provato ogni caso descritto da una clausola <code>specify</code> con 100 ingressi differenti.

<p>&Egrave; importante capire il valore che <em>ScalaCheck</em> <span class=wtf>delivers</span>. Piuttosto che passare attraverso il processo di scrivere abbastanza test di &#8220;esempio&#8221; con dati rappresentativi, che è tedioso e soggetto a errori, definiamo &#8220;generatori&#8221; riusabili, come la funzione <code>arbitraryComplex</code>, per produrre un intervallo appropriato di istanze del tipo che stiamo collaudando. Poi scriviamo specifiche di proprietà che dovrebbero valere per qualsiasi istanza. <em>ScalaCheck</em> si occupa di verificare le proprietà su un campione casuale di istanze prodotte dal generatore.

<p>Potete trovare ulteriori esempi d'uso di <em>ScalaCheck</em> negli esempi di codice scaricabili. Alcuni dei tipi usati nell'esempio del <em>libro paga</em> nella sezione <a href=cap-11.html#InternalDSLs><abbr>DSL</abbr> interni</a> del capitolo 1 sono stati collaudati con <em>ScalaCheck</em>, anche se i test non sono stati mostrati.

<p>Infine, notate che esiste un'altra conversione di <em>QuickCheck</em> chiamata <em>Reductio</em>. Essa è parte del progetto <a href=apa.html#FunctionalJava>[FunctionalJava]</a>. <em>Reductio</em> è meno popolare di <em>ScalaCheck</em>, ma offre una <abbr>API</abbr> Java &#8220;nativa&#8221; insieme a una <abbr>API</abbr> Scala, quindi sarebbe più conveniente per i gruppi che lavorano solamente in Java.

<h2 id=OtherLibraries>Altre librerie e strumenti degni di nota per Scala</h2>

<p>Mentre Scala beneficia della ricca <span class=wtf>legacy</span> delle librerie Java e .NET, esiste una serie crescente di librerie scritte specificatamente per Scala. Qui discuteremo alcune delle più interessanti.

<h3 id=Lift>Lift</h3>

<p><em>Lift</em> (<a class=url href=http://liftweb.net/>http://liftweb.net/</a>) è il più importante framework per applicazioni web scritto in Scala. Ha recentemente raggiunto la versione 1.0. <em>Lift</em> è stato usato per un certo numero di siti web commerciali. Potete anche trovare la documentazione per Lifr sul sito web di Lift.

<p>Altri framework web includono Sweet (<a class=url href=http://code.google.com/p/sweetscala/>http://code.google.com/p/sweetscala/</a>), Pinky (<a class=url href=http://bitbucket.org/pk11/pinky/>http://bitbucket.org/pk11/pinky/</a>), e Slinky (<a class=url href=http://code.google.com/p/slinky2/>http://code.google.com/p/slinky2/</a>).

<h3 id=Scalaz>Scalaz</h3>

<p><em>Scalaz</em> (<a class=url href=http://code.google.com/p/scalaz/>http://code.google.com/p/scalaz/</a>) è una libreria che riempie i vuoti lasciati dalla libreria standard. Tra le sue funzionalità si annoverano miglioramenti a diversi tipi principali di Scala, come <code>Boolean</code>, <code>Unit</code>, <code>String</code> e <code>Option</code>, più il supporto per astrazioni il <em>controllo</em> funzionali, come <code>FoldLeft</code>, <code>FoldRight</code>, <code>Monad</code>, <i class=baa>&amp;</i>c. che estendono quanto è disponibile nella libreria standard.

<h3 id=Scalax>Scalax</h3>
<!-- TODO completare vs. integrare -->
<p><em>Scalax</em> (<a class=url href=http://scalax.scalaforge.org/>http://scalax.scalaforge.org/</a>) è un altro sforzo per creare una libreria di terze parti per completare la libreria principale di Scala.

<h3 id=MetaScala>MetaScala</h3>

<p><em>MetaScala</em> (<a class=url href=http://www.assembla.com/wiki/show/metascala>http://www.assembla.com/wiki/show/metascala</a>) è una libreria sperimentale di metaprogrammazione per Scala. Le funzioni di metaprogrammazione tendono a essere più deboli nei linguaggi staticamente tipati rispetto ai linguaggi dinamicamente tipati. In più, la <abbr>JVM</abbr> e il <abbr>CLR</abbr> di .NET impongono i propri vincoli sulla metaprogrammazione.

<p>Molte delle caratteristiche di Scala evitano la necessità della metaprogrammazione, se confrontate a linguaggi come Ruby, ma a volte la metaprogrammazione è ancora utile. <em>MetaScala</em> tenta di soddisfare questi bisogni più pienamente rispetto al supporto per la riflessione integrato in Scala.

<h3 id=JavaRebel>JavaRebel</h3>

<p><em>JavaRebel</em> è uno strumento commerciale che permette di ricaricare dinamicamente le classi (scritte in qualsiasi linguaggio) su una <abbr>JVM</abbr> in esecuzione, al di là del supporto limitato fornito nativamente dalla funzione &#8220;HotSwap&#8221; della <abbr>JVM</abbr>. <em>JavaRebel</em> è progettato per offrire allo sviluppatore una risposta più veloce ai cambiamenti, offrendo un'esperienza più simile alla risposta rapida di cui godono gli utenti dei linguaggi dinamici. <em>JavaRebel</em> può essere usato anche con codice Scala.

<h3 id=MiscSmallerLibraries>Varie librerie più piccole</h3>

<p>Infine, ecco una lista di diverse librerie specifiche per Scala che potreste trovare utili per le vostre applicazioni.

<div class=table id=misc-scala-libs>
<p class=tt>Tabella 14.5. Varie librerie Scala.
<table summary="Varie librerie Scala." border=0>
<colgroup>
<col align="left">
<col align="left">
</colgroup>
<thead valign="top"><tr>
<th align="left" valign="top">Nome</th>
<th align="left" valign="top">Descrizione e <abbr>URL</abbr></th>
</tr></thead>
<tbody valign="top">
<tr>
<td align="left" valign="top"><p>Kestrel
<td align="left" valign="top"><p>Un piccolo sistema molto veloce per gestire code. (<a class=url href=http://github.com/robey/kestrel/>http://github.com/robey/kestrel/</a>).
</tr>
<tr>
<td align="left" valign="top"><p>ScalaModules
<td align="left" valign="top"><p>Un <abbr>DSL</abbr> Scala per facilitare lo sviluppo su OSGi (<a class=url href=http://code.google.com/p/scalamodules/>http://code.google.com/p/scalamodules/</a>).
</tr>
<tr>
<td align="left" valign="top"><p>Configgy
<td align="left" valign="top"><p>Gestice i file di configurazione e la registrazione delle attività per i &#8220;demoni&#8221; scritti in Scala (<a class=url href=http://www.lag.net/configgy/>http://www.lag.net/configgy/</a>).
</tr>
<tr>
<td align="left" valign="top"><p>scouchdb
<td align="left" valign="top"><p>Un'interfaccia Scala per CouchDB (<a class=url href=http://code.google.com/p/scouchdb/>http://code.google.com/p/scouchdb/</a>).
</tr>
<tr>
<td align="left" valign="top"><p>Akka
<td align="left" valign="top"><p>Un progetto per implementare una piattaforma su cui costruire applicazioni distribuite e tolleranti ai guasti basate su <abbr>REST</abbr>, attori, <i class=baa>&amp;</i>c. (<a class=url href=http://akkasource.org/>http://akkasource.org</a>).
</tr>
<tr>
<td align="left" valign="top"><p>scala-query
<td align="left" valign="top"><p>Una <abbr>API</abbr> Scala per effettuare query su database in maniera type-safe (<a class=url href=http://github.com/szeiger/scala-query/>http://github.com/szeiger/scala-query/</a>).
</tr>
</tbody>
</table>
</div>

<p>Discuteremo l'uso di Scala con diverse librerie Java ben note dopo aver discusso della interoperabilità con Java nella prossima sezione

<h2 id=JavaInterop>Interoperabilità con Java</h2>

<p>Tra tutti i linguaggi alternativi per la <abbr>JVM</abbr>, l'interoperabilità di Scala con il codice sorgente Java è tra le più <span class=wtf>seamless</span>. Questa sezione comincia con una discussione dell'interoperabilità con codice scritto in Java. Una volta che ne comprendete i dettagli, essi possono essere generalizzati per affrontare l'interoperabilità con altri linguaggi per la <abbr>JVM</abbr>, come JRuby o Groovy. Per esempio, se sapete già come usare JRuby e Java insieme e sapete come usare Java e Scala insieme, allora potete generalizzare per usare JRuby e Scala insieme.

<p>Dato che la sintassi Scala è fondamentalmente un sovrainsieme della sintassi Java, invocare codice Java da Scala è generalmente semplice. Per andare nell'altra direzione è necessario capire come alcune caratteristiche di Scala vengono codificate in modi che soddisfano la specifica della <abbr>JVM</abbr>. Qui discuteremo diverse questioni legate all'interoperabilità. <a href=apa.html#Spiewak2009a>[Spiewak2009a]</a> e <a href=apa.html#Odersky2008>[Odersky2008]</a> forniscono ulteriori informazioni.

<h3 id=_java_and_scala_generics>I generici in Java e Scala</h3>

<p>Abbiamo visto numerosi esempi di codice Scala che usa tipi Java come <code>java.lang.String</code> e varie classi tra le collezioni Java. Instanziare tipi generici Java in Scala è semplice (a partire da Scala 2.7.0). Considerate la seguente classe generica Java molto semplice, <code>JStack</code>.

<pre><code>// <a href=esempi/cap-14/JStack.java>esempi/cap-14/JStack.java</a>

import java.util.*;

public class JStack&lt;T&gt; {
  private List&lt;T&gt; stack = new ArrayList&lt;T&gt;();
  public void push(T t) {
    stack.add(t);
  }
  public T pop() {
    return stack.remove(stack.size() - 1);
  }
}</code></pre>

<p>Possiamo istanziare questa classe da Scala, specificando il parametro di tipo, come mostrato qui di seguito.

<pre><code>// <a href=esempi/cap-14/JStack-spec.scala>esempi/cap-14/JStack-spec.scala</a>

import org.specs._

object JStackSpec extends Specification {
  "L'invocazione di un tipo generico Java da Scala" should {
    "supportare la parametrizzazione" in {
      val js = new JStack[String]
      js must notBe(null)  // controllo fittizio...
    }
    "supportare l'invocazione dei metodi del tipo" in {
      val js = new JStack[String]
      js.push("uno")
      js.push("due")
      js.pop() mustEqual "due"
      js.pop() mustEqual "uno"
    }
  }
}</code></pre>

<p>A partire da Scala 2.7.2, potete anche usare i generici Scala da Java. Considerate il seguente test per JUnit 4, che mostra alcune delle idiosincrasie che potreste incontrare.

<pre><code>// <a href=esempi/cap-14/SMapTest.java>esempi/cap-14/SMapTest.java</a>

import org.junit.*;
import static org.junit.Assert.*;
import scala.*;
import scala.collection.mutable.LinkedHashMap;

public class SMapTest {
  static class Name {
    public String firstName;
    public String lastName;

    public Name(String firstName, String lastName) {
      this.firstName = firstName;
      this.lastName  = lastName;
    }
  }

  LinkedHashMap&lt;Integer, Name&gt; map;

  @Before
  public void setup() {
    map = new LinkedHashMap&lt;Integer, Name&gt;();
    map.update(1, new Name("Dean", "Wampler"));
    map.update(2, new Name("Alex", "Payne"));
  }

  @Test
  public void usingMapGetWithWarnings() {
    assertEquals(2, map.size());
    Option&lt;Name&gt; n1 = map.get(1);  // attenzione!
    Option&lt;Name&gt; n2 = map.get(2);  // attenzione!
    assertTrue(n1.isDefined());
    assertTrue(n2.isDefined());
    assertEquals("Dean", n1.get().firstName);
    assertEquals("Alex", n2.get().firstName);
  }

  @Test
  public void usingMapGetWithoutWarnings() {
    assertEquals(2, map.size());
    Option&lt;?&gt; n1 = map.get(1);
    Option&lt;?&gt; n2 = map.get(2);
    assertTrue(n1.isDefined());
    assertTrue(n2.isDefined());
    assertEquals("Dean", ((Name) n1.get()).firstName);
    assertEquals("Alex", ((Name) n2.get()).firstName);
 }
}</code></pre>

<p>Su sistemi di tipo <abbr>UNIX</abbr>, questo test si può compilare con il seguente comando.

<pre><samp>javac -Xlint:unchecked -cp $SCALA_HOME/lib/scala-library.jar:$JUNIT_HOME/junit-4.4.jar SMapTest.java</samp></pre>

<p><code>SCALA_HOME</code> e <code>JUNIT_HOME</code> sono le directory di installazione di Scala e di JUnit, rispettivamente.

<p>La classe <code>SMapTest</code> definisce una classe <code>Name</code> annidata che viene usate come tipo &#8220;valore&#8221; in un'istanza di <code>scala.collection.mutable.LinkedHashMap</code>. Per semplicità, <code>Name</code> è dotato di campi <code>firstName</code> e <code>lastName</code> pubblici e di un costruttore.

<p>Il metodo <code>setup</code> crea una nuova istanza di <code>LinkedHashMap&lt;Integer,Name&gt;</code> e vi inserisce due coppie chiave-valore. I due test, <code>usingMapGetWithWarnings</code> e <code>usingMapGetWithoutWarnings</code>, esercitano l'interoperabilità tra Java e Scala nello stesso modo. Tuttavia, il primo test genera due avvertimenti a tempo di compilazione, indicati dai commenti, mentre il secondo test viene compilato senza problemi.

<pre><samp>SMapTest.java:29: warning: [unchecked] unchecked conversion
found   : scala.Option
required: scala.Option&lt;SMapTest.Name&gt;
    Option&lt;Name&gt; n1 = map.get(1);  // attenzione!
                             ^
SMapTest.java:30: warning: [unchecked] unchecked conversion
found   : scala.Option
required: scala.Option&lt;SMapTest.Name&gt;
    Option&lt;Name&gt; n2 = map.get(2);  // attenzione!
                             ^
2 warnings</samp></pre>

<p>Gli avvertimenti vengono generati a causa della cancellazione di tipo. Nella libreria Scala compilata, il tipo di ritorno di <code>Map.get</code> è <code>Option</code> senza nessun parametro di tipo o effettivamente <code>Option&lt;Object&gt;</code>. Quindi otteniamo avvertimenti per le conversioni in <code>Option&lt;Name&gt;</code>.

<p>Il secondo test, <code>usingMapGetWithoutWarnings</code>, non genera avvertimenti, perché assegniamo i valori restituiti da <code>Map.get</code> a <code>Option&lt;?&gt;</code> e poi effetuiamo un <span class=wtf>cast</span> esplicito a <code>Name</code> quando invochiamo <code>Option.get</code> nelle ultime due asserzioni.

<h3 id=FunctionsInJava>Usare le funzioni Scala in Java</h3>

<p>Continuando con il nostro precedente esempio <code>SMapTest</code>, possiamo esplorare l'invocazione di codice Scala da Java quando sono richieste le funzioni Scala.

<pre><code>// <a href=esempi/cap-14/SMapTestWithFunctions.java>esempi/cap-14/SMapTestWithFunctions.java</a>

import org.junit.*;
import static org.junit.Assert.*;
import scala.*;
import scala.collection.mutable.LinkedHashMap;
import static scala.collection.Map.Projection;

public class SMapTestWithFunctions {
  static class Name {
    public String firstName;
    public String lastName;

    public Name(String firstName, String lastName) {
      this.firstName = firstName;
      this.lastName  = lastName;
    }

    public static Name emptyName = new Name("", "");

    public static Function0&lt;Name&gt; empty = new Function0&lt;Name&gt;() {
      public Name apply() { return emptyName; }

      public int $tag() { return 0; }
    };
  }

  LinkedHashMap&lt;Integer, Name&gt; map;

  @Before
  public void setup() {
    map = new LinkedHashMap&lt;Integer, Name&gt;();
    map.update(1, new Name("Dean", "Wampler"));
    map.update(2, new Name("Alex", "Payne"));
  }

  @Test
  public void usingMapGetOrElse() {
    assertEquals(2, map.size());
    assertEquals("Dean", ((Name) map.getOrElse(1, Name.empty)).firstName);
    assertEquals("Alex", ((Name) map.getOrElse(2, Name.empty)).firstName);
  }

  Function1&lt;Integer, Boolean&gt; filter = new Function1&lt;Integer, Boolean&gt;() {
    public Boolean apply(Integer i) { return i.intValue() &lt;= 1; }

    public &lt;A&gt; Function1&lt;A,Boolean&gt; compose(Function1&lt;A,Integer&gt; g) {
      return Function1$class.compose(this, g);
    }

    public &lt;A&gt; Function1&lt;Integer,A&gt; andThen(Function1&lt;Boolean,A&gt; g) {
      return Function1$class.andThen(this, g);
    }

    public int $tag() { return 0; }
  };

  @Test
  public void usingFilterKeys() {
    assertEquals(2, map.size());
    Projection&lt;Integer, Name&gt; filteredMap =
        (Projection&lt;Integer, Name&gt;) map.filterKeys(filter);
    assertEquals(1, filteredMap.size());
    assertEquals("Dean", filteredMap.getOrElse(1, Name.empty).firstName);
    assertEquals("",     filteredMap.getOrElse(2, Name.empty).firstName);
  }
}</code></pre>

<p>La classe <code>SMapTestWithFunctions</code> possiede la propria classe <code>Name</code> che aggiunge un oggetto statico <var>emptyName</var> e un oggetto statico di tipo <code>scala.Function0</code> chiamato <var>empty</var>, che definisce <code>apply</code> in modo da restituire <code>emptyName</code>. Notate che è anche necessario definire il metodo <code>$tag</code> che è stato discusso in precedenza nella sezione <a href=#CommandLineToolDecompilers>Gli strumenti <kbd>scalap</kbd>, <kbd>javap</kbd> e <kbd>jad</kbd> a riga di comando</a>.

<p>L'oggetto funzione <code>empty</code> è necessario quando usiamo <code>Map.getOrElse</code> nel metodo di collaudo, <code>usingMapGetOrElse</code>. La firma di <code>getOrElse</code> è la seguente

<pre><code>def getOrElse[B2 &gt;: B](key : A, default : =&gt; B2) : B2</code></pre>

<p>Qui, <code>A</code> è il parametro di tipo per la chiave, <code>B</code> è il parametro di tipo del valore e <code>B2</code> è un supertipo di <code>B</code> o lo stesso tipo di <code>B</code>. Il secondo argomento <code>default</code> è un parametro <em>per nome</em>, di cui abbiamo parlato nel <a href=cap-8.html>capitolo 8</a>. Notate che i parametri <em>per nome</em> sono implementati come oggetti <code>scala.Function0</code>. Quindi, non possiamo semplicemente passare l'oggetto statico <code>emptyName</code>.

<p>Il secondo test, <code>usingFilterKeys</code>, richiede un oggetto <code>Function1</code>, che è dotato di un metodo <code>apply</code> che accetta un argomento. Usiamo questo oggetto <code>Function1</code> come un filtro passato a <code>Map.filterKeys</code>.

<p>Definiamo il filtro prima del test. Il codice Java qui è considerevolmente più complicato di quanto sarebbe il codice Scala equivalente. Non solo dobbiamo definire i metodi <code>apply</code> e <code>$tag</code>, dobbiamo anche definire i metodi usari per la composizione di funzioni, <code>compose</code> e <code>andThen</code>. Fortunatamente, possiamo delegare agli oggetti che sono già parte della libreria Scala, come mostrato. Notate che altri tipi <code>FunctionN</code>, per <code>N</code> che va da 2 a 22, hanno altri metodi che avremmo dovuto implementare usando simile codice &#8220;stereotipato&#8221;. Per esempio, ognuno di questi tipi ha il proprio metodo <code>curry</code>.

<p>Infine, ricordatevi che nella sezione <a href=cap-6.html#CompanionObjectsAndJavaStaticMethods>Gli oggetti associati e i metodi statici di Java</a> del capitolo 6, abbiamo evidenziato come i metodi definiti negli oggetti associati non sono visibili come metodi statici al codice Java. Per esempio, i metodi <code>main</code> definiti negli oggetti associati non possono essere usati per eseguire applicazioni. Invece, dovreste definire tali metodi in oggetti <em>singleton</em>.

<p>Quindi, usare gli oggetti funzione di Scala può essere difficile. Se trovate necessario usarli frequentemente, potreste definire alcune classi Java di utilità che gestiscano il codice &#8220;steretipato&#8221; per tutti i metodi tranne <code>apply</code>.

<h3 id=JavaBeanProperties>Proprietà JavaBeans</h3>

<p>Nel <a href=cap-5.html>capitolo 5</a> abbiamo visto che Scala non segue le convenzioni <em>JavaBeans</em> <a href=apa.html#JavaBeansSpec>[JavaBeansSpec]</a> per i metodi di lettura e scrittura dei campi, per ragioni descritte nella sezione <a href=cap-6.html#UniformAccessPrinciple>Quando i metodi di accesso e i campi sono indistinguibili: il principio di accesso uniforme</a>. Tuttavia, in certe occasioni potreste aver bisogno dei metodi di accesso nello stile <em>JavaBeans</em>. Per esempio, questi metodi vi servono quando volete che le vostre istanze Scala siano configurabili da un meccanismo di <em>iniezione di dipendenze</em> come quello fornito dal framework Spring <a href=apa.html#SpringFramework>[SpringFramework]</a>. Potreste aver bisogno dei metodi di accesso nello stile <em>JavaBeans</em> anche per alcuni <abbr>IDE</abbr> che eseguono l'&#8220;introspezione&#8221; dei componenti.

<p>Scala risolve questo problema con un'annotazione che potete applicare ai campi, <code>@scala.reflect.BeanProperty</code>, che dice al compilatore di generare metodi di accesso e di impostazione nello stile <em>JavaBeans</em>. Abbiamo introdotto questa annotazione nella sezione <a href=cap-13.html#Annotations>Annotazioni</a> del capitolo 13.

<p>Ricordate la classe <code>Complex</code> che abbiamo visto in precedenza? Ora aggiungiamo l'annotazione a ogni parametro del costruttore, che in una classe <code>case</code> rappresenta un campo.

<pre><code>// <a href=esempi/cap-14/complex-javabean.scala>esempi/cap-14/complex-javabean.scala</a>

case class ComplexBean(
  @scala.reflect.BeanProperty real: Double,
  @scala.reflect.BeanProperty imaginary: Double) {

  def +(that: ComplexBean) =
    new ComplexBean(real + that.real, imaginary + that.imaginary)
  def -(that: ComplexBean) =
    new ComplexBean(real - that.real, imaginary - that.imaginary)
}</code></pre>

<p>Se compilate questa classe e poi la decompilate con <kbd>javap -classpath &hellip; ComplexBean</kbd>, ottenete l'uscita seguente.

<pre><code>public class ComplexBean extends java.lang.Object
  implements scala.ScalaObject,scala.Product,java.io.Serializable{
  public ComplexBean(double, double);
  public java.lang.Object productElement(int);
  public int productArity();
  public java.lang.String productPrefix();
  public boolean equals(java.lang.Object);
  public java.lang.String toString();
  public int hashCode();
  public int $tag();
  public ComplexBean $minus(ComplexBean);
  public ComplexBean $plus(ComplexBean);
  public double imaginary();
  public double real();
  public double getImaginary();
  public double getReal();
}</code></pre>

<p>Ora confrontate questa uscita con il risultato della decompilazione del file <span class=file>Complex.class</span> originale.

<pre><code>public class Complex extends java.lang.Object
  implements scala.ScalaObject,scala.Product,java.io.Serializable{
  public Complex(double, double);
  public java.lang.Object productElement(int);
  public int productArity();
  public java.lang.String productPrefix();
  public boolean equals(java.lang.Object);
  public java.lang.String toString();
  public int hashCode();
  public int $tag();
  public Complex $minus(Complex);
  public Complex $plus(Complex);
  public double imaginary();
  public double real();
}</code></pre>

<p>L'ordine dei metodi mostrati potrebbe essere differente quando eseguite <kbd>javap</kbd> su questi file. Li abbiamo riordinati in modo che i due elenchi corrispondano quanto più è possibile. Notate che le sole differenze sono i nomi delle classi e la presenza dei metodi <code>getImaginary</code> e <code>getReal</code> nel caso di <code>ComplexBean</code>. Avremmo avuto anche i corrispondenti metodi per l'impostazione dei valori se i campi <code>real</code> e <code>imaginary</code> fossero stati dichiarati come <code>var</code> invece che <code>val</code>.
<!-- NON CHIARO!!! Puoi invocarli o no? O vengono invocati "automaticamente" da Scala, ma tu non puoi direttamente? -->
<blockquote class=warning>
<p><span class=u>&#x2762;</span>La pagina <em>Scaladoc</em> per <code>@BeanProperty</code> (per Scala 2.7) dice che non potete invocare i metodi di scrittura dei campi da Scala. In realtà potete invocarli, ma come la pagina <em>Scaladoc</em> procede a dire, dovreste preferibilmente usare i metodi di scrittura (e di lettura) nello stile di Scala.
</blockquote>

<h3 id=AnyValTypesAndJavaPrimitives>I tipi <code>AnyVal</code> e i tipi primitivi in Java</h3>

<p>Notate anche che nel precedente esempio di <code>Complex</code> le istanze di <code>Double</code> venivano convertite in valori primitivi <code>double</code> di Java. Tutti i tipi <code>AnyVal</code> vengono convertiti nei loro corrispondenti tipi Java primitivi. Abbiamo mostrato la corrispondenza nella <a href=cap-7.html#AnyVal-value-types>tabella 7.3</a>. In particolare, notate che <code>Unit</code> corrisponde a <code>void</code>.

<h3 id=ScalaNamesInJavaCode>Nomi Scala nel codice Java</h3>

<p>Come abbiamo discusso nel <a href=cap-3.html>capitolo 3</a>, Scala ammette identificatori più flessibili, per esempio <em>caratteri operatore</em> come <code>*</code>, <code>&lt;</code>, <i class=baa>&amp;</i>c. Questi caratteri vengono codificati (o &#8220;<span class=wtf>mangled</span>&#8221;, se preferite) per soddisfare i vincoli più stretti della specifica <abbr>JVM</abbr>. Vengono tradotti come segue (adattato da <a href=apa.html#Spiewak2009a>[Spiewak2009a]</a>).

<div class=table id=char-encoding>
<p class=tt>Tabella 14.6. Codifica dei caratteri operatore.
<table summary="Codifica dei caratteri operatore." border=0>
<colgroup>
<col align="left">
<col align="left">
</colgroup>
<thead valign="top"><tr>
<th align="left" valign="top">Operatore</th>
<th align="left" valign="top">Codifica</th>
</tr></thead>
<tbody valign="top">
<tr>
<td align="left" valign="top"><p>=
<td align="left" valign="top"><p><code>$eq</code>
</tr>
<tr>
<td align="left" valign="top"><p>&gt;
<td align="left" valign="top"><p><code>$greater</code>
</tr>
<tr>
<td align="left" valign="top"><p>&lt;
<td align="left" valign="top"><p><code>$less</code>
</tr>
<tr>
<td align="left" valign="top"><p>+
<td align="left" valign="top"><p><code>$plus</code>
</tr>
<tr>
<td align="left" valign="top"><p>-
<td align="left" valign="top"><p><code>$minus</code>
</tr>
<tr>
<td align="left" valign="top"><p>*
<td align="left" valign="top"><p><code>$times</code>
</tr>
<tr>
<td align="left" valign="top"><p>/
<td align="left" valign="top"><p><code>$div</code>
</tr>
<tr>
<td align="left" valign="top"><p>\
<td align="left" valign="top"><p><code>$bslash</code>
</tr>
<tr>
<td align="left" valign="top"><p>|
<td align="left" valign="top"><p><code>$bar</code>
</tr>
<tr>
<td align="left" valign="top"><p>!
<td align="left" valign="top"><p><code>$bang</code>
</tr>
<tr>
<td align="left" valign="top"><p>?
<td align="left" valign="top"><p><code>$qmark</code>
</tr>
<tr>
<td align="left" valign="top"><p>:
<td align="left" valign="top"><p><code>$colon</code>
</tr>
<tr>
<td align="left" valign="top"><p>%
<td align="left" valign="top"><p><code>$percent</code>
</tr>
<tr>
<td align="left" valign="top"><p>^
<td align="left" valign="top"><p><code>$up</code>
</tr>
<tr>
<td align="left" valign="top"><p>&amp;
<td align="left" valign="top"><p><code>$amp</code>
</tr>
<tr>
<td align="left" valign="top"><p>@
<td align="left" valign="top"><p><code>$at</code>
</tr>
<tr>
<td align="left" valign="top"><p>#
<td align="left" valign="top"><p><code>$hash</code>
</tr>
<tr>
<td align="left" valign="top"><p>~
<td align="left" valign="top"><p><code>$tilde</code>
</tr>
</tbody>
</table>
</div>

<p>Potete vedere questo all'opera nel seguente tratto artificioso, dove ogni carattere viene usato per dichiarare un metodo astratto che non prende argomenti e restituisce <code>Unit</code>.

<pre><code>// <a href=esempi/cap-14/all-op-chars.scala>esempi/cap-14/all-op-chars.scala</a>

trait AllOpChars {
  def == : Unit   // $eq$eq
  def &gt;  : Unit   // $greater
  def &lt;  : Unit   // $less
  def +  : Unit   // $plus
  def -  : Unit   // $minus
  def *  : Unit   // $times
  def /  : Unit   // $div
  def \  : Unit   // $bslash
  def |  : Unit   // $bar
  def !  : Unit   // $bang
  def ?  : Unit   // $qmark
  def :: : Unit   // $colon$colon
  def %  : Unit   // $percent
  def ^  : Unit   // $up
  def &amp;  : Unit   // $amp
  def @@ : Unit   // $at$at
  def ## : Unit   // $hash$hash
  def ~  : Unit   // $tilde
}</code></pre>

<p>Notate che abbiamo raddoppiato alcuni dei caratteri per consentirne la compilazione come nomi di metodo, laddove usare un singolo carattere sarebbe risultato ambiguo. Compilare questo file e poi decompilare il file di classe risultante con <kbd>javap AllOpChars</kbd> produce la seguente interfaccia Java. (Abbiamo riarrangiato l'ordine dei metodi per farlo combaciare con l'ordine nel file Scala originale.)

<pre><code>Compiled from "all-op-chars.scala"
public interface AllOpChars{
  public abstract void $eq$eq();
  public abstract void $greater();
  public abstract void $less();
  public abstract void $plus();
  public abstract void $minus();
  public abstract void $times();
  public abstract void $div();
  public abstract void $bslash();
  public abstract void $bar();
  public abstract void $bang();
  public abstract void $qmark();
  public abstract void $colon$colon();
  public abstract void $percent();
  public abstract void $up();
  public abstract void $amp();
  public abstract void $at$at();
  public abstract void $hash$hash();
  public abstract void $tilde();
}</code></pre>

<p>Per concludere, l'interoperabilità tra Java e Scala funziona molto bene, ma ci sono alcune cose che dovreste ricordare quando invocate codice Scala da Java. Se non siete sicuri di come un identificatore Scala viene codificato o di come un metodo Scala viene trasformato in bytecode valido, usate <kbd>javap</kbd> per scoprirlo.

<h2 id=JavaLibraryInterop>L'interoperabilità con le librerie Java</h2>

<p>Questa sezione considera nello specifico l'interoperabilità con diversi framework Java importanti: AspectJ, il framework Spring, Terracotta e Hadoop. Dato che sono ampiamente usati nelle applicazioni Java &#8220;aziendali&#8221; e di rete, la riuscita interoperabilità con Scala è importante.

<h3 id=AspectJInterop>AspectJ</h3>

<p>AspectJ <a href=apa.html#AspectJ>[AspectJ]</a> è un'estensione di Java che supporta la <em>programmazione orientata agli aspetti</em> (<abbr>AOP</abbr>), anche nota come <em>sviluppo del software orientato agli aspetti</em> <a href=apa.html#AOSD>[AOSD]</a>. Lo scopo della <abbr>AOP</abbr> è abilitare modifiche sistematiche dello stesso tipo attraverso molti moduli, evitando nel contempo di copiare e incollare lo stesso codice più volte in ogni posto. Evitare questa duplicazione non solo incrementa la produttività, ma riduce enormemente i bug.

<p>Per esempio, se volete che tutte le modifiche ai campi per tutti gli oggetti del &#8220;modello del dominio&#8221; siano rese automaticamente persistenti dopo che i cambiamenti si verificano, potete scrivere un aspetto che osserva quei cambiamenti e che innesca la scrittura persistente dopo ogni modifica.

<p>AspectJ supporta la <abbr>AOP</abbr> offrendo un <em class=wtf>pointcut language</em> per specificare in maniera dichiarativa tutti i &#8220;punti di esecuzione&#8221; in un programma per il quale viene richiesta una particolare modifica nel comportamento (chiamata <em class=wtf>advice</em>). Nella terminologia di AspectJ, ogni punto di esecuzione viene chiamato <em>punto di unione</em> e una particolare <span class=wtf>query</span> sui punti di unione è un <em class=wtf>pointcut</em>. Quindi, il <em>pointcut language</em> è una specie di linguaggio di interrogazione. Per un dato <span class=wtf>pointcut</span>, AspectJ incorpora le modifiche comportamentali desiderate in ogni punto di unione. L'inserimento manuale di queste modifiche non è obbligatorio. Un <em>aspetto</em> incapsula i <span class=wtf>pointcut</span> e gli <span class=wtf>advice</span>, in modo simile a come una classe incapsula campi e metodi.

<p>Per una introduzione dettagliata ad AspectJ corredata di molti esempi pratici, si veda <a href=apa.html#Laddad2009>[Laddad2009]</a>.

<p>Ci sono due problemi che devono essere considerati quando si usa AspectJ con Scala. Il primo problema è come fare riferimento ai punti di esecuzione definiti in Scala (per esempio, metodi e tipi Scala) usando il linguaggio <span class=wtf>pointcut</span> di AspectJ. Il secondo problema è come invocare codice Scala sotto forma di <em class=wtf>advice</em>.

<p>Diamo un'occhiata a un aspetto che registra le invocazioni di metodo sulla classe <code>Complex</code> che abbiamo precedentemente usato in questo capitolo. Questa volta aggiungeremo una dichiarazione di package per fornire un ambito di visibilità.

<pre><code>// <a href=esempi/cap-14/aspectj/complex.scala>esempi/cap-14/aspectj/complex.scala</a>

package example.aspectj

case class Complex(real: Double, imaginary: Double) {
  def +(that: Complex) =
    new Complex(real + that.real, imaginary + that.imaginary)
  def -(that: Complex) =
    new Complex(real - that.real, imaginary - that.imaginary)
}</code></pre>

<p>Ecco un <code>object</code> che usa questa classe <code>Complex</code>.

<pre><code>// <a href=esempi/cap-14/aspectj/complex-main.scala>esempi/cap-14/aspectj/complex-main.scala</a>

package example.aspectj

object ComplexMain {
  def main(args: Array[String]) {
    val c1 = Complex(1.0, 2.0)
    val c2 = Complex(3.0, 4.0)
    val c12 = c1 + c2
    println(c12)
  }
}</code></pre>

<p>Di seguito, ecco un aspetto AspectJ che definisce un <em class=wtf>pointcut</em> per la creazione di istanze di <code>Complex</code> e un altro <span class=wtf>pointcut</span> per l'invocazione del metodo <code>+</code>.

<pre><code>// <a href=esempi/cap-14/aspectj/LogComplex.aj>esempi/cap-14/aspectj/LogComplex.aj</a>

package example.aspectj;

public aspect LogComplex {
  public pointcut newInstances(double real, double imag):
    execution(Complex.new(..)) &amp;&amp; args(real, imag);

  public pointcut plusInvocations(Complex self, Complex other):
    execution(Complex Complex.$plus(Complex)) &amp;&amp; this(self) &amp;&amp; args(other);

  before(double real, double imag): newInstances(real, imag) {
    System.out.println("new Complex(" + real + "," + imag + ") invocato.");
  }

  before(Complex self, Complex other): plusInvocations(self, other) {
    System.out.println("Invoco " + self + ".+(" + other + ")");
  }

  after(Complex self, Complex other) returning(Complex c):
    plusInvocations(self, other) {
    System.out.println("Complex.+ ha restituito " + c);
  }
}</code></pre>

<p>Non spiegheremo tutti i dettagli della sintassi AspectJ qui. Si vedano i documenti <a href=apa.html#AspectJ>[AspectJ]</a> e <a href=apa.html#Laddad2009>[Laddad2009]</a> per quei dettagli. Ci limiteremo a un'introduzione &#8220;concettuale&#8221; di questo aspetto.

<p>Il primo <code>pointcut</code>, <code>newInstance</code>, corrisponde alle &#8220;esecuzioni&#8221; delle invocazioni del costruttore, usando la sintassi <code>Complex.new</code> per fare riferimento al costruttore. Ci aspettiamo argomenti di tipo <code>double</code> per l'invocazione del costruttore. Come abbiamo visto in precedenza, le occorrenze di <code>scala.Double</code> vengono convertite al tipo primitivo <code>double</code> di Java durante la generazione del bytecode. La clausola <code>args</code> &#8220;lega&#8221; i valori degli argomenti passati in modo che possiamo fare riferimento a essi nell'<em class=wtf>advice</em>.

<p>Il secondo <code>pointcut</code>, <code>plusInvocation</code>, corrisponde alle &#8220;esecuzioni&#8221; del metodo <code>+</code>, che in effetti si chiama <code>$plus</code> nel bytecode. I parametri <var>self</var> e <var>other</var> vengono legati all'oggetto su cui il metodo <code>+</code> è stato invocato (usando la clausola <code>this</code>) e all'argomento passato (usando la clausola <code>args</code>), rispettivamente.

<p>Il primo <em class=wtf>advice</em> <code>before</code> viene eseguito per il <span class=wtf>pointcut</span> <code>newInstances</code>, cioè prima di entrare effettivamente nel costruttore. &#8220;Registriamo&#8221; l'invocazione, mostrando gli effettivi valori reale e immaginario passati come argomenti.

<p>L'<em class=wtf>advice</em> <code>before</code> successivo viene eseguito per il <span class=wtf>pointcut</span> <code>plusInvocation</code>, cioè prima che il metodo <code>+</code> venga eseguito. Registriamo il valore di <code>self</code> (cioè, l'istanza <code>this</code>) e l'altro numero.

<p>Infine, viene eseguito anche un <em class=wtf>advice</em> <code>after returning</code> per il <span class=wtf>pointcut</span> <code>plusInvocation</code>, cioè dopo che il metodo <code>+</code> si è concluso. Catturiamo il valore di ritorno nella variabile <var>c</var> e lo registriamo.

<p>Se avete AspectJ installato in una directory <code class=var>aspectj-home</code>, potete compilare questo file come segue.

<pre><samp>ajc -classpath .:aspectj-home/lib/aspectjrt.jar:../lib/scala-library.jar aspectj/LogComplex.aj</samp></pre>
<!-- TODO "weave into" -->
<p>Per eseguire questo codice con l'aspetto <code>LogComplex</code>, usiamo <em class=wtf>load-time weaving</em> (<a class=url href=http://www.eclipse.org/aspectj/doc/released/devguide/ltw.html>http://www.eclipse.org/aspectj/doc/released/devguide/ltw.html</a>). Invocheremo Java con un <em>agente</em> che &#8220;<span class=wtf>weaves</span>&#8221; l'<em class=wtf>advice</em> da <code>LogComplex</code> in <code>Complex</code>. Per usare il <span class=wtf>load-time weaving</span>, abbiamo anche bisogno del seguente file di configurazione, <span class=file>META-INF/aop.xml</span>.

<pre><code>&lt;!-- <a href=esempi/cap-14/META-INF/aop.xml>esempi/cap-14/META-INF/aop.xml</a> --&gt;

&lt;aspectj&gt;
  &lt;aspects&gt;
    &lt;aspect name="example.aspectj.LogComplex" /&gt;
    &lt;include within="example.aspectj.*" /&gt;
  &lt;/aspects&gt;

  &lt;weaver options="-verbose"&gt;
    &lt;dump within="example.aspectj.*" beforeandafter="true"&gt;
      &lt;include within="example.aspectj.*" /&gt;
    &lt;/dump&gt;
  &lt;/weaver&gt;
&lt;/aspectj&gt;</code></pre>

<p>La directory <span class=file>META-INF</span> dovrebbe essere nel percorso di ricerca delle classi; supporremo che si trovi nella directory di lavoro corrente.) Questo file dice al <span class=wtf>weaver</span> quale aspetto usare (il tag <code>aspect</code>), verso quale dirigere il <span class=wtf>weaving</span> (il tag <code>include</code>) e abilita anche l'uscita verbosa, utile per scopi di debug. Infine, possiamo eseguire l'applicazione con il comando seguente.
<!-- TODO dire qualcosa su "/" -->
<pre><samp>java -classpath .:aspectj-home/lib/aspectjrt.jar:../lib/scala-library.jar \
                -javaagent:aspectj-home/lib/aspectjweaver.jar example.aspectj.ComplexMain</samp></pre>

<p>Ottenete diverse righe di messaggi che registrano il processo di <span class=wtf>weaving</span>. L'uscita si conclude con queste righe.

<pre><samp>new Complex(1.0,2.0) invocato.
new Complex(3.0,4.0) invocato.
Invoco Complex(1.0,2.0).+(Complex(3.0,4.0))
new Complex(4.0,6.0) invocato.
Complex.+ ha restituito Complex(4.0,6.0)
Complex(4.0,6.0)</samp></pre>

<p>Tutte le righe tranne l'ultima sono state stampate da <code>LogComplex</code>. Abbiamo aggiunto questo comportamento addizionale senza inserire manualmente queste istruzioni nella classe <code>Complex</code> stessa!

<p>Ricordatevi che abbiamo detto che il secondo problema che potreste incontrare quando usate AspectJ è come invocare codice Scala da un <em class=wtf>advice</em>. Nel nostro aspetto <code>LogComplex</code>, le istruzioni all'interno dei diversi <span class=wtf>advice</span> <code>before</code> e <code>after</code> sono effettivamente solo codice Java. Di conseguenza, possiamo invocare codice Scala altrettanto facilmente, applicando le stesse lezioni che abbiamo già imparato per invocare codice Scala da Java.

<p>I tratti Scala sostituiscono <em>quasi</em> completamente gli aspetti. Nel <a href=cap-4.html>capitolo 4</a> e nel <a href=cap-13.html>capitolo 13</a> abbiamo visto come potete costruire tratti che modificano il comportamento di altri tratti, e poi mescolare insieme i comportamenti quando create nuove classi o nuove istanze. Questa potente tecnica vi permette di implementare una forma di <span class=wtf>aspect <em>adivce</em></span>. Tuttavia, Scala non possiede un linguaggio <span class=wtf>pointcut</span> come AspectJ. Quando dovete influenzare un insieme di punti di unione che non condividono uno stesso supertipo, avrete bisogno delle capacità di AspectJ. Tuttavia, se vi trovate in questa situazione, dovreste considerare se potete riorganizzare il vostro codice in modo da estrarre un tratto comune che fornisce gli &#8220;agganci&#8221; che vi servono per implementare un <em class=wtf>advice</em> usando i tratti.

<h3 id=TheSpringFrameworkInterop>Il framework Spring</h3>

<p>Il framework Spring <a href=apa.html#SpringFramework>[SpringFramework]</a> è un framework Java open source, modulare e pronto per le aziende che offre una <abbr>API</abbr> Java pura per la <abbr>AOP</abbr>, supporto integrato per AspectJ, un contenitore per la <em>iniezione di dipendenza</em> (in inglese, <em>dependency injection</em> o <abbr>DI</abbr>), <abbr>API</abbr> uniformi e ben progettate per invocare una varietà di altre <abbr>API</abbr> Java di terze parti, e componenti aggiuntivi per la sicurezza, lo sviluppo web, <i class=baa>&amp;</i>c.

<p>Qui ci concentreremo sulla iniezione di dipendenza, in quanto i problemi di interoperabilità con le altre parti di Spring si riducono a problemi riguardanti Java o AspectJ, di cui abbiamo già parlato.

<p>Abbiamo discusso il concetto di <abbr>DI</abbr> nella sezione <a href=cap-13.html#DependencyInjectionInScala>L'iniezione di dipendenza in Scala: il pattern torta</a> del capitolo 13, dove abbiamo mostrato eleganti patter per l'iniezione di dipendenza usando lo stesso Scala. Tuttavia, se vi trovate in un ambiente misto Java/Scala, potrebbe essere necessario usare un framework <abbr>DI</abbr> come quello fornito da Spring per gestire le dipendenze.

<p>Nella <abbr>DI</abbr> di Spring, le dipendenze vengono specificate usando una combinazione di file di configurazione <abbr>XML</abbr> e annotazioni nel codice sorgente. La <abbr>API</abbr> di Spring risolve queste dipendenze nel momento in cui le classi vengono istanziate. Spring si aspetta che queste classi seguano le convenzioni <em>JavaBeans</em> (si veda <a href=apa.html#JavaBeansSpec>[JavaBeansSpec]</a>). Classi ben progettate dipenderanno solamente dalle astrazioni, cioè da interfacce Java o tratti Scala, e le istanze concrete che soddisfano quelle dipendenze verranno passate ai componenti <em>JavaBeans</em> come argomenti di un costruttore o attraverso i metodi per impostare i valori. Quindi, se usate la <abbr>DI</abbr> di Spring con le classi Scala, dovrete usare l'annotazione <code>@scala.reflect.BeanProperty</code> quando usate l'iniezione attraverso i metodi per impostare i valori. L'annotazione non è necessaria se usate l'iniezione attraverso i costruttori.

<blockquote class=note>
<p><span class=u>&#x261E;</span>Privilegiate l'iniezione attraverso i costruttori, quando è possibile. Questa scelta non solo elimina il bisogno di usare l'annotazione <code>@BeanProperty</code>, ma lascia ogni istanza in uno stato noto e valido quando il processo di costruzione termina.
</blockquote>

<p>Tuttavia, se iniettate dipendenze in un <code>object</code> Scala, dovete usare l'iniezione attraverso i metodi per impostare i valori, dato che non avete modod di definire i parametri del costruttore e non avete il controllo sul processo di costruzione.

<p>Un altro punto: ricordate che Spring si aspetta nomi compatibili con Java, quindi dovete usare nomi <em>codificati</em> per i metodi e gli oggetti, quando è necessario.

<p>Ecco un esempio che illustra come &#8220;collegare&#8221; oggetti tra loro con Spring.

<pre><code>// <a href=esempi/cap-14/spring/object-bean.scala>esempi/cap-14/spring/object-bean.scala</a>

package example.spring

case class NamedObject(name: String)

trait Factory {
  @scala.reflect.BeanProperty
  var nameOfFactory = "sconosciuto"

  def make(name: String): AnyRef
}

object NamedObjectFactory extends Factory {
  def make(name: String) = NamedObject(name)
}

case class FactoryUsingBean(factory: Factory)</code></pre>

<p>La classe <code>case</code> <code>FactoryUsingBean</code> è un semplice tipo di dipendenza da un'astrazione <code>Factory</code> che vogliamo iniettare usando un costruttore.

<p>Il tratto <code>Factory</code> definisce l'astrazione di factory. &Egrave; dotato di un metodo <code>make</code> per creare istanze di qualche tipo. Per mostrare l'iniezione attraverso i metodi per impostare i valori sugli <code>object</code>, lo dotiamo anche di un campo <var>nameOfFactory</var>. Questo mostrerà l'iniezione di dipendenza sugli <code>object</code> perché il sottotipo concreto che useremo effettivamente, <code>NamedObjectFactory</code>, è un <code>object</code>.

<p>Scala ci richiede di inizializzare <var>nameOfFactory</var> con un valore, ma useremo Spring per impostare il valore reale. Dobbiamo usare l'annotazione <code>@BeanProperty</code> per generare il metodo <code>setNameOfFactory</code> che Spring si aspetta di trovare.

<p>Il metodo concreto <code>make</code> in <code>NamedObjectFactory</code> crea una nuova istanza di <code>NamedObject</code>, una semplice classe <code>case</code> con un campo <var>name</var>.

<p>Notate che nessuno di questi tipi dipende dalle <abbr>API</abbr> Spring. Potete compilare questo file senza alcun file <abbr>JAR</abbr> di Spring.

<p>Successivamente, definiamo il &#8220;collegamento&#8221; tra le dipendenze usando un file di configurazione <abbr>XML</abbr> standard di Spring.

<pre><code>&lt;!-- <a href=esempi/cap-14/spring/scala-spring.xml>esempi/cap-14/spring/scala-spring.xml</a> --&gt;

&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

  &lt;bean id="factory" class="example.spring.NamedObjectFactory$"&gt;
    &lt;property name="nameOfFactory" value="Factory per istanze di NamedObject" /&gt;
  &lt;/bean&gt;

  &lt;bean id="factoryUsingBean" class="example.spring.FactoryUsingBean"&gt;
    &lt;constructor-arg ref="factory" /&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</code></pre>

<p>Definiamo due componenti <code>bean</code>. Dotiamo la nostra factory di un idenfiticatore <code>factory</code>. La &#8220;classe&#8221; in realtà è l'<code>object</code> <code>NamedObjectFactory</code>. Notate che dobbiamo aggiungere <code>$</code> in coda al nome, il nome reale dell'oggetto nel bytecode.

<p>Il tag <code>property</code> imposta il valore di <code>nameOfFactory</code>. Non possiamo controllare l'istanziazione degli <code>object</code>, quindi dobbiamo iniettare la dipendenza corretta dopo che il processo di costruzione è terminato.

<p>Il secondo <code>bean</code> è il nostro semplice <code>FactoryUsingBean</code>. Dato che questa è una classe, possiamo usare l'iniezione attraverso il costruttore. Il tag <code>constructor</code> specifica che il componente <code>factory</code> viene usato per soddisfare la dipendenza al momento della costruzione.

<p>Infine, ecco uno script che usa questi tipi per fare una dimostrazione della <abbr>DI</abbr> di Spring in Scala.

<pre><code>// <a href=esempi/cap-14/spring/object-bean-script.scala>esempi/cap-14/spring/object-bean-script.scala</a>

import example.spring._
import org.springframework.context.support._

val context = new ClassPathXmlApplicationContext("spring/scala-spring.xml");

val bean = context.getBean("factoryUsingBean").asInstanceOf[FactoryUsingBean]
println("Nome della factory: " + bean.factory.nameOfFactory)

val obj  = bean.factory.make("Dean Wampler")
println("Oggetto: " + obj)</code></pre>

<p>Creiamo un'istanza di <code>ClassPathXmlApplicationContext</code>, specificando il nostro file <abbr>XML</abbr>. Questo oggetto di contesto è il nostro ingresso nel contenitore <abbr>DI</abbr>. Gli chiediamo la nostra <code>factoryUsingBean</code>. Dobbiamo <span class=wtf>cast</span> l'oggetto <code>AnyRef</code> restituito (cioè, un <code>Object</code> Java) al tipo corretto. Stampiamo il nome della factory, per vedere se è corretto.

<p>Poi, chiediamo alla factory di costruire &#8220;qualcosa&#8221; con la stringa <code>"Dean Wampler"</code>. Quando stampiamo l'oggetto restituito, esso dovrebbe essere un'istanza di <code>NamedObject</code>.

<p>Se avete Spring installato in una directory <code class=var>spring-home</code>, potete eseguire questo script con il comando seguente.

<pre><samp>scala -cp spring-home/dist/spring.jar:spring-home/.../commons-logging.jar:. spring/object-bean-script.scala</samp></pre>

<p>(La directory di lavoro corrente <code>.</code> è necessaria nel percorso di ricerca delle classi per trovare il file <abbr>XML</abbr>.) Ci sono molte righe nella registrazione in uscita. Le ultime due righe sono quelle che ci interessano.

<pre><samp>&hellip;
Nome della factory: Factory per istanze di NamedObject
Oggetto: NamedObject(Dean Wampler)</samp></pre>

<p>Questo esempio ha richiesto un certo numero di file e di dettagli di configurazione per funzionare. Per un'applicazione Java di dimensioni moderatamente ampie, lo sforzo è giustificato. Tuttavia, Scala vi mette a disposizione modi nuovi e più semplici di implementare l'iniezione di dipendenza nel codice Scala senza usare file di configurazione e un contenitore <abbr>DI</abbr>.

<h3 id=TerracottaInterop>Terracotta</h3>
<!-- TODO "instrumented" -> orchestrato? -->
<p>Terracotta <a href=apa.html#Terracotta>[Terracotta]</a> è un prodotto open source di <span class=wtf>clustering</span> che distribuisce un'applicazione su diversi server effettuando il <span class=wtf>clustering</span> delle <abbr>JVM</abbr> su cui l'applicazione viene eseguita. Per ragioni di efficienza, non tutti gli oggetti dell'applicazione mantenuti in memoria vengono distribuiti. Invece, il programmatore specifica quali strutture dati distribuire tramite file di configurazione. Un vantaggio di Terracotta è che l'applicazione non richiede modifiche di codice per supportare questo <span class=wtf>clustering</span> (almeno in linea di principio; alcune personalizzazioni limitate possono essere utili per ragioni di efficienza). Invece, il bytecode viene <span class=wtf>instrumented</span> per fornire il <span class=wtf>clustering</span>. Terracotta rappresenta un'alternativa alle cache distribuite che necessitano di modifiche nel codice dell'applicazione.

<p><a href=apa.html#Boner2008a>[Bonér2008a]</a> offre un resoconto dettagliato di come usare Terracotta con gli attori Scala. &Egrave; necessario installare un modulo di integrazione con Terracotta (<abbr>TIM</abbr>) specifico per Scala. Quando configurate gli oggetti da distribuire, dovete usare i nomi codificati per gli oggetti associati, i nomi dei metodi, <i class=baa>&amp;</i>c. nella forma in cui esistono a livello di bytecode. Abbiamo parlato di queste codifiche nella sezione <a href=#ScalaNamesInJavaCode>I nomi Scala nel codice Java</a> più indietro. Infine, dovete aggiungere alcuni parametri aggiuntivi all'invocazione del comando <kbd>java</kbd> contenuta nello script <kbd>scala</kbd>. Per il resto, il <span class=wtf>clustering</span> di applicazioni Scala con Terracotta funziona esattamente come per le applicazioni Java.

<h3 id=HadoopInterop>Hadoop</h3>

<p><em>MapReduce</em> è un modello di programmazione dividi-e-conquista per elaborare grandi quantità di dati in parallelo. Nella fase di &#8220;mappatura&#8221;, un insieme di dati viene diviso in N sottoinsiemi di dimensioni approssimativamente uguali, dove N viene scelto per ottimizzare la quantità di lavoro che può essere compiuta in parallelo. Per esempio, N potrebbe essere vicino al numero totale di processori disponibili. (Alcuni processori potrebbero essere lasciati inattivi come &#8220;backup&#8221; o per effettuare altre elaborazioni.) La computazione desiderata viene effettuata su ogni sottoinsieme. La fase di &#8220;riduzione&#8221; combina i risultati dei calcoli sui sottoinsiemi in un risultato finale.

<p>Notate che la mappatura e la riduzione sono sostanzialmente operazioni funzionali. Quindi un linguaggio funzionale come Scala è l'ideale per scrivere applicazioni basate sul modello MapReduce.

<p>I framework che implementano il modello MapReduce offrono strumenti per mappare e ridurre insiemi di dati, gestire tutte le fasi della computazione, compresi i nodi di elaborazione, riavviare le operazioni che falliscono per qualche ragione, <i class=baa>&amp;</i>c. L'utente di un framework basato su MapReduce deve solo scrivere gli algoritmi per mappare (suddividere) i dati di ingresso, le computazioni con i sottoinsiemi di dati, e la riduzione dei risultati. Si veda <a href=apa.html#MapReduceTutorial>[MapReduceTutorial]</a> per un'introduzione succinta e <a href=apa.html#MapReduce>[MapReduce]</a> che descrive il framework <em>MapReduce</em> di Google, il cui nome è diventato lo standard <em>de facto</em> per questi framework.

<p>Hadoop <a href=apa.html#Hadoop>[Hadoop]</a> è un framework open source basato sul modello MapReduce creato e mantenuto da Yahoo!. Esistono due <span class=wtf>wrapper</span> Sclaa attorno alla <abbr>API</abbr> di Hadoop: <em>SHadoop</em> <a href=apa.html#SHadoop>[SHadoop]</a> e <em>SMR</em> <a href=apa.html#SMRa>[SMRa]</a> e <a href=apa.html#SMRb>[SMRb]</a>. Entrambi gli esempi dimostrano la grande diminuzione delle dimensioni del codice quando si usa Scala. <a href=apa.html#SMRa>[SMRa]</a> attribuisce questa riduzione al supporto di Scala per le funzioni di ordine superiore e per le funzioni anonime, al suo sofisticato sistema di tipi e all'inferenza di tipo, e alla capacità delle espressioni <code>for</code> di generare mappature in un modo elegante e conciso.

<h2 id=_recap_and_what_s_next_5>Riepilogo, e poi?</h2>

<p>Questo capitolo vi ha fornito informazioni sui dettagli degli strumenti Scala a riga di comando che userete quotidianamente. Abbiamo anche esaminato il supporto per Scala disponibile in vari editor di testo e <abbr>IDE</abbr>. Abbiamo discusso un certo numero di librerie importanti, come le <abbr>API</abbr> di collaudo. Infine, abbiamo discusso l'interoperabilità tra Scala e altri linguaggi e librerie per la <abbr>JVM</abbr>.

<p>Questo completa la nostra rassegna sul mondo della programmazione in Scala. Il prossimo capitolo contiene un glossario di termini che abbiamo usato nel corso del libro, seguito da una lista di riferimenti per ulteriori approfondimenti.

<p class=v><a rel=prev href=cap-13.html title='indietro a &#8220;La progettazione di applicazioni&#8221;'><span class=u>&#x261C;</span></a> <a rel=next href=glossario.html title='avanti a &#8220;Glossario&#8221;'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2008&ndash;9 O&#8217;Reilly Media<br>
&copy; 2009&ndash;10 Giulio Piancastelli per la traduzione italiana
</div>
