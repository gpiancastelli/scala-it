<!DOCTYPE html>
<meta charset=utf-8>
<title>Il sistema di tipi di Scala - Programmare in Scala</title>
<link rel=stylesheet href=styles.css>
<style>
body{counter-reset:h1 12}
</style>

<div id=book>
<p>Voi siete qui: <a href=index.html>Inizio</a> <span class=u>&#8227;</span> <a href=indice.html#cap-12>Programmare in Scala</a> <span class=u>&#8227;</span>

<h1>Il sistema di tipi di Scala</h1>

<p>Scala è un linguaggio staticamente tipato con un sistema di tipi annoverabile tra i più sofisticati, in parte grazie alla combinazione di concetti essenziali provenienti dalla programmazione funzionale e da quella orientata agli oggetti. Il sistema di tipi di Scala cerca di essere logicamente esaustivo, completo e coerente, superando le limitazioni di Java e allo stesso tempo presentando innovazioni mai apparse prima in un linguaggio di programmazione.

<p>Tuttavia, il sistema di tipi può intimidire alla prima occhiata, in particolare chi è abituato a programmare in un linguaggio dinamicamente tipato come Ruby o Python. Per fortuna, l&#8217;inferenza di tipo nasconde la maggior parte della complessità in modo che non sia necessario conoscere i particolari, quindi è possibile usare Scala in maniera efficace anche senza padroneggiare il sistema di tipi. I lettori alla prima esperienza con Scala possono decidere di scorrere rapidamente questo capitolo, in modo da sapere almeno dove guardare nell&#8217;eventualità che in futuro incontrino problemi relativi ai tipi.

<p>In ogni caso, maggiore è la conoscenza del sistema di tipi, maggiori saranno le capacità di sfruttarne le caratteristiche nella scrittura di un programma. Questa considerazione è valida soprattutto per gli sviluppatori di librerie, ai quali tornerà utile sapere quando usare i tipi parametrici anziché i tipi astratti, quali parametri di tipo dovrebbero essere covarianti, controvarianti o invarianti in caso di ereditarietà, e così via. In generale, una certa comprensione del sistema di tipi si rivelerà un aiuto prezioso nel capire e correggere gli occasionali errori di compilazione relativi ai tipi e nel dare un senso alle informazioni di tipo incluse nei sorgenti e nella documentazione <em>Scaladoc</em> delle librerie Scala.

<p>Se ignorate il significato di alcuni dei termini usati nei paragrafi precedenti, non preoccupatevi: li spiegheremo, e spiegheremo perché sono utili. Anziché esaminare nei dettagli il sistema di tipi di Scala ci concentreremo sui suoi aspetti pratici, puntando a farvi acquisire la conoscenza delle caratteristiche disponibili e dello scopo per cui sono state progettate, nonché la capacità di leggere e capire le dichiarazioni di tipo.

<p>Metteremo anche in evidenza le somiglianze con il sistema di tipi di Java, che potrebbe essere un punto di riferimento familiare per buona parte dei lettori, in modo che la comprensione delle differenze tra i due sistemi faciliti l&#8217;interazione con le librerie di quella piattaforma. Circoscriveremo la discussione evitando di parlare del sistema di tipi di .NET, tranne che per mettere in rilievo alcune discrepanze degne di nota che i programmatori .NET vorranno conoscere.

<h2 id=ReflectingOnTypes>La riflessione sui tipi</h2>

<p>Scala supporta le stesse funzionalità di riflessione di Java e .NET, sebbene in alcuni casi la sintassi sia differente.

<p>Prima di tutto, è possibile usare gli stessi metodi a cui si ricorre nei programmi Java o .NET. Lo script seguente mostra alcuni metodi di riflessione disponibili sulla <abbr>JVM</abbr>, appartenenti a <code>java.lang.Object</code> e a <code>java.lang.Class</code>.

<pre><code>// <a href=esempi/cap-12/jvm-script.scala>esempi/cap-12/jvm-script.scala</a>

trait T[A] {
  val vT: A
  def mT = vT
}

class C extends T[String] {
  val vT = "T"
  val vC = "C"
  def mC = vC

  class C2
  trait T2
}

val c = new C
val clazz = c.getClass              // metodo di java.lang.Object
val clazz2 = classOf[C]             // metodo Scala: classOf[C] ~ C.class
val methods = clazz.getMethods      // metodo di java.lang.Class&lt;T&gt;
val ctors = clazz.getConstructors   // ...
val fields = clazz.getFields
val annos = clazz.getAnnotations
val name  = clazz.getName
val parentInterfaces = clazz.getInterfaces
val superClass = clazz.getSuperclass
val typeParams = clazz.getTypeParameters</code></pre>

<p>Si noti che questi metodi sono disponibili solo per i sottotipi di <code>AnyRef</code>.

<p>Il metodo <code>classOf[T]</code> restituisce la rappresentazione di un tipo Scala a tempo di esecuzione, analogamente alla espressione Java <code>T.class</code>. L&#8217;uso di <code>classOf[T]</code> si rivela conveniente quando si desidera estrarre informazioni su un tipo a partire dal tipo stesso, mentre <code>getClass</code> è comodo per recuperare le stesse informazioni da un&#8217;istanza di quel tipo.

<p>Tuttavia <code>classOf[T]</code> e <code>getClass</code> restituiscono valori leggermente differenti, a causa della <em>cancellazione di tipo</em> operata dalla <abbr>JVM</abbr> nel caso di <code>getClass</code>.

<pre><samp>scala&gt; classOf[C]
res0: java.lang.Class[C] = class C

scala&gt; c.getClass
res1: java.lang.Class[_] = class C</samp></pre>

<blockquote class=note>
<p><span class=u>&#x261E;</span>Nonostante .NET supporti i <em>tipi reificati</em> evitando la cancellazione di tipo, attualmente la versione .NET di Scala segue il modello a cancellazione della <abbr>JVM</abbr> allo scopo di scongiurare incompatibilità che richiederebbero la separazione delle implementazioni.
</blockquote>

<p>Valuteremo una soluzione chiamata <em>Manifest</em> per aggirare la cancellazione di tipo dopo aver esaminato i <em>tipi parametrici</em> nella prossima sezione.

<p>Scala fornisce anche metodi per verificare che un oggetto corrisponda a un certo tipo e anche per convertire un oggetto in un certo tipo.

<p><code>x.isInstanceOf[T]</code> restituirà <code>true</code> se l&#8217;istanza <var>x</var> è di tipo <code>T</code>. Tuttavia, questa verifica è soggetta alla cancellazione di tipo: per esempio, <code>List(3.14159).isInstanceOf[List[String]]</code> restituirà <code>true</code> perché il parametro di tipo di <code>List</code> non viene conservato a livello di bytecode; in questo caso, otterrete comunque un messaggio di avvertimento sull&#8217;operazione &#8220;non controllata&#8221; (in inglese, <em>unchecked</em>) da parte del compilatore.

<p><code>x.asInstanceOf[T]</code> convertirà <var>x</var> nel tipo <code>T</code> o lancerà una <code>ClassCastException</code> se <code>T</code> e il tipo di <var>x</var> sono incompatibili. Ancora una volta è necessario considerare la cancellazione di tipo per i tipi parametrici: infatti, la conversione <code>List(3.14159).asInstanceOf[List[String]]</code> avrà successo.

<p>Si noti che queste due operazioni coinvolgono metodi anziché parole chiave del linguaggio, e i loro nomi sono deliberatamente piuttosto prolissi. Di solito, i controlli sui tipi e le conversioni come queste dovrebbero essere evitate: al posto dei primi è possibile usare il pattern matching; per quanto riguarda le seconde, è consigliabile considerare i motivi che le rendono necessarie e determinare se possono essere eliminate tramite una riorganizzazione del codice.

<blockquote class=note>
<p><span class=u>&#x261E;</span>Al momento della scrittura, Scala contiene alcune funzionalità sperimentali nella versione 2.8 del package <code>scala.reflect</code>, progettate per semplificare l&#8217;ispezione e l&#8217;invocazione di codice tramite riflessione rispetto ai metodi Java corrispondenti.
</blockquote>

<h2 id=ParameterizedTypes>Capire i tipi parametrici</h2>

<p>Abbiamo presentato i <em>tipi parametrici</em> e i <em>metodi parametrici</em> nel <a href=cap-1.html>capitolo 1</a> e ne abbiamo fornito una panoramica più approfondita nella sezione <a href=cap-2.html#AbstractTypesAndParameterizedTypes>Tipi astratti e tipi parametrici</a> del capitolo 2. Probabilmente li conoscete già se avete una certa esperienza di programmazione in Java o C#. In questa sezione esploreremo i dettagli del sofisticato supporto offerto da Scala per i tipi parametrici.

<p>I tipi parametrici di Scala sono simili ai generici di Java e C# e ai template del C++. Offrono le stesse funzionalità dei generici Java, ma con alcune importanti differenze ed estensioni che rispecchiano la raffinatezza del sistema di tipi di Scala.

<p>Ricapitolando quanto già visto, una dichiarazione come <code>class List[+A]</code> significa che <code>List</code> è parametrizzato da un singolo tipo, rappresentato da <code>A</code>. Il simbolo <code>+</code> viene chiamato <em>annotazione di varianza</em>. Ne riparleremo nella sezione <a href=#VarianceUnderInheritance>Varianza in caso di ereditarietà</a> più avanti.

<p>Talvolta un <em>tipo parametrico</em> come <code>List</code> è chiamato <em>costruttore di tipo</em> perché viene usato per creare tipi specifici. Per esempio, <code>List</code> è il costruttore di tipo per <code>List[String]</code> e <code>List[Int]</code>, che sono tipi differenti anche se vengono implementati allo stesso modo a causa della <em>cancellazione di tipo</em>. In realtà, è più accurato dire che tutti i tratti e le classi sono costruttori di tipo: quelli senza parametri sono effettivamente tipi parametrici a zero argomenti.

<blockquote class=warning>
<p><span class=u>&#x2762;</span>Nella dichiarazione <code>class StringList[String] extends List[String] {&hellip;}</code>, Scala interpreterà <code>String</code> come il nome del parametro di tipo invece di usarlo per la creazione di un tipo basato su stringhe. Per ottenere questo secondo effetto, basterà scrivere <code>class StringList extends List[String] {&hellip;}</code>.
</blockquote>

<h3 id=Manifests>Manifesti</h3>

<p>A partire dalla versione 2.7.2, Scala è dotato di una funzione sperimentale chiamata <em>Manifest</em> che cattura le informazioni di tipo cancellate nel bytecode. Questa funzione non è documentata nelle pagine <em>Scaladoc</em>, ma potete esaminare il codice sorgente del tratto <code>scala.reflect.Manifest</code> per saperne di più. <a href=apa.html#Ortiz2008>[Ortiz2008]</a> analizza i manifesti e ne offre alcuni esempi d&#8217;uso.

<p>Un <code>Manifest</code> va dichiarato come un argomento implicito di un metodo o di un tipo di cui si vogliono catturare le informazioni di tipo cancellate. A differenza della maggior parte degli argomenti impliciti, l&#8217;utente non ha bisogno di implementare un valore o un metodo <code>Manifest</code> che sia visibile nell&#8217;ambito in cui viene usato, perché il compilatore ne genera uno automaticamente. Ecco un esempio che illustra alcuni punti di forza e di debolezza dei manifesti.

<pre><code>// <a href=esempi/cap-12/manifest-script.scala>esempi/cap-12/manifest-script.scala</a>

import scala.reflect.Manifest

object WhichList {
  def apply[B](value: List[B])(implicit m: Manifest[B]) = m.toString match {
    case "int"              =&gt; println("List[Int]")
    case "double"           =&gt; println("List[Double]")
    case "java.lang.String" =&gt; println("List[String]")
    case _                  =&gt; println("List[???]")
  }
}

WhichList(List(1, 2, 3))
WhichList(List(1.1, 2.2, 3.3))
WhichList(List("uno", "due", "tre"))

List(List(1, 2, 3), List(1.1, 2.2, 3.3), List("uno", "due", "tre")) foreach {
  WhichList(_)
}</code></pre>

<p><code>WhichList</code> cerca di determinare il tipo della lista passata come argomento sfruttando il valore restituito dal metodo <code>toString</code> del manifesto. Si noti che questo uso del manifesto funziona quando la lista viene costruita all&#8217;interno della invocazione di <code>WhichList.apply</code>, ma <em>non</em> funziona quando quel metodo riceve una lista precedentemente costruita. Nel primo caso, il compilatore sfrutta le informazioni di tipo che conosce per costruire il <code>Manifest</code> implicito con il tipo <code>B</code> corretto. Tuttavia, quando il metodo <code>WhichList</code> riceve liste precostruite, le informazioni di tipo cruciali sono già andate perse.

<p>Perciò, i manifesti non possono &#8220;riesumare&#8221; le informazioni di tipo dal bytecode, ma possono essere usati per catturare e sfruttare le informazioni di tipo prima che vengano cancellate.

<h3 id=ParameterizedMethods>Metodi parametrici</h3>

<p>Anche i singoli metodi possono essere parametrici. Un buon esempio di metodo parametrico è il metodo <code>apply</code> degli oggetti associati a classi parametriche. Se ricordate, gli oggetti associati sono oggetti singleton con una classe associata. Esiste una sola istanza di un oggetto singleton, come indica il nome, quindi i parametri sul tipo non avrebbero senso.

<p>Consideriamo <code>object List</code>, l&#8217;oggetto associato a <code>class List[+A]</code>. Ecco la definizione del metodo <code>apply</code> di <code>object List</code>.

<pre><code>def apply[A](xs: A*): List[A] = xs.toList</code></pre>

<p>Il metodo <code>apply</code> accetta una lista a lunghezza variabile di argomenti di tipo <code>A</code> (inferito a partire dagli argomenti stessi) e restituisce una lista che contiene gli oggetti passati. Ecco un esempio.

<pre><code>val languages = List("Scala", "Java", "Ruby", "C#", "C++", "Python", &hellip;)
val positiveInts = List(1, 2, 3, 4, 5, 6, 7, &hellip;)</code></pre>

<p>Esamineremo altri metodi parametrici più avanti.

<h2 id=VarianceUnderInheritance>Varianza in caso di ereditarietà</h2>

<p>Una differenza importante tra i generici Java e Scala è il modo in cui funziona la <em>varianza</em> in caso di ereditarietà, che determina, per esempio, se è possibile passare un argomento di tipo <code>List[String]</code> a un metodo che ha un parametro di tipo <code>List[AnyRef]</code>, cioè se, in altre parole, <code>List[String]</code> deve essere considerato un <em>sottotipo</em> di <code>List[AnyRef]</code>. In caso affermativo, questo tipo di varianza viene chiamata <em>covarianza</em>, perché la relazione tra supertipo e sottotipo del contenitore (il tipo parametrico) &#8220;va nella stessa direzione&#8221; della relazione tra i parametri di tipo. In altri contesti, può essere desiderabile un comportamento <em>controvariante</em> o <em>invariante</em>, che descriveremo tra breve.

<p>In Scala, il comportamento della varianza viene definito nel <em>punto di dichiarazione</em> usando le <em>annotazioni di varianza</em> <code>+</code> e <code>-</code>, oppure nessuna annotazione. Questo significa che è il progettista del tipo a decidere come deve variare il tipo in caso di ereditarietà.

<p>Esaminiamo i tre tipi di varianza, riassunti nella tabella seguente, e cerchiamo di capire come usarli in maniera efficace. Supporremo che <code>T<sup>sup</sup></code> sia un <em>supertipo</em> di <code>T</code> e che <code>T<sub>sub</sub></code> sia un <em>sottotipo</em> di <code>T</code>.

<div class=table id=type-variance-annotations-table>
<p class=tt>Tabella 12.1. Annotazioni di varianza di tipo e loro significato.
<table summary="Annotazioni di varianza di tipo e loro significato." border=0>
<colgroup>
<col align=left>
<col align=left>
<col align=left>
</colgroup>
<thead valign=top><tr>
<th align=left valign=top>Annotazione
<th align=left valign=top>Equivalente Java
<th align=left valign=top>Descrizione
</thead>
<tbody valign=top>
<tr>
<td align=left valign=top><p><code>+</code>
<td align=left valign=top><p><code>? extends T</code>
<td align=left valign=top><p>Estensione <em>covariante</em>. Per esempio, <code>List[T<sub>sub</sub>]</code> è un sottotipo di <code>List[T]</code>.
<tr>
<td align=left valign=top><p><code>-</code>
<td align=left valign=top><p><code>? super T</code>
<td align=left valign=top><p>Estensione <em>controvariante</em>. Per esempio, <code>X[T<sup>sup</sup>]</code> è un sottotipo di <code>X[T]</code>.
<tr>
<td align=left valign=top><p><em>nessuna</em>
<td align=left valign=top><p><code>T</code>
<td align=left valign=top><p>Estensione <em>invariante</em>. Per esempio, non è possibile sostituire <code>Y[T<sup>sup</sup>]</code> o <code>Y[T<sub>sub</sub>]</code> al posto di <code>Y[T]</code>.
</tbody>
</table>
</div>

<p>La colonna &#8220;Equivalente Java&#8221; è leggermente fuorviante; spiegheremo il perché più avanti, approfondendo il confronto tra Java e Scala.

<p>La classe <code>List</code> è dichiarata come <code>List[+A]</code>, indicando che <code>List[String]</code> è una sottoclasse di <code>List[AnyRef]</code> e quindi che le liste sono covarianti nel parametro di tipo <code>A</code>. Quando un tipo come <code>List</code> ha un solo parametro di tipo covariante, si sente spesso usare l&#8217;espressione abbreviata &#8220;le liste sono covarianti&#8221;, così come per i tipi con un singolo parametro di tipo controvariante.

<p>I tratti <code>FunctionN</code> per <code>N</code> che va da <code>0</code> a <code>22</code> vengono usati da Scala per implementare i valori funzione come veri oggetti. Consideriamo <code>Function1</code> come esempio rappresentativo: è dichiarato come <code>trait Function1[-T, +R]</code>.

<p><code>+R</code> è il tipo di ritorno e presenta l&#8217;annotazione covariante <code>+</code>. Il tipo del singolo argomento presenta l&#8217;annotazione <em>controvariante</em> <code>-</code>. Per le funzioni con più di un argomento, tutti i tipi degli argomenti presentano l&#8217;annotazione controvariante. Quindi, per esempio, usando i nostri tipi <code>T</code>, <code>T<sup>sup</sup></code> e <code>T<sub>sub</sub></code>, la definizione seguente sarebbe legale.

<p><code>val f: Function1[T, T] = new Function1[T<sup>sup</sup>, T<sub>sub</sub>] { &hellip; }</code>

<p>Perciò, i tratti funzione sono covarianti nel parametro del tipo di ritorno <code>R</code> e controvarianti nei parametri degli argomenti <code>T<sub>1</sub></code>, <code>T<sub>2</sub></code>, &hellip;, <code>T<sub>N</sub></code>.

<p>Per capire il reale comportamento della varianza, esaminiamo un esempio completo. Se avete già esperienza nella <em>progettazione per contratto</em> <a href=apa.html#DesignByContract>[DesignByContract]</a>, di cui parleremo brevemente nella sezione <a href=cap-13.html#DesignByContractExample>Una progettazione migliore con la progettazione per contratto</a> del capitolo 13, potrebbe esservi d&#8217;aiuto ricordarne i principi di funzionamento, che sono molto simili a quelli su cui si basa il meccanismo della varianza. Questo script illustra il comportamento della varianza in caso di ereditarietà.

<pre><code>// <a href=esempi/cap-12/func-script.scala>esempi/cap-12/func-script.scala</a>
// Non verrà compilato!

class CSuper                { def msuper = println("CSuper") }
class C      extends CSuper { def m      = println("C") }
class CSub   extends C      { def msub   = println("CSub") }

var f: C =&gt; C = (c: C)      =&gt; new C       // #1
    f         = (c: CSuper) =&gt; new CSub    // #2
    f         = (c: CSuper) =&gt; new C       // #3
    f         = (c: C)      =&gt; new CSub    // #4
    f         = (c: CSub)   =&gt; new CSuper  // #5: ERRORE!</code></pre>

<p>Lo script non produce alcuna uscita: se provate a eseguirlo, genererà un errore di compilazione relativo all&#8217;ultima riga.

<p>Cominciamo definendo una gerarchia molto semplice di tre classi: <code>C</code>, la sua superclasse <code>CSuper</code> e il suo sottotipo <code>CSub</code>. Ognuna di esse definisce un metodo, che sfrutteremo tra breve.

<p>Successivamente definiamo una variabile chiamata <var>f</var> sulla riga con il commento <code>#1</code>: è una funzione con la firma <code>C =&gt; C</code>, o più precisamente, è di tipo <code>Function1(-C,+C)</code>. Per essere chiari, il valore assegnato a <code>f</code> si trova dopo il segno di uguale: <code>(c: C) =&gt; new C</code>, nel cui corpo ignoriamo il valore <code>c</code> in ingresso e ci limitiamo a creare una nuova istanza di <code>C</code>.

<p>Ora assegniamo differenti valori funzione anonimi a <code>f</code>, usando gli spazi per sottolineare le somiglianze e le differenze nel confrontare la dichiarazione originale di <code>f</code> e i riassegnamenti successivi. Stiamo continuando a riassegnare valori a <code>f</code> perché desideriamo semplicemente verificare cosa verrà o non verrà compilato a questo punto. In particolare, desideriamo sapere quali valori funzione possiamo assegnare legalmente a <code>f: (C) =&gt; C</code>.

<p>L&#8217;assegnamento sulla riga con il commento <code>#2</code> usa <code>(x:CSuper) =&gt; new CSub</code> come valore funzione. Anche questo è accettabile, perché l&#8217;argomento di <code>Function1</code> è <em>controvariante</em>, quindi possiamo sostituirlo con il <em>supertipo</em>, mentre il tipo di ritorno di <code>Function1</code> è <em>covariante</em>, quindi il nostro valore funzione può restituire un&#8217;istanza del <em>sottotipo</em>.

<p>Anche gli assegnamenti nelle due righe successive sono validi. Sulla terza riga, usiamo <code>CSuper</code> come argomento, che viene accettato come è accaduto nella seconda riga, e restituiamo un&#8217;istanza di <code>C</code>, che non crea problemi, proprio come ci aspettiamo. Similmente, sulla quarta riga usiamo <code>C</code> come argomento e <code>CSub</code> come tipo di ritorno, entrambi già convalidati dal loro impiego nelle righe precedenti.

<p>L&#8217;ultima riga, con il commento <code>#5</code>, non viene compilata perché stiamo tentando di usare un argomento covariante in una posizione controvariante, e stiamo anche tentando di usare un valore di ritorno controvariante dove sono permessi solo valori covarianti.

<p>Per capire qual è il comportamento corretto in questo caso, possiamo ricorrere a un ragionamento in termini di <em>progettazione per contratto</em>. Analizziamo il modo in cui un cliente potrebbe usare alcune di queste definizioni di <code>f</code>.

<pre><code>// <a href=esempi/cap-12/func2-script.scala>esempi/cap-12/func2-script.scala</a>
// Non verrà compilato!

class CSuper                { def msuper = println("CSuper") }
class C      extends CSuper { def m      = println("C") }
class CSub   extends C      { def msub   = println("CSub") }

def useF(f: C =&gt; C) = {
  val c1 = new C     // #1
  val c2: C = f(c1)  // #2
  c2.msuper          // #3
  c2.m               // #4
}

useF((c: C)      =&gt; new C)        // #5
useF((c: CSuper) =&gt; new CSub)     // #6
useF((c: CSub)   =&gt; {println(c.msub); new CSuper})   // #7: ERRORE!</code></pre>

<p>Il metodo <code>useF</code> accetta una funzione <code>C =&gt; C</code> come argomento; ora stiamo semplicemente passando letterali funzione anziché assegnarli a <code>f</code>. Il metodo crea un&#8217;istanza di <code>C</code> (riga con il commento <code>#1</code>) e la passa alla funzione in ingresso per creare una nuova istanza di <code>C</code> (riga <code>#2</code>) su cui poi usa le operazioni di <code>C</code>, invocando i metodi <code>msuper</code> e <code>m</code> (righe con i commenti <code>#3</code> e <code>#4</code>, rispettivamente).

<p>Si potrebbe dire che il metodo <code>useF</code> specifica un <em>contratto</em> di comportamento: si aspetta che gli venga passata una funzione capace di accettare un&#8217;istanza di <code>C</code> come argomento e di restituire un&#8217;altra istanza di <code>C</code>. Perciò, il metodo invocherà la funzione che gli viene passata, passandole un&#8217;istanza di <code>C</code>, e si aspetterà di ricevere come valore di ritorno un&#8217;istanza di <code>C</code>.

<p>Sulla riga con il commento <code>#5</code>, a <code>useF</code> viene passata una funzione che accetta un&#8217;istanza di <code>C</code> e restituisce un&#8217;istanza di <code>C</code>. L&#8217;istanza di <code>C</code> restituita non avrà problemi a funzionare con le righe <code>#3</code> e <code>#4</code>, per definizione. Non ci sono intoppi.

<p>Infine, arriviamo al punto cruciale di questo esempio. Sulla riga <code>#6</code> viene passata una funzione che è &#8220;disposta&#8221; ad accettare un&#8217;istanza di <code>CSuper</code> e &#8220;promette&#8221; di restituire un&#8217;istanza di <code>CSub</code>, in altre parole una funzione il cui tipo inferito è <code>Function1[CSuper,CSub]</code>. In effetti, questa funzione allarga il ventaglio delle istanze permesse accettando un supertipo. Si noti che <code>useF</code> non le passerà mai un&#8217;istanza di <code>CSuper</code>, ma solo un&#8217;istanza di <code>C</code>; tuttavia, dato che la funzione accetta un insieme più ampio di valori, opera altrettanto bene anche se le vengono passate solo istanze di <code>C</code>.

<p>Similmente, &#8220;promettendo&#8221; di restituire un&#8217;istanza di <code>CSub</code>, questa funzione anonima restringe i valori possibili restituiti a <code>useF</code>. Ma anche questo è un comportamento ancora valido, perché <code>useF</code> accetterà qualsiasi istanza di <code>C</code> come valore di ritorno e il suo contratto sarà soddisfatto pure ottenendo solo un&#8217;istanza di <code>CSub</code>. Le righe <code>#3</code> e <code>#4</code> continueranno a fare il loro dovere.

<p>Seguendo la stessa linea di ragionamento, è possibile capire perché l&#8217;ultima riga dello script, indicata dal commento <code>#7</code>, genera un errore di compilazione. Ora la funzione anonima può solo accettare un&#8217;istanza di <code>CSub</code>, ma <code>useF</code> le passerà un&#8217;istanza di <code>C</code>: il corpo della funzione anonima invocherebbe il metodo <code>c.msub</code> che non esiste in <code>C</code>. Similmente, la restituzione di un&#8217;istanza di <code>CSuper</code> al posto di un&#8217;istanza di <code>C</code> provocherebbe un problema nella riga <code>#4</code> in <code>useF</code>, perché <code>CSuper</code> non dispone del metodo <code>m</code>.

<p>Argomentazioni identiche a queste vengono usate per spiegare come i contratti possono cambiare in caso di ereditarietà nella <em>progettazione per contratto</em>.

<p>Si noti che le annotazioni di varianza hanno senso solamente sui parametri di tipo per i tipi parametrici ma non per i metodi parametrici, perché le annotazioni influenzano il comportamento dei sottotipi e i metodi non possono essere estesi, a differenza dei tipi che li contengono.

<blockquote class=note>
<p><span class=u>&#x261E;</span>L&#8217;annotazione di varianza <code>+</code> significa che il tipo parametrico è <em>covariante</em> nel parametro di tipo. L&#8217;annotazione di varianza <code>-</code> significa che il tipo parametrico è <em>controvariante</em> nel parametro di tipo. L&#8217;assenza di qualsiasi annotazione di varianza significa che il tipo parametrico è <em>invariante</em> nel parametro di tipo.
</blockquote>

<p>Infine, il compilatore controlla l&#8217;uso effettuato delle annotazioni di varianza per evitare problemi come quello che abbiamo appena descritto nelle ultime righe degli esempi. Supponete di provare a definire un vostro tipo funzione in questo modo.

<pre><code>trait MyFunction2[+T1, +T2, -R] {
  def apply(v1:T1, v2:T2): R = { &hellip; }
  &hellip;
}</code></pre>

<p>Il compilatore lancerà i seguenti errori per quanto riguarda il metodo <code>apply</code>.

<pre><samp>&hellip; error: contravariant type R occurs in covariant position in type (T1,T2)R
     def apply(v1:T1, v2:T2):R
         ^
&hellip; error: covariant type T1 occurs in contravariant position in type T1 &hellip;
     def apply(v1:T1, v2:T2):R
               ^
&hellip; error: covariant type T2 occurs in contravariant position in type T2 &hellip;
     def apply(v1:T1, v2:T2):R
                      ^</samp></pre>

<h3 id=VarianceOfMutableTypes>La varianza dei tipi mutabili</h3>

<p>Tutti i tipi parametrici visti finora sono tipi immutabili. Per quanto riguarda la varianza dei tipi mutabili, possiamo dire che è permesso solo il comportamento <em>invariante</em>. Considerate questo esempio.

<pre><code>// <a href=esempi/cap-12/mutable-type-variance-script.scala>esempi/cap-12/mutable-type-variance-script.scala</a>
// Non verrà compilato!
// I tipi parametrici mutabili non possono avere annotazioni di varianza

class ContainerPlus[+A](var value: A)      // ERRORE
class ContainerMinus[-A](var value: A)     // ERRORE

println(new ContainerPlus("Ciao mondo!"))
println(new ContainerMinus("Ciao mondo!"))</code></pre>

<p>L&#8217;esecuzione di questo script provoca i seguenti errori.

<pre><samp>&hellip; 4: error: covariant type A occurs in contravariant position in type A of parameter of setter value_=
class ContainerPlus[+A](var value: A)      // ERRORE
                             ^
&hellip; 5: error: contravariant type A occurs in covariant position in type =&gt; A of method value
class ContainerMinus[-A](var value: A)     // ERRORE
                              ^
two errors found</samp></pre>

<p>Questi errori si possono comprendere ricordando la discussione sulla varianza di tipo in caso di ereditarietà per i tratti <code>FunctionN</code>, dove i tipi degli argomenti della funzione sono <em>controvarianti</em> (cioè, <code>-T1</code>) e il tipo del valore di ritorno è <em>covariante</em> (cioè, <code>+R</code>).

<p>Il problema con un tipo mutabile è che almeno uno dei suoi campi è dotato dell&#8217;equivalente delle operazioni di lettura <em>e</em> scrittura, tramite l&#8217;accesso diretto o attraverso metodi per impostare e restituire il valore.

<p>Il primo errore è dovuto al tentativo di usare un tipo covariante come argomento di un metodo di scrittura, ma dalla discussione sui tipi funzione si è visto che i tipi degli argomenti di un metodo devono essere controvarianti. Un tipo covariante può essere utilizzato per un metodo di lettura.

<p>Similmente, il secondo errore è dovuto al tentativo di usare un tipo controvariante come tipo di ritorno per un metodo di lettura, che deve essere covariante. Un tipo controvariante può essere utilizzato per un metodo di scrittura.

<p>Perciò, il compilatore non ci permetterà di usare un&#8217;annotazione di varianza su un tipo usato per un campo mutabile. Per questo motivo, tutti i tipi parametrici mutabili nella libreria Scala sono <em>invarianti</em> nei loro parametri di tipo. Alcuni hanno un tipo immutabile corrispondente che possiede parametri covarianti o controvarianti.

<h3 id=VarianceInScalaVsJava>Un confronto tra la varianza in Scala e in Java</h3>

<p>Come è già stato detto, in Scala il comportamento di varianza è definito nel <em>punto di dichiarazione</em>. In Java, al contrario, è definito nel <em>punto di invocazione</em>: è il <em>cliente</em> di un tipo a definire il comportamento di varianza desiderato <a href=apa.html#Naftalin2006>[Naftalin2006]</a>. In altre parole, quando si usa un tipo generico Java e si specifica il parametro di tipo, si indica anche il comportamento di varianza (compresa l&#8217;invarianza, che è il comportamento predefinito). Non è possibile specificare il comportamento di varianza nel punto della dichiarazione in Java, sebbene sia consentito usare espressioni simili, che però definiscono i <em>limiti del tipo</em>, come vedremo più avanti.

<p>Nelle specifiche di varianza in Java, compare sempre una wildcard <code>?</code> prima delle parole chiave <code>super</code> o <code>extend</code>, come mostrato nella tabella precedente. Quando abbiamo affermato, dopo la tabella, che la colonna &#8220;Equivalente Java&#8221; era leggermente fuorviante, ci stavamo riferendo alla differenza tra le specifiche nel punto di dichiarazione o nel punto di invocazione. Esiste un&#8217;ulteriore differenza tra il comportamento di Scala e quello di Java che illustreremo più avanti nella sezione <a href=#ExistentialTypes>Tipi esistenziali</a>.

<p>Le specifiche di varianza nel punto di invocazione hanno lo svantaggio di obbligare chi usa i generici Java a una comprensione più completa del sistema di tipi rispetto a quanto è necessario per chi usa i tipi parametrici di Scala, che non ha bisogno di indicare questo comportamento nei punti in cui li impiega. I programmatori Scala vengono anche grandemente avvantaggiati dall&#8217;inferenza di tipo.

<p>Esaminiamo un esempio Java di una versione semplificata dei tipi Scala <code>Option</code>, <code>Some</code> e <code>None</code>.

<pre><code>// <a href=esempi/cap-12/variances/Option.java>esempi/cap-12/variances/Option.java</a>

package variances;

abstract public class Option&lt;T&gt; {
  abstract public boolean isEmpty();

  abstract public T get();

  public T getOrElse(T t) {
    return isEmpty() ? t : get();
  }
}</code></pre>

<pre><code>// <a href=esempi/cap-12/variances/Some.java>esempi/cap-12/variances/Some.java</a>

package variances;

public class Some&lt;T&gt; extends Option&lt;T&gt; {

  public Some(T value) {
    this.value = value;
  }

  public boolean isEmpty() { return false; }

  private T value;

  public T get() { return value; }

  public String toString() {
    return "Option(" + value + ")";
  }
}</code></pre>

<pre><code>// <a href=esempi/cap-12/variances/None.java>esempi/cap-12/variances/None.java</a>

package variances;

public class None&lt;T&gt; extends Option&lt;T&gt; {

  public boolean isEmpty() { return true; }

  public T get() { throw new java.util.NoSuchElementException(); }

  public String toString() {
    return "None";
  }
}</code></pre>

<p>Ecco un breve programma che usa questa gerarchia di <code>Option</code> in Java.

<pre><code>// <a href=esempi/cap-12/variances/OptionExample.java>esempi/cap-12/variances/OptionExample.java</a>

package variances;
import java.io.*;
import shapes.*;  // Dal capitolo "Una introduzione a Scala"

public class OptionExample {
  static String[] shapeNames = {"Rettangolo", "Cerchio", "Triangolo", "Sconosciuto"};
  static public void main(String[] args) {

    Option&lt;? extends Shape&gt; shapeOption =
      makeShape(shapeNames[0], new Point(0.,0.), 2., 5.);
    print(shapeNames[0], shapeOption);

    shapeOption = makeShape(shapeNames[1], new Point(0.,0.), 2.);
    print(shapeNames[1], shapeOption);

    shapeOption = makeShape(shapeNames[2],
      new Point(0.,0.), new Point(2.,0.), new Point(0.,2.));
    print(shapeNames[2], shapeOption);

    shapeOption = makeShape(shapeNames[3]);
    print(shapeNames[3], shapeOption);
  }

  static public Option&lt;? extends Shape&gt; makeShape(String shapeName,
      Object... args) {
    if (shapeName == shapeNames[0])
      return new Some&lt;Rectangle&gt;(new Rectangle((Point) args[0],
        (Double) args[1], (Double) args[2]));
    else if (shapeName == shapeNames[1])
      return new Some&lt;Circle&gt;(new Circle((Point) args[0], (Double) args[1]));
    else if (shapeName == shapeNames[2])
      return new Some&lt;Triangle&gt;(new Triangle((Point) args[0],
        (Point) args[1], (Point) args[2]));
    else
      return new None&lt;Shape&gt;();
  }

  static void print(String name, Option&lt;? extends Shape&gt; shapeOption) {
    System.out.println(name + "? " + shapeOption);
  }
}</code></pre>

<p>Il metodo <code>OptionExample.main</code> usa la gerarchia di forme geometriche introdotta nel <a href=cap-1.html>capitolo 1</a> e che qui di seguito abbiamo aggiornato per sfruttare nuove funzionalità imparate nel corso del libro, come le classi <code>case</code>.

<pre><code>// <a href=esempi/cap-12/shapes.scala>esempi/cap-12/shapes.scala</a>

package shapes {
  case class Point(x: Double, y: Double) {
    override def toString() = "Point(" + x + "," + y + ")"
  }

  abstract class Shape() {
    def draw(): Unit
  }

  case class Circle(center: Point, radius: Double) extends Shape {
    def draw() = println("Circle.draw: " + this)
  }

  case class Rectangle(lowerLeft: Point, height: Double, width: Double)
        extends Shape {
    def draw() = println("Rectangle.draw: " + this)
  }

  case class Triangle(point1: Point, point2: Point, point3: Point)
        extends Shape() {
    def draw() = println("Triangle.draw: " + this)
  }
}</code></pre>

<p>L&#8217;esecuzione di <code>OptionExample</code> tramite il comando <kbd>scala -cp &hellip; variances.OptionExample</kbd> produce il risultato seguente.

<pre><samp>Rettangolo? Option(Rectangle(Point(0.0,0.0),2.0,5.0))
Cerchio? Option(Circle(Point(0.0,0.0),2.0))
Triangolo? Option(Triangle(Point(0.0,0.0),Point(2.0,0.0),Point(0.0,2.0)))
Sconosciuto? None</samp></pre>

<p>Tra le altre cose, questo esempio illustra anche l&#8217;interoperabilità tra Scala e Java, di cui riparleremo nella sezione <a href=cap-14.html#JavaInterop>Interoperabilità con Java</a> del capitolo 14.

<p><code>OptionExample.main</code> invoca il metodo factory statico <code>makeShape</code>, i cui argomenti sono il nome di una forma geometrica e una lista a lunghezza variabile di parametri da passare ai costruttori di <code>Shape</code>.

<p>Si noti che <code>makeShape</code> restituisce <code>Option&lt;? extends Shape&gt;</code> e che, quando <code>Shape</code> viene istanziata, <code>makeShape</code> restituisce un&#8217;istanza di <code>Some</code> parametrizzata con il sottotipo di <code>Shape</code> che racchiude. Se il metodo factory riceve un nome di forma geometrica sconosciuto, allora restituisce un&#8217;istanza di <code>None&lt;Shape&gt;</code>. Qui è necessario parametrizzare un&#8217;istanza di <code>None</code> con <code>Shape</code>, laddove Scala, che definisce un sottotipo di <em>tutti</em> i tipi, chiamato <code>Nothing</code>, può permettersi di definire <code>None</code> come <code>case object None extends Option[Nothing]</code>.

<p>Il sistema di tipi di Java non offre alcun idioma per implementare l&#8217;equivalente di <code>None</code> in modo simile. La possibilità di definire <code>None</code> come oggetto singleton ha un certo numero di vantaggi, compresa una maggior efficienza, perché evita la creazione di una moltitudine di piccoli oggetti, e un comportamento non ambiguo di <code>equals</code>, perché rende superfluo definire la semantica di uguaglianza tra diverse istanziazioni del tipo Java <code>None&lt;?&gt;</code>, per esempio per confrontare <code>None&lt;String&gt;</code> e <code>None&lt;Shape&gt;</code>.

<p>Infine, si noti che <code>OptionExample</code>, in quanto cliente di <code>Option</code>, deve specificare la varianza di tipo <code>Option&lt;? extends Shape&gt;</code> in diversi punti. In Scala, invece, il cliente non deve assumersi questo onere.

<h3 id=ImplementationNotes>Note di implementazione</h3>

<p>L&#8217;implementazione dei tipi e dei metodi parametrici merita alcune considerazioni. Le diverse implementazioni sono generate quando il file sorgente che contiene le definizioni viene compilato. Per ogni parametro di tipo, l&#8217;implementazione presume che possano essere specificati i sottotipi di <code>Any</code> (nei generici Java viene usato <code>Object</code>). Questi aspetti hanno implicazioni sulle prestazioni di cui riparleremo esaminando l&#8217;annotazione <code>@specialized</code> nella sezione <a href=cap-13.html#Annotations>Annotazioni</a> del capitolo 13.

<h2 id=TypeBounds>Limiti sui tipi</h2>

<p>Quando si definisce un tipo o un metodo parametrico potrebbe essere necessario specificare i <em>limiti</em> sul tipo. Per esempio, un tipo parametrico potrebbe richiedere che un particolare parametro di tipo contenga certi metodi.

<h3 id=UpperTypeBounds>Limiti superiori sui tipi</h3>

<p>Considerate i metodi <code>apply</code> sovraccaricati di <code>object.scala.Array</code> usati per creare nuovi array. Ne esistono implementazioni ottimizzate per ogni tipo derivato da <code>AnyVal</code>, ma esiste un&#8217;altra implementazione di <code>apply</code> parametrizzata per qualsiasi sottotipo di <code>AnyRef</code>. Ecco come si presenta questa implementazione in Scala 2.7.5.

<pre><code>object Array {
  &hellip;
  def apply[A &lt;: AnyRef](xs: A*): Array[A] = {
    val array = new Array[A](xs.length)
    var i = 0
    for (x &lt;- xs.elements) { array(i) = x; i += 1 }
    array
  }
  &hellip;
}</code></pre>

<p>Il parametro di tipo <code>A &lt;: AnyRef</code> significa &#8220;qualsiasi tipo <code>A</code> che sia un <em>sottotipo</em> di <code>AnyRef</code>&#8221;. Si noti che un tipo è sempre sottotipo e supertipo di se stesso, quindi <code>A</code> potrebbe anche essere uguale ad <code>AnyRef</code>. L&#8217;operatore <code>&lt;:</code> indica che il tipo alla sua sinistra deve essere derivato dal tipo alla sua destra, o che i due tipi devono essere uguali. Come abbiamo detto nella sezione <a href=cap-2.html#ReservedWords>Parole riservate</a> del capitolo 2, in realtà questo operatore è una parola riservata del linguaggio.

<p>Questi limiti sono chiamati <em>limiti superiori sul tipo</em>, seguendo la convenzione <em>de facto</em> per cui i diagrammi delle gerarchie di tipi collocano i sottotipi al di sotto dei loro supertipi. Abbiamo seguito questa convenzione nel diagramma mostrato nella sezione <a href=cap-7.html#ScalaTypeHierarchy>La gerarchia di tipi di Scala</a> del capitolo 7.

<p>In questo caso, se il limite non fosse presente, cioè se la firma fosse <code>def apply[A](xs: A*): Array[A]</code>, la dichiarazione risulterebbe ambigua rispetto agli altri metodi <code>apply</code> definiti per ognuno dei sottotipi di <code>AnyVal</code>.

<blockquote class=note>
<p><span class=u>&#x261E;</span>La firma di tipo <code>A &lt;: B</code> significa che <code>A</code> deve essere un <em>sottotipo</em> di <code>B</code>. In Java, questa condizione si esprimerebbe come <code>A extends B</code> in una dichiarazione di tipo. Al contrario, per <em>istanziare</em> un tipo nel punto di invocazione la sintassi usata in Java sarebbe <code>? extends B</code> e indicherebbe il comportamento della <em>varianza</em>.
</blockquote>

<p>&Egrave; importante tenere a mente la distinzione tra varianza di tipo e limiti sul tipo. Per un tipo come <code>List</code>, il comportamento della varianza descrive il modo in cui i tipi reali istanziati dal tipo parametrico, come <code>List[AnyRef]</code> e <code>List[String]</code>, sono in relazione tra loro. In questo caso, <code>List[String]</code> è un sottotipo di <code>List[AnyRef]</code>, dato che <code>String</code> è un sottotipo di <code>AnyRef</code>.

<p>Al contrario, i limiti superiore e inferiore di un tipo restringono i tipi permessi che possono essere usati come parametro di tipo quando si istanzia un tipo a partire da un tipo parametrico. Per esempio, <code>def apply[A &lt;: AnyRef]&hellip;</code> indica che qualsiasi tipo usato per <code>A</code> deve essere un sottotipo di <code>AnyRef</code>.

<h3 id=LowerTypeBounds>Limiti inferiori sui tipi</h3>

<p>Similmente, esistono circostanze in cui si desidera esprimere che solo i <em>supertipi</em> di un tipo particolare sono ammessi, senza dimenticare che un tipo è anche supertipo di se stesso. Chiamiamo questi <em>limiti inferiori sul tipo</em>, sempre a causa della disposizione grafica in un tipico diagramma di gerarchia di tipi, in questo caso perché il tipo permesso si troverebbe al di sopra del suo limite.

<p>Un esempio particolarmente interessante è il metodo <code>::</code> (chiamato &#8220;cons&#8221;) della classe <code>List[+A]</code>. Se ricordate, questo operatore viene usato per creare una nuova lista aggiungendo un elemento in testa a una lista già esistente.

<pre><code>class List[+A] {
  &hellip;
  def ::[B &gt;: A](x : B) : List[B] = new scala.::(x, this)
  &hellip;
}</code></pre>

<p>La nuova lista sarà di tipo <code>List[B]</code>, nello specifico <code>scala.::</code>. La <em>classe</em> <code>::</code> (distinta dal <em>metodo</em> <code>::</code>) deriva da <code>List</code>. Ne riparleremo tra breve.

<p>Il metodo <code>::</code> può aggiungere in testa a una lista un oggetto di tipo diverso dal tipo <code>A</code> degli elementi contenuti nella lista originale. Il compilatore inferirà il supertipo comune più vicino di <code>A</code> e del parametro <code>x</code> e lo userà come valore di <code>B</code>. Ecco un esempio che aggiunge in testa a una lista di oggetti di un certo tipo un oggetto di tipo diverso.

<pre><code>// <a href=esempi/cap-12/list-ab-script.scala>esempi/cap-12/list-ab-script.scala</a>

val languages = List("Scala", "Java", "Ruby", "C#", "C++", "Python")
val list = 3.14 :: languages
println(list)</code></pre>

<p>Questo script stampa il risultato seguente.

<pre><samp>List(3.14, Scala, Java, Ruby, C#, C++, Python)</samp></pre>

<p>La nuova lista è di tipo <code>List[Any]</code>, dato che <code>Any</code> è il supertipo comune più vicino di <code>String</code> e <code>Double</code>. La lista di partenza era una lista di stringhe, con <code>A</code> uguale a <code>String</code>; in seguito all&#8217;aggiunta di un numero di tipo <code>Double</code> in testa alla lista, il compilatore ha inferito <code>Any</code> come valore di <code>B</code>, cioè il supertipo comune più vicino (e, in realtà, l&#8217;unico).

<blockquote class=note>
<p><span class=u>&#x261E;</span>La firma di tipo <code>B &gt;: A</code> dice che <code>B</code> deve essere un <em>supertipo</em> di <code>A</code>. Non esiste caso analogo in Java: l&#8217;espressione <code>B super A</code> non è valida.
</blockquote>

<h3 id=ACloserLookAtLists>Uno sguardo più attento alle liste</h3>

<p>L&#8217;implementazione della classe <code>List</code> nella libreria Scala merita di essere analizzata nel dettaglio, dato che combina tutte le caratteristiche appena viste e illustra diversi idiomi utili per realizzare strutture dati immutabili in stile funzionale pienamente type-safe e comunque flessibili. Non mostreremo l&#8217;implementazione completa, omettendo <code>object List</code>, numerosi metodi della classe <code>List</code> e i commenti usati per generare la documentazione <em>Scaladoc</em>, ma incoraggiamo il lettore a esaminarla per proprio conto, scaricando la distribuzione del codice sorgente dal sito web del linguaggio <a href=apa.html#Scala>[Scala]</a> oppure visitando la pagina <em>Scaladoc</em> di <code>List</code>. Per evitare confusione con <code>scala.List</code>, useremo nomi diversi per la classe (che chiameremo <code>AbbrevList</code>) e per il package.

<pre><code>// <a href=esempi/cap-12/abbrev-list.scala>esempi/cap-12/abbrev-list.scala</a>
// Adattato da scala/List.scala nella distribuzione di Scala 2.7.5

package bounds.abbrevlist

sealed abstract class AbbrevList[+A] {

  def isEmpty: Boolean
  def head: A
  def tail: AbbrevList[A]

  def ::[B &gt;: A] (x: B): AbbrevList[B] = new bounds.abbrevlist.::(x, this)

  final def foreach(f: A =&gt; Unit) = {
    var these = this
    while (!these.isEmpty) {
      f(these.head)
      these = these.tail
    }
  }
}

// La AbbrevList vuota.

case object AbbrevNil extends AbbrevList[Nothing] {
  override def isEmpty = true

  def head: Nothing =
    throw new NoSuchElementException("testa della AbbrevList vuota")

  def tail: AbbrevList[Nothing] =
    throw new NoSuchElementException("coda della AbbrevList vuota")
}

// Una AbbrevList non vuota caratterizzata da una testa e una coda.

final case class ::[B](private var hd: B,
    private[abbrevlist] var tl: AbbrevList[B]) extends AbbrevList[B] {

  override def isEmpty: Boolean = false
  def head : B = hd
  def tail : AbbrevList[B] = tl
}</code></pre>

<p>Si noti che, sebbene <code>AbbrevList</code> sia immutabile, l&#8217;implementazione interna usa variabili mutabili, per esempio nel metodo <code>foreach</code>.

<p>Il package contiene le definizioni di tre tipi che formano una gerarchia sigillata. Il primo è <code>AbbrevList</code> (l&#8217;analogo di <code>List</code>), un tratto astratto che dichiara i tre metodi astratti <code>isEmpty</code>, <code>head</code> e <code>tail</code> e definisce anche l&#8217;operatore <code>::</code> e un metodo <code>foreach</code>. Sarebbe possibile implementare tutti gli altri metodi di <code>List</code> a partire da questi metodi, sebbene alcuni (come <code>List.length</code>) siano realizzati in maniera differente per ragioni di efficienza.

<p><code>AbbrevNil</code>, l&#8217;analogo di <code>Nil</code>, è un <code>object case</code> che estende <code>AbbrevList[Nothing]</code> restituendo <code>true</code> da <code>isEmpty</code> e lanciando un&#8217;eccezione dai metodi <code>head</code> e <code>tail</code>. Dato che <code>AbbrevNil</code> (come <code>Nil</code>) essenzialmente non ha stato né comportamento, implementarlo sotto forma di un oggetto anziché di una classe elimina le copie non necessarie, rende <code>equals</code> veloce e semplice, <i class=baa>&amp;</i>c.

<p>La classe <code>::</code>, dichiarata <code>final</code>, è l&#8217;analogo di <code>scala.::</code> derivata da <code>List</code>. I suoi argomenti sono l&#8217;elemento che diventerà la testa della nuova lista e una lista esistente che diventerà la coda della nuova lista. Si noti che questi valori vengono memorizzati direttamente come campi. I metodi <code>head</code> e <code>tail</code> definiti in <code>AbbrevList</code> sono semplicemente metodi di lettura per questi campi. Non sono richieste altre strutture dati per rappresentare la lista.

<p>Questo è il motivo per cui aggiungere in testa un nuovo elemento per creare una nuova lista è un&#8217;operazione di complessità temporale O(1). La classe <code>List</code> possiede anche un metodo <code>+</code> deprecato che crea una nuova lista aggiungendo un elemento in coda a una lista esistente: questa operazione è di complessità O(N), dove N è la lunghezza della lista.

<p>Man mano che vengono costruite nuove liste aggiungendo elementi in testa ad altre liste, si forma una gerarchia annidata di istanze di <code>::</code>. Dato che le liste sono immutabili, non è necessario premunirsi contro l&#8217;alterazione accidentale di questa catena nel caso in cui una delle istanze di <code>::</code> venisse modificata in qualche modo.

<p>&Egrave; possibile vedere questa struttura annidata stampando una lista tramite il metodo <code>toString</code> che viene generato automaticamente a causa della parola chiave <code>case</code>. Ecco una sessione <kbd>scala</kbd> di esempio.

<pre><samp>$ scala -cp &hellip;
Welcome to Scala version 2.7.5.final &hellip;
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import bounds.abbrevlist._
import bounds.abbrevlist._

scala&gt; 1 :: 2 :: 3 :: AbbrevNil
res1: bounds.abbrevlist.AbbrevList[Int] = ::(1,::(2,::(3,AbbrevNil)))</samp></pre>

<p>Si noti il risultato sull&#8217;ultima riga, che mostra gli elementi <code>(head,tail)</code> annidati.

<p>Si veda <a class=url href="http://www.scala-lang.org/node/129">http://www.scala-lang.org/node/129</a> per un altro esempio che definisce in modo simile una struttura dati a pila.

<h3 id=ViewsAndViewBounds>Viste e limiti sulle viste</h3>

<p>Abbiamo visto molti casi in cui un metodo implicito viene usato per una conversione di tipo, per esempio allo scopo di far sembrare che si siano aggiunti nuovi metodi a un tipo esistente, come nel pattern cosiddetto <em>Pimp my library</em> ampiamente sfruttato nel capitolo 11. Per effettuare una conversione si possono anche usare valori funzione accompagnati dalla parola chiave <code>implicit</code>. Vedremo un esempio di entrambe le soluzioni tra breve.

<p>Una <em>vista</em> è un valore implicito di tipo funzione che converte un tipo <code>A</code> in un tipo <code>B</code>. La funzione è di tipo <code>A =&gt; B</code> oppure <code>(=&gt; A) =&gt; B</code> (dove <code>(=&gt; A)</code> è un <em>parametro con nome</em>). Si può usare come vista un metodo implicito con la stessa firma visibile nell&#8217;ambito corrente, cioè un metodo implicito importato da un <code>object</code>. Il termine <em>vista</em> esprime l&#8217;idea che da un tipo (<code>A</code>) sia possibile vedere un altro tipo (<code>B</code>).

<p>Una vista viene applicata in due circostanze.

<ol>
<li>Quando un tipo <code>A</code> viene usato in un contesto dove è richiesto un altro tipo <code>B</code> e l&#8217;ambito di visibilità contiene una vista in grado di convertire <code>A</code> in <code>B</code>.
<li>Quando si fa riferimento a un membro inesistente <code>m</code> di un tipo <code>A</code> ma l&#8217;ambito di visibilità contiene una vista in grado di convertire <code>A</code> in un tipo <code>B</code> dotato del membro <code>m</code>.
</ol>

<p>Un esempio comune della seconda circostanza è la sintassi di inizializzazione <code>x -&gt; y</code> delle mappe, che innesca l&#8217;invocazione di <code>Predef.anyToArrowAssoc(x)</code> come abbiamo detto nella sezione <a href=cap-7.html#PredefObject>L&#8217;oggetto <code>Predef</code></a> del capitolo 7.

<p>Come esempio della prima circostanza, si possono considerare le viste definite da <code>Predef</code> per convertire i tipi <code>AnyVal</code> tra loro e per convertire un tipo <code>AnyVal</code> nel tipo corrispondente del package <code>java.lang</code>. Per esempio, <code>double2Double</code> converte un numero <code>scala.Double</code> in un&#8217;istanza di <code>java.lang.Double</code>.

<p>Un <em>limite di vista</em> in una dichiarazione di tipo viene indicato con la parola chiave <code>&lt;%</code>, per esempio <code>A &lt;% B</code>. Il limite consente di usare come valore di <code>A</code> qualsiasi tipo che possa essere convertito in <code>B</code> usando una vista.

<p>Un metodo o una classe che contiene un tale parametro di tipo viene trattato come equivalente a un metodo o a una classe corrispondente dotata di una lista di parametri aggiuntiva che contiene una vista come unico elemento. Per esempio, considerate la seguente definizione di metodo con un limite di vista.

<pre><code>def m [A &lt;% B](arglist): R = &hellip;</code></pre>

<p>La definizione è effettivamente identica a quella del metodo seguente, dove al parametro implicito <code>viewAB</code> il compilatore darebbe un nome unico.

<pre><code>def m [A](arglist)(implicit viewAB: A =&gt; B): R = &hellip;</code></pre>

<p>Si noti che abbiamo una lista di parametri aggiuntiva anziché un parametro aggiuntivo nella lista di parametri esistente.

<p>Questa trasformazione ha l&#8217;effetto voluto perché l&#8217;argomento implicito <code>viewAB</code>, posto che l&#8217;ambito di visibilità contenga una vista del tipo corretto che lo soddisfi, verrà invocato all&#8217;interno di <code>m</code> per convertire tutte le istanze di <code>A</code> in istanze di <code>B</code> ove sia necessario. &Egrave; anche possibile passare esplicitamente una funzione con la firma corretta in una seconda lista di argomenti quando si invoca <code>m</code>, sebbene in alcune situazioni particolari, che descriveremo dopo il nostro prossimo esempio, questo modo di operare non funzioni.

<p>Per i limiti di vista sui tipi, la lista di parametri contenente la vista implicita viene aggiunta al costruttore principale.

<blockquote class=note>
<p><span class=u>&#x261E;</span>I tratti non possono avere limiti di vista per i loro parametri di tipo, poiché i loro costruttori non possono accettare argomenti.
</blockquote>

<p>Per concretizzare quanto è stato detto in un esempio pratico, useremo i limiti di vista per implementare una classe <code>LinkedList</code> dove la lista sia formata da nodi e ogni istanza di <code>Node</code> sia dotata di un campo <code>payload</code> che rappresenta il valore dell&#8217;elemento nella lista e di un riferimento all&#8217;istanza di <code>Node</code> successiva. Per prima cosa, ecco la gerarchia di nodi.

<pre><code>// <a href=esempi/cap-12/node.scala>esempi/cap-12/node.scala</a>

package bounds

abstract trait Node[+A] {
  def payload: A
  def next: Node[A]
}

case class ::[+A](val payload: A, val next: Node[A]) extends Node[A] {
  override def toString =
    String.format("(%s :: %s)", payload.toString, next.toString)
}

object NilNode extends Node[Nothing] {
  def payload = throw new NoSuchElementException("Nessun valore in NilNode")
  def next    = throw new NoSuchElementException("Nessun nodo successivo in NilNode")

  override def toString = "*"
}</code></pre>

<p>Questa gerarchia di tipi è modellata sulla falsariga di <code>List</code> e <code>AbbrevList</code>. Il tipo <code>::</code> rappresenta i nodi intermedi e <code>NilNode</code> è l&#8217;analogo di <code>Nil</code> per <code>List</code>. Il metodo <code>toString</code> è stato ridefinito per fornire una rappresentazione conveniente dei nodi, che esamineremo tra breve.

<p>Lo script seguente definisce un tipo <code>LinkedList</code> che usa istanze di <code>Node</code>.

<pre><code>// <a href=esempi/cap-12/view-bounds-script.scala>esempi/cap-12/view-bounds-script.scala</a>

import bounds._

implicit def any2Node[A](x: A): Node[A] = bounds.::[A](x, NilNode)

case class LinkedList[A &lt;% Node[A]](val head: Node[A]) {

  def ::[B &gt;: A &lt;% Node[B]](x: Node[B]) =
    LinkedList(bounds.::(x.payload, head))

  override def toString = head.toString
}

val list1 = LinkedList(1)
val list2 = 2 :: list1
val list3 = 3 :: list2
val list4 = "QUATTRO!" :: list3

println(list1)
println(list2)
println(list3)
println(list4)</code></pre>

<p>Lo script comincia con la definizione di un metodo implicito parametrico <code>any2Node</code> capace di convertire <code>A</code> in <code>Node[A]</code>, che verrà usato come vista e passato come argomento implicito quando lavoreremo con le istanze di <code>LinkedList</code>. Il metodo crea un nodo &#8220;foglia&#8221; usando un nodo <code>bounds.::</code> con un riferiento a <code>NilNode</code> come elemento &#8220;successivo&#8221; nella lista.

<p>In alternativa, si potrebbe definire un valore funzione che converte <code>Any</code> in <code>Node[Any]</code>.

<pre><code>implicit val any2Node = (a: Any) =&gt; bounds.::[Any](a, NilNode)</code></pre>

<p>In questo caso, lo script verrebbe eseguito allo stesso modo, a parte il fatto che alcune liste temporanee userebbero <code>Node[Any]</code> anziché <code>Node[Int]</code>.

<p>La dichiarazione di <code>LinkedList</code> definisce un limite di vista su <code>A</code> e accetta come singolo argomento l&#8217;istanza di <code>Node</code> che fa da testa alla lista (che potrebbe essere la testa di una catena di nodi).

<pre><code>case class LinkedList[A &lt;% Node[A]](val head: Node[A]) { &hellip; }</code></pre>

<p>Come si vede più avanti nello script, anche se il costruttore richiede un argomento di tipo <code>Node[A]</code>, è possibile passargli un&#8217;istanza di <code>A</code> e aspettarsi l&#8217;invocazione della vista implicita <code>any2Node</code>. Il vantaggio di questo approccio è che il cliente non deve mai preoccuparsi di costruire opportunamente le istanze di <code>Node</code> perché il meccanismo gestisce questo processo in maniera automatica.

<p>La classe è anche dotata di un operatore <code>::</code>.

<pre><code>def ::[B &gt;: A &lt;% Node[B]](x: Node[B]) = &hellip;</code></pre>

<p>Il parametro di tipo significa che &#8220;<code>B</code> è limitato inferiormente da (cioè è un supertipo di) <code>A</code> e ha un limite di vista uguale a <code>B &lt;% Node[B]</code>.&#8221; Come abbiamo visto per <code>List</code> e <code>AbbrevList</code>, il limite inferiore consente di aggiungere in testa alla lista elementi di tipi differenti rispetto al tipo <code>A</code> originale. Il compilatore aggiungerà a questo metodo un argomento implicito per la vista, ma il nostro metodo implicito parametrico <code>any2Node</code> verrà usato anche per quell&#8217;argomento.

<p>In precedenza abbiamo affermato che, se l&#8217;ambito corrente non contiene una vista adatta, è possibile passare esplicitamente un convertitore &#8220;non implicito&#8221; in una seconda lista di argomenti. Nel nostro esempio, in realtà, questo espediente non funzionerebbe, perché il costruttore e il metodo <code>::</code> di <code>LinkedList</code> accettano argomenti di tipo <code>Node[A]</code>, ma noi li invochiamo con istanze di <code>Int</code> e <code>String</code>. Per poter passare manualmente il convertitore dovremmo invocare entrambi usando argomenti di tipo <code>Node[Int]</code> e <code>Node[String]</code>, e l&#8217;invocazione di <code>::</code> risulterebbe anche piuttosto inelegante, come in <code>val list2 = list1.::(2)(convertitore)</code>.

<p>Si noti la particolare sintassi usata per il parametro di tipo, che a prima vista potrebbe creare confusione. Leggendo <code>B &gt;: A &lt;% Node[B]</code> si potrebbe essere tentati di assumere che, in questa espressione, l&#8217;operatore <code>&lt;%</code> vada applicato ad <code>A</code>, ma in realtà deve essere applicato a <code>B</code>. La grammatica per i parametri di tipo, compresi i limiti di vista, è la seguente <a href=apa.html#ScalaSpec2009>[ScalaSpec2009]</a>.

<pre><code>TypeParam ::= (id | &#8216;_&#8217;) [TypeParamClause] [&#8216;&gt;:&#8217; Type] [&#8216;&lt;:&#8217; Type] [&#8216;&lt;%&#8217; Type]
TypeParamClause ::= &#8216;[&#8217; VariantTypeParam {&#8216;,&#8217; VariantTypeParam} &#8216;]&#8217;
VariantTypeParam ::= [&#8216;+&#8217; | &#8216;&#8217;] TypeParam</code></pre>

<p>Come vedete, è possibile costruire espressioni per rappresentare tipi gerarchici molto complessi. Nel metodo <code>::</code> definito per <code>LinkedList</code>, <code>id</code> è <code>B</code>, <code>TypeParamClause</code> è vuota e sulla destra abbiamo le espressioni <code>&gt;: A</code> e <code>&lt;% Node[B]</code>. Ancora una volta, tutte le espressioni dei limiti si applicano al primo <code>id</code> (cioè <code>B</code>) o alla variabile indicata dal trattino basso <code>_</code> usato per i <em>tipi esistenziali</em>, di cui parleremo più avanti in una sezione a loro dedicata.

<p>Infine, in fondo allo script creiamo un&#8217;istanza di <code>LinkedList</code> e vi aggiungiamo in testa alcuni valori per creare nuove liste che poi verranno stampate.

<pre><samp>1 :: *
2 :: 1 :: *
3 :: 2 :: 1 :: *
QUATTRO! :: 3 :: 2 :: 1 :: *</samp></pre>

<p>Per ricapitolare, i limiti di vista ci permettono di lavorare con &#8220;valori utili&#8221; di tipo intero e stringa mentre l&#8217;implementazione gestisce le conversioni necessarie per ottenere le istanze di <code>Node</code>.

<p>I limiti di vista non vengono usati con la stessa frequenza dei limiti inferiore e superiore sui tipi, ma offrono un meccanismo elegante da adoperare nelle situazioni in cui si desidera sfruttare la conversione automatica tra due tipi. Come sempre, gli impliciti devono essere usati con cautela: le conversioni implicite non risultano assolutamente chiare dalla lettura del codice e durante le attività di debug.

<h2 id=NothingAndNull><code>Nothing</code> e <code>Null</code></h2>

<p>Nella sezione <a href=cap-7.html#ScalaTypeHierarchy>La gerarchia di tipi di Scala</a> del capitolo 7 abbiamo detto che <code>Null</code> è un sottotipo di tutti i tipi <code>AnyRef</code> e che <code>Nothing</code> è un sottotipo di tutti i tipi, incluso <code>Null</code>.

<p><code>Null</code> è un tratto dichiarato come <code>final</code> (in modo che non possa essere esteso) di cui esiste una sola istanza, <code>null</code>. Dato che <code>Null</code> è un sottotipo di tutti i tipi <code>AnyRef</code>, è sempre possibile usare <code>null</code> come istanza di qualsiasi altro tipo. Java, al contrario, tratta semplicemente <code>null</code> come una parola chiave gestita in modo particolare dal compilatore. Tuttavia, il <code>null</code> di Java in realtà si comporta come se fosse un sottotipo di tutti i tipi riferimento, proprio come il <code>Null</code> di Scala.

<p>D&#8217;altra parte, dato che <code>Null</code> non è un sottotipo di <code>AnyVal</code>, non è possibile usare <code>null</code> come istanza di <code>Int</code>, per esempio, coerentemente con la semantica dei tipi primitivi in Java.

<p>Anche <code>Nothing</code> è un tratto dichiarato come <code>final</code>, ma dato che non ne esiste alcuna istanza viene utilizzato per definire altri tipi. Il miglior esempio è <code>Nil</code>, che rappresenta la lista vuota come un <code>case object</code> di tipo <code>List[Nothing]</code>. Dato che, come abbiamo visto, le liste in Scala sono covarianti, <code>Nil</code> è a tutti gli effetti un&#8217;istanza di <code>List[T]</code> per qualsiasi tipo <code>T</code>. Questa caratteristica è stata anche sfruttata nelle precedenti implementazioni di <code>AbbrevList</code> e <code>LinkedList</code>.

<h2 id=_understanding_abstract_types>Capire i tipi astratti</h2>

<p>In agginuta ai tipi parametrici, che di solito si trovano nei linguaggi orientati agli oggetti staticamente tipati, Scala supporta i tipi astratti, rintracciabili nella maggior parte dei linguaggi funzionali. Abbiamo presentato i tipi astratti nella sezione <a href=cap-2.html#AbstractTypesAndParameterizedTypes>Tipi astratti e tipi parametrici</a> del capitolo 2.

<p>Questi due generi di tipo si sovrappongono tra loro in una certa misura. Tecnicamente, è possibile implementare quasi tutti gli idiomi supportati dai tipi parametrici usando i tipi astratti, e viceversa. Tuttavia, in pratica, ogni genere è adatto per natura a risolvere problemi di progettazione diversi.

<p>Riprendiamo la nostra versione del pattern Observer che sfrutta i tipi astratti, vista nel <a href=cap-6.html>capitolo 6</a>.

<pre><code>// <a href=esempi/cap-6/observer/observer2.scala>esempi/cap-6/observer/observer2.scala</a>

package observer

trait AbstractSubject {
  type Observer

  private var observers = List[Observer]()
  def addObserver(observer:Observer) = observers ::= observer
  def notifyObservers = observers foreach (notify(_))

  def notify(observer: Observer): Unit
}

trait SubjectForReceiveUpdateObservers extends AbstractSubject {
  type Observer = { def receiveUpdate(subject: Any) }

  def notify(observer: Observer): Unit = observer.receiveUpdate(this)
}

trait SubjectForFunctionalObservers extends AbstractSubject {
  type Observer = (AbstractSubject) =&gt; Unit

  def notify(observer: Observer): Unit = observer(this)
}</code></pre>

<p><code>AbstractSubject</code> dichiara un tipo <code>Observer</code> senza limiti di tipo che viene definito nei due tratti derivati: come <em>tipo strutturale</em> in <code>SubjectForReceiveUpdate</code>, come <em>tipo funzione</em> in <code>SubjectForFunctionalObservers</code>. Tratteremo questi due tipi in maniera più approfondita nelle prossime sezioni di questo capitolo.

<p>I limiti di tipo possono essere usati anche quando si dichiara o si perfeziona la dichiarazione di un tipo astratto. Vedremo un semplice esempio nella sezione <a href=#TypeProjections>Proiezioni di tipo</a> di questo capitolo, dove esamineremo una dichiarazione <code>type t &lt;: AnyRef</code> in cui <code>t</code> ha un <em>limite superiore di tipo</em> (superclasse) uguale a <code>AnyRef</code> che esclude tutti i tipi <code>AnyVal</code>.

<p>Nelle dichiarazioni di tipo astratto possono anche essere presenti <em>limiti inferiori di tipo</em> (sottoclassi) e nelle espressioni dei limiti si possono usare la maggior parte dei <em>tipi valore</em> (si veda la sezione <a href=#ValueTypes>Tipi valore</a> più avanti). Ecco un esempio che illustra le opzioni più comuni.

<pre><code>// <a href=esempi/cap-12/abs-type-examples-script.scala>esempi/cap-12/abs-type-examples-script.scala</a>

trait exampleTrait {
  type t1               // Senza vincoli
  type t2 &gt;: t3 &lt;: t1   // t2 deve essere un supertipo di t2 e un sottotipo di t1
  type t3 &lt;: t1         // t3 deve essere un sottotipo di t1
  type t4               // Senza vincoli
  type t5 = List[t4]    // Lista di t4, qualunque sarà il tipo t4...

  val v1: t1            // Non può essere inizializzata fino a quando t1 non viene definito
  val v3: t3            // &amp;c.
  val v2: t2            // ...
  val v4: t4            // ...
  val v5: t5            // ...
}

trait T1 { val name1: String }
trait T2 extends T1 { val name2: String }
class C(val name1: String, val name2: String) extends T2

object example extends exampleTrait {
  type t1 = T1
  type t2 = T2
  type t3 = C
  type t4 = Int

  val v1 = new T1 { val name1 = "T1"}
  val v3 = new C("C1", "C2")
  val v2 = new T2 { val name1 = "T1"; val name2 = "T2" }
  val v4 = 10
  val v5 = List(1,2,3,4,5)
}</code></pre>

<p>I commenti spiegano la maggior parte dei dettagli. Le relazioni tra <code>t1</code>, <code>t2</code> e <code>t3</code> presentano alcuni aspetti interessanti. Per cominciare, <code>t2</code> viene dichiarato in modo da trovarsi &#8220;tra&#8221; <code>t1</code> e <code>t3</code>. Il tipo <code>t1</code>, qualsiasi esso sia, deve essere una superclasse di <code>t2</code> (o uguale a <code>t2</code>) e <code>t3</code> deve essere una sottoclasse di <code>t2</code> (o uguale a <code>t2</code>).

<p>Se ricordate quanto detto nella sezione <a href=#TypeBounds>Limiti sui tipi</a>, qui viene fatta la dichiarazione del <em>primo</em> tipo dopo la parola chiave <code>type</code>, cioè <code>t2</code>, non del tipo nel mezzo, cioè <code>t3</code>. Il resto di questa espressione indica i limiti su <code>t2</code>.

<p>Si consideri la riga successiva, che contiene la dichiarazione di <code>t3</code> come sottotipo di <code>t1</code>. Se mancasse il limite di tipo, il compilatore genererebbe un errore, perché la relazione <code>t3 &lt;: t1</code> viene implicata dalla dichiarazione precedente di <code>t2</code>. Questo non significa che potete omettere la dichiarazione di <code>t3</code>, che deve essere presente, ma deve allo stesso tempo indicare un limite di tipo coerente con quello implicato dalla dichiarazione di <code>t2</code>.

<p>Quando rivisiteremo il pattern Observer nella sezione <a href=cap-13.html#SelfTypeAnnotationsAndAbstractTypeMembers>Annotazioni self-type e membri tipo astratti</a> del capitolo 13, esamineremo un altro esempio di limiti di tipo usati sui tipi astratti, vedremo i problemi che possono causare e un modo elegante per risolverli.

<p>Infine, i tipi astratti non possono avere annotazioni di varianza.

<pre><code>// <a href=esempi/cap-12/abs-type-variances-wont-compile.scala>esempi/cap-12/abs-type-variances-wont-compile.scala</a>
// Non verrà compilato!

trait T1 { val name1: String }
trait T2 extends T1 { val name2: String }
class C(val name1: String, val name2: String) extends T2

trait T {
  type t: +T1   // ERRORE, annotazioni di varianza +/- illegali
  val v
}</code></pre>

<p>Ricordate che i tipi astratti sono <em>membri</em> del tipo che li racchiude anziché essere parametri di tipo come accade nei tipi parametrici. Il tipo che li racchiude può avere una relazione di ereditarietà con altri tipi, ma i membri tipo si comportano esattamente come i metodi e le variabili: non hanno influenza sulle relazioni di ereditarietà del tipo che li racchiude. Come gli altri membri, i tipi astratti possono essere dichiarati astratti o concreti, tuttavia la loro definizione può venire perfezionata nei sottotipi senza essere completata, a differenza di quanto accade per le variabili e i metodi. Naturalmente, si possono creare istanze solo quando ai tipi astratti è stata data una definizione concreta.

<h3 id=_parameterized_types_vs_abstract_types>Un confronto tra tipi parametrici e tipi astratti</h3>

<p>La scelta tra tipi parametrici e tipi astratti è una delle tipiche decisioni da prendere durante la progettazione. I tipi parametrici sono i più adatti per i tipi contenitore come <code>List</code> e <code>Option</code>. Si consideri la dichiarazione di <code>Some</code>, inclusa nella libreria standard.

<pre><code>case final class Some[+A](val x : A) { &hellip; }</code></pre>

<p>Tentando di convertire questa dichiarazione per usare i tipi astratti, si potrebbe cominciare con quanto segue.

<pre><code>case final class Some(val x : ???) {
  type A
  &hellip;
}</code></pre>

<p>Il tipo del campo <code>x</code> rimane indefinito. Non è possibile usare <code>A</code> perché non è visibile dai parametri del costruttore. Si potrebbe usare <code>Any</code>, perdendo però il valore aggiunto di una dichiarazione che usi i tipi nel modo più opportuno.

<p>Se si corre il rischio di dichiarare i parametri di un costruttore usando un tipo &#8220;segnaposto&#8221; che non è ancora stato definito, allora i tipi parametrici sono l&#8217;unica soluzione valida (a meno di usare <code>Any</code> o <code>AnyRef</code>).

<p>I tipi astratti si possono usare nei parametri di un metodo e come valori di ritorno all&#8217;interno di una funzione. Tuttavia, possono sorgere due problemi: primo, nel caso si usino tipi dipendenti dal percorso (esaminati più avanti nella sezione <a href=#PathDependentTypes>Tipi dipendenti dal percorso</a>) il compilatore potrebbe confondersi, ritenendo incompatibile l&#8217;uso di un tipo in un particolare contesto quando in effetti il percorso conduce a un tipo compatibile; secondo, è insolito esprimere metodi come <code>List.::</code> usando tipi astratti là dove possono avvenire cambiamenti di tipo (espansioni, in questo caso).

<pre><code>class List[+A] {
  &hellip;
  def ::[B &gt;: A](x : B) : List[B] = new scala.::(x, this)
  &hellip;
}</code></pre>

<p>Inoltre, se si desidera esprimere la varianza in caso di ereditarietà che è legata alle astrazioni di tipo, allora i tipi parametrici sono in grado di chiarire ed esplicitare questi comportamenti usando le annotazioni di varianza.

<p>Queste limitazioni sui tipi astratti in realtà riflettono la tensione tra l&#8217;ereditarietà orientata agli oggetti e le origini funzionali dei tipi astratti, introdotti nei sistemi di tipi adottati nella programmazione funzionale pura, che non possiede il concetto di ereditarietà. I tipi parametrici sono più popolari nei linguaggi orientati agli oggetti perché gestiscono l&#8217;ereditarietà in maniera più naturale nella maggior parte delle situazioni.

<p>D&#8217;altra parte, talvolta è utile fare riferimento a un&#8217;astrazione di tipo come a un membro di un altro tipo anziché come a un parametro usato per costruire nuovi tipi a partire da un tipo parametrico. Una dichiarazione di tipo astratto che viene perfezionata attraverso una serie di raffinamenti del tipo che la racchude può rivelarsi piuttosto elegante.

<pre><code>trait T1 {
  type t
  val v: t
}
trait T2 extends T1 {
  type t &lt;: SomeType1
}
trait T3 extends T2 {
  type t &lt;: SomeType2  // dove SomeType2 &lt;: SomeType1
}
class C extends T3 {
  type t = Concrete    // dove Concrete &lt;: SomeType2
  val v = new Concrete(&hellip;)
}
&hellip;</code></pre>

<p>In più, questo esempio mostra che i tipi astratti vengono spesso usati per dichiarare variabili astratte dello stesso tipo. Vengono usati, meno frequentemente, anche per le dichiarazioni di metodo.

<p>Per rendere finalmente concrete le variabili astratte è possibile definirle all&#8217;interno del corpo del tipo, in maniera molto simile a come sono state dichiarate in origine, oppure inizializzarle tramite gli argomenti del costruttore. Questa seconda tecnica permette a chi usa il tipo di scegliere l&#8217;effettivo valore, mentre la prima lascia questa decisione al progettista del tipo.

<p>Abbiamo effettuato l&#8217;inizializzazione sfruttando gli argomenti del costruttore nella classe <code>BulkReader</code>, parte del breve esempio presentato nella sezione <a href=cap-2.html#AbstractTypesAndParameterizedTypes>Tipi astratti e tipi parametrici</a> del capitolo 2.

<pre><code>// <a href=esempi/cap-2/abstract-types-script.scala>esempi/cap-2/abstract-types-script.scala</a>

import java.io._

abstract class BulkReader {
  type In
  val source: In
  def read: String
}

class StringBulkReader(val source: String) extends BulkReader {
  type In = String
  def read = source
}

class FileBulkReader(val source: File) extends BulkReader {
  type In = File
  def read = {
    val in = new BufferedInputStream(new FileInputStream(source))
    val numBytes = in.available()
    val bytes = new Array[Byte](numBytes)
    in.read(bytes, 0, numBytes)
    new String(bytes)
  }
}

println(new StringBulkReader("Ciao Scala!").read)
println(new FileBulkReader(new File("abstract-types-script.scala")).read)</code></pre>

<p>Chi si è formato sulla programmazione orientata agli oggetti tenderà naturalmente a usare i tipi parametrici più spesso dei tipi astratti. Anche la libreria standard di Scala tende a enfatizzare l&#8217;uso dei tipi parametrici. In ogni caso, è consigliabile riconoscere i meriti dei tipi astratti e imparare a usarli quando ha senso farlo.

<h2 id=PathDependentTypes>Tipi dipendenti dal percorso</h2>

<p>I linguaggi che consentono di annidare i tipi mettono anche a disposizione alcuni modi di fare riferimento al <em>percorso</em> di quei tipi. Scala è dotato di una ricca sintassi per i tipi dipendenti dal percorso, di cui è utile comprendere i concetti principali anche se viene usata raramente, in quanto i messaggi di errore del compilatore contengono spesso percorsi di tipo.

<p>Si consideri l&#8217;esempio seguente.

<pre><code>// <a href=esempi/cap-12/type-path-wont-compile.scala>esempi/cap-12/type-path-wont-compile.scala</a>
// Non verrà compilato!

trait Service {
  trait Logger {
    def log(message: String): Unit
  }
  val logger: Logger

  def run = {
    logger.log("Avvio " + getClass.getSimpleName + ":")
    doRun
  }

  protected def doRun: Boolean
}

object MyService1 extends Service {
  class MyService1Logger extends Logger {
    def log(message: String) = println("1: " + message)
  }
  override val logger = new MyService1Logger
  def doRun = true  // fai qualcosa di concreto...
}

object MyService2 extends Service {
  override val logger = MyService1.logger  // ERRORE
  def doRun = true  // fai qualcosa di concreto...
}</code></pre>

<p>Compilando questo file si ottiene l&#8217;errore seguente.

<pre><samp>&hellip;:27: error: error overriding value logger in trait Service of type MyService2.Logger;
 value logger has incompatible type MyService1.MyService1Logger
  override val logger = MyService1.logger  // ERRORE
               ^
one error found</samp></pre>

<p>Il compilatore si lamenta del fatto che il valore <code>logger</code> di <code>MyService2</code> sulla riga 27 è di tipo <code>MyService2.Logger</code> pur essendo stato dichiarato come <code>Logger</code> nel tratto genitore <code>Service</code>, e del tentativo di assegnargli un valore di tipo <code>MyService1.MyService1Logger</code>.

<p>Questi tre tipi sono considerati diversi in Scala. <code>Logger</code> è annidato in <code>Service</code>, che è il genitore di <code>MyService1</code> e <code>MyService2</code>. In Scala ciò significa che il tipo <code>Logger</code> annidato è unico per ognuno dei sottotipi. Il tipo reale è <em>dipendente dal percorso</em>.

<p>In questo caso, la soluzione più semplice è spostare la dichiarazione di <code>Logger</code> al di fuori di <code>Service</code>, rimuovendo così la dipendenza dal percorso. In altri casi, è possibile qualificare il tipo in modo che corrisponda al tipo che desiderate.

<p>Esistono diverse forme di percorsi di tipo.

<h3 id=_c_this>Il percorso <code>C.this</code></h3>

<p>All&#8217;interno del corpo di una qualsiasi classe <code>C</code> potete usare <code>C.this</code> o <code>this</code> per fare riferimento all&#8217;istanza corrente.

<pre><code>class C1 {
  var x = "1"
  def setX1(x:String) = this.x = x
  def setX2(x:String) = C1.this.x = x
}</code></pre>

<p>Sia <code>setX1</code> sia <code>setX2</code> hanno lo stesso effetto, perché <code>C1.this</code> è equivalente a <code>this</code>.

<p>All&#8217;interno del corpo di un tipo e al di fuori della definizione di un metodo <code>this</code> fa riferimento al tipo stesso.

<pre><code>trait T1 {
  class C
  val c1 = new C
  val c2 = new this.C
}</code></pre>

<p>I valori <code>c1</code> e <code>c2</code> sono dello stesso tipo. L&#8217;occorrenza di <code>this</code> nell&#8217;espressione <code>this.C</code> fa riferimento al tratto <code>T1</code>.

<h3 id=_c_super>Il percorso <code>C.super</code></h3>

<p>Potete fare riferimento in modo specifico al genitore di un tipo usando <code>super</code>.

<pre><code>class C2 extends C1
class C3 extends C2 {
  def setX3(x:String) = super.setX1(x)
  def setX4(x:String) = C3.super.setX1(x)
  def setX5(x:String) = C3.super[C2].setX1(x)
}</code></pre>

<p><code>C3.super</code> è equivalente a <code>super</code> in questo esempio. Se volete fare riferimento a uno specifico genitore tra tutti quelli di un tipo, potete qualificare <code>super</code> con il tipo, come mostrato in <code>setX5</code>. Questo è particolarmente utile nel caso in cui un tipo mescoli diversi tratti, ognuno dei quali ridefinisca lo stesso metodo: se avete bisogno di accedere al metodo di un tratto specifico, potete qualificare <code>super</code>. Tuttavia, questa qualifica non può spingersi oltre il livello immediatamente superiore nella gerarchia, cioè non può fare riferimento ai tipi genitore del tipo genitore, e così via.

<p>Se invocate <code>super</code> in una classe dotata di numerosi mixin e che estende un altro tipo, nel caso in cui il riferimento non sia qualificato sono le regole di <em>linearizzazione</em> a determinare l&#8217;obiettivo di <code>super</code> (si veda la sezione <a href=cap-7.html#Linearization>Linearizzare la gerarchia di un oggetto</a> nel capitolo 7).

<p>Proprio come accade per <code>this</code>, potete usare <code>super</code> per fare riferimento al tipo genitore nel corpo di un tipo al di fuori di un metodo.

<pre><code>class C4 {
  class C5
}
class C6 extends C4 {
  val c5a = new C5
  val c5b = new super.C5
}</code></pre>

<p>Sia <code>c5a</code> sia <code>c5b</code> sono dello stesso tipo.

<h3 id=_path_x>Il percorso <code>path.x</code></h3>

<p>Potete raggiungere un tipo annidato attraverso una espressione di percorso suddivisa da punti.

<pre><code>package P1 {
  object O1 {
    object O2 {
      val name = "nome"
    }
  }
}
class C7 {
  val name = P1.O1.O2.name
}</code></pre>

<p><code>C7.name</code> usa un percorso verso il valore <code>name</code> in <code>O2</code>. Gli elementi di un percorso di tipo devono essere <em>stabili</em>, il che a grandi linee comprende package e oggetti singleton, e dichiarazioni di tipo usate come alias di queste due entità. L&#8217;ultimo elemento di un percorso può essere una classe o un tratto. Si veda <a href=apa.html#ScalaSpec2009>[ScalaSpec2009]</a> per i dettagli.

<pre><code>object O3 {
  object O4 {
    type t = java.io.File
    class C
    trait T
  }
  class C2 {
    type t = Int
  }
}
class C8 {
  type t1 = O3.O4.t
  type t2 = O3.O4.C
  type t3 = O3.O4.T
//  type t4 = O3.C2.t   // ERRORE: C2 non è un "valore" in O3
}</code></pre>

<h2 id=ValueTypes>Tipi valore</h2>

<p>Dato che Scala è tipato in modo forte e statico, ogni valore è dotato di tipo. Il termine <em>tipi valore</em> si riferisce a tutte le forme differenti che questi tipi possono assumere, quindi comprende molte forme che ora ci sono familiari, più alcune nuove forme che finora non abbiamo incontrato.

<blockquote class=warning>
<p><span class=u>&#x2762;</span>Qui stiamo usando il termine <em>tipi valore</em> nello stesso modo in cui viene usato in <a href=apa.html#ScalaSpec2009>[ScalaSpec2009]</a>. Tuttavia, in altri punti del libro abbiamo anche seguito l&#8217;uso sovraccaricato del termine adottato dalla specifica per fare riferimento a tutti i sottotipi di <code>AnyVal</code>.
</blockquote>

<h3 id=_type_designators>Designatori di tipo</h3>

<p>Gli identificatori di tipo convenzionali che vengono comunemente usati sono chiamati <em>designatori di tipo</em>.

<pre><code>class Person              // "Person" è il designatore di tipo
object O { type t }       // "O" e "t" sono designatori di tipo
&hellip;</code></pre>

<p>In realtà, i designatori non rappresentano altro che una sintassi abbreviata per le <em>proiezioni di tipo</em>, di cui parleremo più avanti.

<h3 id=_tuples>Tuple</h3>

<p>Un valore della forma <code>(x<sub>1</sub>, &hellip; x<sub>N</sub>)</code> è un tipo valore tupla.

<h3 id=_parameterized_types>Tipi parametrici</h3>

<p>I tipi creati a partire da un tipo parametrico, come <code>List[Int]</code> e <code>List[String]</code>, creati a partire da <code>List[A]</code>, sono tipi valore perché vengono associati alla dichiarazione di valori, come nell&#8217;espressione <code>val names = List[String]()</code>.

<h3 id=_annotated_types>Tipi annotati</h3>

<p>Quando si annota un tipo, come in <code>@serializable @cloneable class C(val x:String)</code>, il tipo effettivo include le annotazioni.

<h3 id=_compound_types>Tipi composti</h3>

<p>Una dichiarazione della forma <code>T<sub>1</sub> extends T<sub>2</sub> with T<sub>3</sub> { R }</code>, dove <code>R</code> è il <em>raffinamento</em> (corpo), rappresenta un tipo composto. Qualsiasi dichiarazione nel raffinamento è parte della definizione del tipo composto. La nozione di tipi composti tiene in considerazione il fatto che non tutti i tipi hanno un nome, dato che possono esistere tipi anonimi, come mostra questa sessione di esempio di <kbd>scala</kbd>.

<pre><samp>scala&gt; val x = new T1 with T2 {
        type z = String
        val v: z = "Z"
}
x: java.lang.Object with T1 with T2{type z = String; def v: this.z} = $anon$1@9d9347d</samp></pre>

<p>Si noti il tipo dipendente dal percorso <code>this.z</code> nell&#8217;ultima riga.

<p>Particolarmente interessante è il caso di una dichiarazione della forma <code>val x = new { R }</code>, priva di qualsiasi identificatore di tipo. Questa dichiarazione è equivalente a <code>val x = new AnyRef { R }</code>.

<h3 id=_infix_types>Tipi infissi</h3>

<p>Alcuni tipi parametrici possono accettare due argomenti di tipo, per esempio <code>scala.Either[+A,+B]</code>. Scala vi consente di dichiarare istanze di questi tipi usando una notazione infissa, come in <code>a Either b</code>. Si consideri l&#8217;uso che viene fatto di <code>Either</code> nello script seguente.

<pre><code>// <a href=esempi/cap-12/infix-types-script.scala>esempi/cap-12/infix-types-script.scala</a>

def attempt(operation: =&gt; Boolean): Throwable Either Boolean = try {
  Right(operation)
} catch {
  case t: Throwable =&gt; Left(t)
}

println(attempt { throw new RuntimeException("Bu!") })
println(attempt { true })
println(attempt { false })</code></pre>

<p>Il metodo <code>attempt</code> valuterà il parametro <code>operation</code> <em>invocato per nome</em> e restituirà il suo risultato di tipo <code>Boolean</code>, racchiuso in un&#8217;istanza di <code>Right</code>, <em>oppure</em> una qualsiasi istanza di <code>Throwable</code> che sia stata catturata, racchiusa in un&#8217;istanza di <code>Left</code>. Lo script stampa il testo seguente.

<pre><samp>Left(java.lang.RuntimeException: Bu!)
Right(true)
Right(false)</samp></pre>

<p>Si noti la dichiarazione del valore di ritorno, <code>Throwable Either Boolean</code>, che è identica a <code>Either[Throwable, Boolean]</code>. Ricordatevi che, come abbiamo visto nella sezione <a href=cap-7.html#ScalaTypeHierarchy>La gerarchia di tipi di Scala</a> del capitolo 7, quando si sfrutta questo idioma per gestire le eccezioni con <code>Either</code> la convenzione vuole che <code>Left</code> venga usato per l&#8217;eccezione e <code>Right</code> per il valore di ritorno ordinario.

<h3 id=FunctionTypes>Tipi funzione</h3>

<p>Anche le funzioni che abbiamo scritto finora sono tipate. <code>(T<sub>1</sub>, T<sub>2</sub>, &hellip; T<sub>N</sub>) =&gt; R</code> è il tipo di tutte le funzioni che accettano <code>N</code> argomenti e restituiscono un valore di tipo <code>R</code>.

<p>Quando c&#8217;è un solo argomento, è possibile tralasciare le parentesi, come in <code>T =&gt; R</code>. Una funzione che accetta un parametro <em>invocato per nome</em> (come discusso nel <a href=cap-8.html>capitolo 8</a>) è di tipo <code>(=&gt;T) =&gt; R</code>. Abbiamo usato un argomento invocato per nome nell&#8217;esempio con la funzione <code>attempt</code> della sezione precedente.

<p>Ricordatevi che in Scala ogni cosa è un oggetto, persino le funzioni. La libreria Scala definisce i tratti <code>FunctionN</code>, per <code>N</code> che va da <code>0</code> a <code>22</code>, estremi inclusi. Ecco, per esempio, il codice sorgente di <code>scala.Function3</code> incluso nella versione 2.7.5 di Scala, privo della maggior parte dei commenti e di alcuni ulteriori dettagli a cui per ora non siamo interessati.

<pre><code>// Da Scala 2.7.5: scala.Function3 (estratto).
package scala

trait Function3[-T1, -T2, -T3, +R] extends AnyRef {
  def apply(v1:T1, v2:T2, v3:T3): R
  override def toString() = "&lt;function&gt;"

  /** f(x1,x2,x3)  == (f.curry)(x1)(x2)(x3)
   */
  def curry: T1 =&gt; T2 =&gt; T3 =&gt; R = {
    (x1: T1) =&gt; (x2: T2) =&gt; (x3: T3) =&gt; apply(x1,x2,x3)
  }
}</code></pre>

<p>Come abbiamo detto nella sezione <a href=#VarianceUnderInheritance>Varianza in caso di ereditarietà</a>, i tratti <code>FunctionN</code> sono <em>controvarianti</em> nei parametri di tipo per gli argomenti e <em>covarianti</em> nel parametro di tipo per il tipo di ritorno.

<p>Se ricordate, quando si usa il riferimento a un oggetto qualsiasi seguito da una lista di argomenti, Scala invoca il metodo <code>apply</code> su quell&#8217;oggetto. In questo modo, anche qualsiasi oggetto dotato di un metodo <code>apply</code> può essere considerato una funzione, offrendo una gradevole visione simmetrica della doppia natura di Scala, funzionale e orientata agli oggetti.

<p>Quando si definisce un valore funzione, il compilatore istanzia l&#8217;oggetto <code>FunctionN</code> appropriato e usa la definizione di funzione come corpo di <code>apply</code>.

<pre><code>// <a href=esempi/cap-12/function-types-script.scala>esempi/cap-12/function-types-script.scala</a>

val capitalizer = (s: String) =&gt; s.toUpperCase

val capitalizer2 = new Function1[String,String] {
  def apply(s: String) = s.toUpperCase
}

println(List("Programmare", "in", "Scala") map capitalizer)
println(List("Programmare", "in", "Scala") map capitalizer2)</code></pre>

<p>I valori funzione <code>capitalizer</code> e <code>capitalizer2</code> sono in realtà identici: il secondo imita il risultato prodotto dalla compilazione del primo.

<p>Abbiamo parlato in precedenza del metodo <code>curry</code> nella sezione <a href=cap-8.html#Currying>Currying</a> del capitolo 8. Tale metodo restituisce una nuova funzione con <code>N</code> liste di argomenti, ognuna delle quali contiene un singolo argomento preso dalla lista di argomenti originale contenente <code>N</code> elementi. Si noti che viene invocato lo stesso metodo <code>apply</code>.

<pre><code>// <a href=esempi/cap-12/curried-function-script.scala>esempi/cap-12/curried-function-script.scala</a>

val f  = (x: Double, y: Double, z: Double) =&gt; x * y / z
val fc = f.curry

val answer1 = f(2., 5., 4.)
val answer2 = fc(2.)(5.)(4.)
println(answer1 + " == " + answer2 + "? " + (answer1 == answer2))

val fc1 = fc(2.)
val fc2 = fc1(5.)
val answer3 = fc2(4.)
println(answer3 + " == " + answer2 + "? " + (answer3 == answer2))</code></pre>

<p>Questo script stampa il testo seguente.

<pre><samp>2.5 == 2.5? true
2.5 == 2.5? true</samp></pre>

<p>Nella prima parte dello script, definiamo un valore <code>f</code> di tipo <code>Function3</code> che esegue operazioni aritmetiche sui numeri <code>Double</code>. Creiamo un nuovo valore funzione <code>fc</code> applicando il currying a <code>f</code>. Poi invochiamo entrambe le funzioni con gli stessi argomenti e stampiamo i risultati che, come previsto, sono uguali. Si noti che, in questo caso, non ci sono problemi per quanto riguarda eventuali errori di arrotondamento nei confronti di uguaglianza: entrambe le funzioni invocano lo stesso metodo <code>apply</code>, quindi devono restituire lo stesso valore.

<p>Nella seconda parte dello script sfruttiamo la possibilità di <em>applicare parzialmente</em> gli argomenti delle funzioni curry, creando nuove funzioni fino a quando non li abbiamo applicati tutti. L&#8217;esempio ci aiuta anche a capire la dichiarazione di <code>curry</code> in <code>Function3</code>.

<p>Le funzioni sono associative a destra, quindi un tipo <code>T1 =&gt; T2 =&gt; T3 =&gt; R</code> è equivalente a <code>T1 =&gt; (T2 =&gt; (T3 =&gt; R))</code>, come possiamo vedere nello script. Infatti l&#8217;istruzione <code>val fc1 = fc(2.)</code> invoca <code>fc</code> solo con la prima lista di argomenti (in questo caso, <code>T1</code> corrisponde a <code>Double</code>) e restituisce una <em>nuova</em> funzione di tipo <code>T2 =&gt; (T3 =&gt; R)</code>, nel nostro caso <code>Double =&gt; (Double =&gt; Double)</code>. Successivamente, in <code>val fc2 = fc1(5.)</code>, passiamo il secondo argomento (<code>T2</code>) e otteniamo una nuova funzione di tipo <code>T3 =&gt; R</code>, cioè <code>Double =&gt; Double</code>. Infine, in <code>val answer3 = fc2(4.)</code> passiamo l&#8217;ultimo argomento per calcolare il valore del tipo <code>R</code>, cioè <code>Double</code>.

<blockquote class=note>
<p><span class=u>&#x261E;</span>Un tipo <code>T1 =&gt; T2 =&gt; T3 =&gt; R</code> è equivalente a <code>T1 =&gt; (T2 =&gt; (T3 =&gt; R))</code>. Quando si invoca una funzione di questo tipo con un valore per <code>T1</code>, essa restituisce una nuova funzione di tipo <code>T2 =&gt; (T3 =&gt; R)</code>, e così via.
</blockquote>

<p>Per concludere, dato che le funzioni sono istanze di tratti, è possibile usare i tratti come genitori di altri tipi. Nella libreria Scala, <code>Seq[+A]</code> è una sottoclasse di <code>PartialFunction[Int,A]</code>, che a sua volta è una sottoclasse di <code>(Int) =&gt; A</code>, cioè <code>Function1[Int,A]</code>.

<h3 id=TypeProjections>Proiezioni di tipo</h3>

<p>Le <em>proiezioni di tipo</em> si usano per fare riferimento a una dichiarazione di tipo annidata in un altro tipo.

<pre><code>// <a href=esempi/cap-12/type-projection-script.scala>esempi/cap-12/type-projection-script.scala</a>

trait T {
  type t &lt;: AnyRef
}
class C1 extends T {
  type t = String
}
class C2 extends C1

val ic1: C1#t = "C1"
val ic2: C2#t = "C2"
println(ic1)
println(ic2)</code></pre>

<p>Sia <code>C1#t</code> sia <code>C2#t</code> sono uguali a <code>String</code>. &Egrave; possibile anche fare riferimento al tipo astratto <code>T#t</code>, che però non può essere usato in una dichiarazione, proprio perché astratto.

<h3 id=_singleton_types>Tipi singleton</h3>

<p>Dato un valore <code>v</code> di un sottotipo di <code>AnyRef</code>, compreso <code>null</code>, è possibile ottenere il suo <em>tipo singleton</em> tramite l&#8217;espressione <code>v.type</code>, utilizzabile anche come tipo nelle dichiarazioni. Questa proprietà si rivela utile in rare occasioni per aggirare i problemi dovuti ai tipi dipendenti dal percorso visti nella sezione <a href=#PathDependentTypes>Tipi dipendenti dal percorso</a>. In questi casi il tipo dipendente dal percorso di un oggetto potrebbe sembrare incompatibile con un altro tipo dipendente dal percorso, mentre in effetti i due tipi sono compatibili. Tramite l&#8217;espressione <code>v.type</code> si recupera il tipo singleton, un tipo &#8220;unico&#8221; che elimina la dipendenza dal percorso. I tipi dipendenti dal percorso di due valori <code>v1</code> e <code>v2</code> potrebbero essere diversi, ma il loro tipo singleton può essere lo stesso.

<p>Questo esempio usa il tipo singleton di un valore nella dichiarazione di un altro valore.

<pre><code>class C {
  val x = "Cx"
}
val c = new C
val x: c.x.type = c.x</code></pre>

<h2 id=SelfTypeAnnotations>Annotazioni self-type</h2>

<p>All&#8217;interno di un metodo è possibile usare <code>this</code> per fare riferimento al tipo che ne contiene la definizione, e attraverso il riferimento al tipo accedere a uno dei suoi membri. In quest&#8217;ultimo caso, di solito l&#8217;uso di <code>this</code> non è necessario, ma in alcune occasioni può rivelarsi utile per evitare riferimenti ambigui quando in un determinato ambito sono visibili più valori con lo stesso nome. Per default, il tipo di <code>this</code> è uguale al tipo all&#8217;interno del quale viene usato, ma questa è una condizione niente affatto necessaria.

<p>Le <em>annotazioni self-type</em> permettono di specificare vincoli aggiuntivi sul tipo di <code>this</code> e possono essere usate per creare alias di <code>this</code>. Si consideri per primo quest&#8217;ultimo caso.

<pre><code>// <a href=esempi/cap-12/this-alias-script.scala>esempi/cap-12/this-alias-script.scala</a>

class C1 { self =&gt;
  def talk(message: String) = println("C1.talk: " + message)
  class C2 {
    class C3 {
      def talk(message: String) = self.talk("C3.talk: " + message)
    }
    val c3 = new C3
  }
  val c2 = new C2
}
val c1 = new C1
c1.talk("Ciao")
c1.c2.c3.talk("Mondo")</code></pre>

<p>Questo script stampa il testo seguente.

<pre><samp>C1.talk: Ciao
C1.talk: C3.talk: Mondo</samp></pre>

<p>Al <code>this</code> dell&#8217;ambito più esterno (<code>C1</code>) viene dato l&#8217;alias <code>self</code> per potervi fare riferimento facilmente in <code>C3</code>. Sarebbe possibile usare <code>self</code> in qualsiasi metodo all&#8217;interno del corpo di <code>C1</code> o nei suoi tipi annidati. Si noti che il nome <code>self</code> è arbitrario, ma piuttosto convenzionale; in effetti si potrebbe scrivere <code>this =&gt;</code>, pur essendo assolutamente ridondante.

<p>Se l&#8217;annotazione self-type contiene un tipo, i benefici che ne derivano sono molto diversi.

<pre><code>// <a href=esempi/cap-12/selftype-script.scala>esempi/cap-12/selftype-script.scala</a>

trait Persistence {
  def startPersistence: Unit
}

trait Midtier {
  def startMidtier: Unit
}

trait UI {
  def startUI: Unit
}

trait Database extends Persistence {
  def startPersistence = println("Avvio il database")
}

trait ComputeCluster extends Midtier {
  def startMidtier = println("Avvio il cluster di elaborazione")
}

trait WebUI extends UI {
  def startUI = println("Avvio l'interfaccia web")
}

trait App {
  self: Persistence with Midtier with UI =&gt;

  def run = {
    startPersistence
    startMidtier
    startUI
  }
}

object MyApp extends App with Database with ComputeCluster with WebUI

MyApp.run</code></pre>

<p>Questo script illustra la struttura schematica di un&#8217;infrastruttura in grado di supportare diversi livelli applicativi sotto forma di componenti per la memorizzazione persistente, l&#8217;elaborazione dei dati e l&#8217;interfaccia utente. Esploreremo in maniera approfondita questa metodologia di progettazione dei componenti nel <a href=cap-13.html>capitolo 13</a>. Per ora, ci interessa semplicemente il ruolo delle annotazioni self-type.

<p>Ogni tratto astratto dichiara un metodo di avvio che effettua l&#8217;inizializzazione del componente, ignorando tutte le possibili condizioni di errore. Ogni componente astratto è implementato da un tratto concreto corrispondente anziché da una classe, in modo da poterli usare come mixin. I tratti definiti nello script rappresentano un meccanismo per la persistenza in un database, una sorta di cluster di elaborazione per effettuare le operazioni di logica applicativa e una interfaccia web per l&#8217;utente.

<p>Il tratto <code>App</code> collega i componenti tra loro, avviandoli uno per uno nel metodo <code>run</code>.

<p>La particolare annotazione self-type <code>self: Persistence with Midtier with UI =&gt;</code> ha due effetti pratici.

<ol>
<li>Consente al corpo del tratto di considerare se stesso come un&#8217;istanza di <code>Persistence</code>, <code>Midtier</code> e <code>UI</code>, e quindi di invocare i metodi definiti in quei tipi, proprio come succede nel metodo <code>run</code>, a prescindere dal fatto che, a questo punto, siano effettivamente legati a una definizione.
<li>Obbliga il tipo concreto che mescola questo tratto a mescolare quegli altri tre tratti o i loro discendenti.
</ol>

<p>In altre parole, il tipo <code>self</code> di <code>App</code> specifica le dipendenze dagli altri componenti, che vengono successivamente soddisfatte in <code>MyApp</code> mescolando i tratti concreti per i tre livelli applicativi.

<p>Alternativamente, avremmo potuto definire <code>App</code> sfruttando l&#8217;ereditarietà.

<pre><code>trait App with Persistence with Midtier with UI {
  def run = { &hellip; }
}</code></pre>

<p>In effetti, non ci sarebbero state differenze. Come abbiamo detto, l&#8217;annotazione self-type permette ad <code>App</code> di considerarsi come un tipo <code>Persistence</code>, <i class=baa>&amp;</i>c., e questo è proprio ciò che succede anche quando mescolate un tratto.

<p>Anche se sembrano equivalenti all&#8217;ereditarietà, esistono alcuni casi particolari in cui le annotazioni self-type, per ragioni teoriche, offrono vantaggi unici. In pratica sarebbe possibile usare l&#8217;ereditarietà in quasi tutti i casi, ma per convenzione la si usa quando si desidera indicare che un tipo <em>si comporta come</em> (eredita da) un altro tipo, e si usano le annotazioni self-type quando si vuole esprimere una dipendenza tra un tipo e altri tipi <a href=apa.html#McIver2009>[McIver2009]</a>.

<p>Nel nostro esempio, l&#8217;applicazione non viene considerata come se <em>fosse</em> un&#8217;interfaccia utente, un database, <i class=baa>&amp;</i>c., bensì come una composizione di questi elementi. Si noti che nella maggior parte dei linguaggi orientati agli oggetti questa dipendenza tra componenti verrebbe espressa attraverso i campi, in particolare se il linguaggio non supporta la composizione dei mixin, come Java. Per esempio, si potrebbe scrivere <code>App</code> in Java nel modo che segue (dove, incidentalmente, le interfacce dei componenti sono annidate per evitare di dover creare file separati per ognuna).

<pre><code>// <a href=esempi/cap-12/selftype/JavaApp.java>esempi/cap-12/selftype/JavaApp.java</a>

package selftype;

public abstract class JavaApp {
  public interface Persistence {
    public void startPersistence();
  }

  public interface Midtier {
    public void startMidtier();
  }

  public interface UI {
    public void startUI();
  }

  private Persistence persistence;
  private Midtier midtier;
  private UI ui;

  public JavaApp(Persistence persistence, Midtier midtier, UI ui) {
    this.persistence = persistence;
    this.midtier = midtier;
    this.ui = ui;
  }

  public void run() {
    persistence.startPersistence();
    midtier.startMidtier();
    ui.startUI();
  }
}</code></pre>

<p>&Egrave; certamente possibile scrivere applicazioni in questo modo anche in Scala. Tuttavia, l&#8217;esplicitazione del tipo per la classe corrente trasforma la risoluzione imperativa delle dipendenze, che avviene a tempo di esecuzione tramite il passaggio di oggetti ai costruttori o ai metodi di scrittura dei valori, in una risoluzione dichiarativa che avviene a tempo di compilazione e cattura prima gli eventuali errori. Il paradigma dichiarativo, da cui deriva la programmazione funzionale, permette di esprimere codice più robusto, conciso e chiaro rispetto al paradigma imperativo.

<p>Riprenderemo le annotazioni self-type come modello per la composizione di componenti nel <a href=cap-13.html>capitolo 13</a>, in particolare nelle sezioni <a href=cap-13.html#SelfTypeAnnotationsAndAbstractTypeMembers>Annotazioni self-type e membri tipo astratti</a> e <a href=cap-13.html#DependencyInjectionInScala>L&#8217;iniezione di dipendenza in Scala: il pattern Cake</a>.

<h2 id=StructuralTypes>Tipi strutturali</h2>

<p>I <em>tipi strutturali</em> si possono considerare come un meccanismo type-safe di <em>duck typing</em>, termine usato per indicare il modo in cui funziona la risoluzione dei metodi nei linguaggi dinamicamente tipati. L&#8217;interprete Ruby, per esempio, esegue l&#8217;espressione <code>starFighter.shootWeapons</code> cercando un metodo <code>shootWeapons</code> nell&#8217;oggetto a cui <code>starFighter</code> fa riferimento. Questo metodo, se trovato, potrebbe essere stato definito nella classe usata per istanziare <code>starFighter</code> o in una delle classi genitore o in uno dei moduli &#8220;inclusi&#8221;, oppure potrebbe anche essere stato aggiunto all&#8217;oggetto usando le funzionalità di metaprogrammazione di Ruby. In alternativa, l&#8217;oggetto potrebbe ridefinire il metodo <code>method_missing</code> ed eseguire una particolare operazione quando l&#8217;oggetto riceve il &#8220;messaggio&#8221; <code>shootWeapons</code>.

<p>Scala non supporta questo genere di risoluzione dei metodi, ma vi consente di specificare che un oggetto deve aderire a una certa <em>struttura</em>, cioè contenere certi tipi, campi, o metodi, a prescindere dal suo tipo effettivo. Abbiamo incontrato i tipi strutturali per la prima volta all&#8217;inizio del <a href=cap-4.html>capitolo 4</a>, analizzando una variazione del pattern Observer come esempio.

<pre><code>// <a href=esempi/cap-4/observer/observer.scala>esempi/cap-4/observer/observer.scala</a>

package observer

trait Subject {
  type Observer = { def receiveUpdate(subject: Any) }

  private var observers = List[Observer]()
  def addObserver(observer:Observer) = observers ::= observer
  def notifyObservers = observers foreach (_.receiveUpdate(this))
}</code></pre>

<p>La dichiarazione <code>type Observer = { def receiveUpdate(subject: Any) }</code> richiede che qualsiasi osservatore valido sia dotato del metodo <code>receiveUpdate</code>. Il vero tipo del particolare osservatore non è importante.

<p>I tipi strutturali hanno il pregio di minimizzare l&#8217;interfaccia tra due entità. Nel nostro esempio, l&#8217;accoppiamento consiste solo nella firma di un singolo metodo anziché in un tipo come nel caso di un tratto condiviso. Purtroppo i tipi strutturali non riescono a eliminare le dipendenze da <em>nomi</em> particolari. Se un nome è arbitrario, ci interessa solo l&#8217;intento che nasconde. Nel nostro esempio, è possibile evitare la dipendenza dal nome di un singolo metodo usando un oggetto funzione al posto del tipo strutturale, proprio come è stato fatto nella sezione <a href=cap-6.html#OverridingAbstractTypes>Ridefinire i tipi astratti</a> del capitolo 6.

<p>D&#8217;altra parte, se il nome viene adottato come una specie di convenzione universale, la dipendenza ha maggior valore. Per esempio, <code>foreach</code> è un nome molto comune nella libreria Scala e ha un particolare significato, quindi definire un tipo strutturale sulla base di <code>foreach</code> anziché usare una funzione anonima di qualche genere potrebbe essere vantaggioso per comunicarne l&#8217;intento al programmatore.

<h2 id=ExistentialTypes>Tipi esistenziali</h2>

<p>I <em>tipi esistenziali</em> sono astrazioni usate per individuare un tipo disinteressandosi della sua reale identità: permettono di &#8220;indicare&#8221; la presenza di un tipo senza specificare estattamente quale sia, di solito perché non lo si conosce e non è necessario conoscerlo nel contesto in cui viene usata l&#8217;espressione che lo contiene.

<p>I tipi esistenziali sono particolarmente utili per interfacciarsi al sistema di tipi di Java in tre casi.

<ol>
<li>Quando si usano i generici, poiché i loro parametri di tipo vengono &#8220;cancellati&#8221; a livello di bytecode (tramite un procedimento chiamato <em>cancellazione di tipo</em>), come nel caso in cui si crea un&#8217;istanza di <code>List[Int]</code> e il tipo <code>Int</code> non è disponibile nel bytecode.
<li>Quando si incontra un tipo &#8220;grezzo&#8221; (in inglese, <em>raw type</em>), come nelle librerie precedenti a Java 5 dove le collezioni non avevano parametri di tipo. In questo caso, tutti i parametri di tipo sono effettivamente <code>Object</code>.
<li>Quando Java usa le wildcard per esprimere il comportamento di varianza nel punto in cui i generici vengono <em>usati</em>, poiché l&#8217;effettivo tipo rappresentato dalla wildcard è sconosciuto. (Ne abbiamo già parlato nella sezione <a href=#VarianceUnderInheritance>Varianza in caso di ereditarietà</a> di questo capitolo.)
</ol>

<p>Si consideri il caso del pattern matching su oggetti di tipo <code>List[A]</code>. L&#8217;idea di scrivere codice come quello riportato di seguito potrebbe essere seducente.

<pre><code>// <a href=esempi/cap-12/type-erasure-wont-work.scala>esempi/cap-12/type-erasure-wont-work.scala</a>
// Attenzione: non funziona come potreste aspettarvi

object ProcessList {
  def apply[B](list: List[B]) = list match {
    case lInt:    List[Int]    =&gt; // fai qualcosa
    case lDouble: List[Double] =&gt; // fai qualcosa
    case lString: List[String] =&gt; // fai qualcosa
    case _                     =&gt; // comportamento predefinito
  }
}</code></pre>

<p>Se però provate a compilare lo script con l&#8217;opzione <code>-unchecked</code> sulla <abbr>JVM</abbr> otterrete alcuni messaggi di avvertimento sul mancato controllo di tipo per parametri come <code>Int</code>, a causa della cancellazione che impedisce al compilatore di distinguere tra loro i tipi di lista elencati. Nemmeno i <em>manifest</em> esaminati in precedenza possono essere d&#8217;aiuto in questo caso, perché non sono in grado di recuperare il tipo cancellato di <code>B</code>.

<p>Abbiamo già visto che la soluzione migliore da adottare con il pattern matching consiste nel concentrarsi sul fatto di avere una lista ed evitare di provare a determinare il parametro di tipo &#8220;perduto&#8221; per l&#8217;istanza di lista. Allo scopo di salvaguardare la sicurezza dei tipi, è necessario specificare che la lista ha un parametro, il quale però, essendo ignoto, verrà indicato con il carattere <code>_</code> usato come wildcard per il parametro di tipo, nel modo illustrato dall&#8217;esempio seguente.

<pre><code>case l: List[_] =&gt; // fai qualcosa di "generico" con la lista</code></pre>

<p>Quando viene impiegato in un contesto tipato come questo, <code>List[_]</code> è in realtà una forma abbreviata per il <em>tipo esistenziale</em> <code>List[T] forSome { type T }</code>. Questo è il caso più generale: indica che il parametro di tipo della lista potrebbe essere qualsiasi tipo. Ecco alcuni altri esempi che mostrano come usare i limiti sui tipi.

<div class=table id=existential-type-examples-table>
<p class=tt>Tabella 12.2. Esempi di tipi esistenziali
<table summary="Esempi di tipi esistenziali." border=0>
<colgroup>
<col align=left>
<col align=left>
<col align=left>
</colgroup>
<thead valign=top><tr>
<th align=left valign=top>Sintassi abbreviata
<th align=left valign=top>Sintassi completa
<th align=left valign=top>Descrizione
</thead>
<tbody valign=top>
<tr>
<td align=left valign=top><p><code>List[_]</code>
<td align=left valign=top><p><code>List[T] forSome { type T }</code>
<td align=left valign=top><p><code>T</code> può essere qualunque sottotipo di <code>Any</code>.
<tr>
<td align=left valign=top><p><code>List[_ &lt;: scala.actors.AbstractActor]</code>
<td align=left valign=top><p><code>List[T] forSome { type T &lt;: scala.actors.AbstractActor }</code>
<td align=left valign=top><p><code>T</code> può essere qualunque sottotipo di <code>AbstractActor</code>.
<tr>
<td align=left valign=top><p><code>List[_ &gt;: MyFancyActor &lt;: scala.actors.AbstractActor]</code>
<td align=left valign=top><p><code>List[T] forSome { type T &gt;: MyFancyActor &lt;: scala.actors.AbstractActor }</code>
<td align=left valign=top><p><code>T</code> può essere qualunque sottotipo di <code>AbstractActor</code> fino al sottotipo <code>MyFancyActor</code> incluso.
</tbody>
</table>
</div>

<p>Se si considerano le somiglianze tra Scala e Java nella sintassi usata per i generici, è possibile notare che la struttura di un&#8217;espressione come <code>java.util.List[_ &lt;: scala.actors.AbstractActor]</code> corrisponde a quella dell&#8217;espressione di varianza Java <code>java.util.List&lt;? extends scala.actors.AbstractActor&gt;</code>. In effetti, le due dichiarazioni hanno lo stesso effetto. Anche se abbiamo detto che in Scala il comportamento di varianza viene definito nella dichiarazione, si possono usare le espressioni di tipo esistenziale per definire il comportamento di varianza nella invocazione. Questa pratica, tuttavia, viene sconsigliata per le ragioni discusse in precedenza.

<p>La sintassi completa con <code>forSome</code> non viene usata molto spesso nel codice Scala, perché i tipi esistenziali esistono principalmente per supportare i generici Java preservando nel contempo la correttezza nel sistema di tipi di Scala. L&#8217;inferenza di tipo nasconde i dettagli nella maggior parte dei contesti. Quando si lavora con i tipi di Scala, è preferibile usare gli altri costrutti di tipo visti in questo capitolo anziché ricorrere ai tipi esistenziali.

<h2 id=InfiniteDataStructuresAndLaziness>Strutture dati infinite ed esecuzione ritardata</h2>

<p>Abbiamo descritto i valori ritardati nel <a href=cap-8.html>capitolo 8</a>. I linguaggi funzionali la cui esecuzione è ritardata per default, come Haskell, sono maggiormente agevolati nel supportare strutture dati <em>infinite</em>.

<p>Si consideri come esempio il metodo <code>fib</code> seguente che calcola il numero di Fibonacci per <code>n</code> in una sequenza di Fibonacci infinita.

<pre><code>def fib(n: Int): Int = n match {
  case 0 | 1 =&gt; n
  case _ =&gt; fib(n-1) + fib(n-2)
}</code></pre>

<p>Se Scala fosse un linguaggio a esecuzione puramente ritardata, potremmo immaginare di scrivere una definizione della sequenza di Fibonacci come quella che segue evitando la creazione di un ciclo infinito.

<pre><code>fibonacci_sequence = for (i &lt;- 0 to infinity) yield fib(i)</code></pre>

<p>L&#8217;esecuzione di Scala non è ritardata per default (né esiste alcun valore o parola chiave <code>infinity</code>) ma la libreria contiene una classe <code>Stream</code> che supporta la valutazione ritardata e quindi può supportare strutture dati infinite; la sfrutteremo tra un momento per presentarvi una nuova implementazione della sequenza di Fibonacci. Prima, però, ecco un esempio più semplice che usa quella classe per rappresentare tutti gli interi positivi, tutti gli interi dispari positivi e tutti gli interi pari positivi.

<pre><code>// <a href=esempi/cap-12/lazy-ints-script.scala>esempi/cap-12/lazy-ints-script.scala</a>

def from(n: Int): Stream[Int] = Stream.cons(n, from(n+1))

lazy val ints = from(0)
lazy val odds = ints.filter(_ % 2 == 1)
lazy val evens = ints.filter(_ % 2 == 0)

odds.take(10).print
evens.take(10).print</code></pre>

<p>Questo script produce il risultato seguente.

<pre><samp>1, 3, 5, 7, 9, 11, 13, 15, 17, 19, Stream.empty
0, 2, 4, 6, 8, 10, 12, 14, 16, 18, Stream.empty</samp></pre>

<p>Si noti che il metodo <code>from</code>, utilizzato per definire <code>ints</code>, è ricorsivo e non termina mai. <code>Stream.cons</code> è un oggetto dotato di un metodo <code>apply</code> che è analogo al metodo <code>::</code> (chiamato &#8220;cons&#8221;) di <code>List</code>: restituisce un nuovo flusso, cioè una nuova istanza di <code>Stream</code>, con il primo argomento come testa e con il secondo argomento, un&#8217;altra istanza di <code>Stream</code>, come coda. I valori ritardati <code>odds</code> e <code>evens</code> vengono calcolati filtrando <code>ints</code>.

<p>Una volta definiti gli insiemi di numeri, usiamo il metodo <code>take</code> per recuperare una nuova istanza di <code>Stream</code> della dimensione fissa specificata, <code>10</code> in questo caso, e poi la stampiamo con il metodo <code>print</code>, generando i primi dieci elementi seguiti da <code>Stream.empty</code> quando si arriva al termine del flusso.

<p>Tornando alla sequenza di Fibonacci, ne esiste una famosa definizione basata su sequenze infinite ritardate che sfruttano l&#8217;operazione <code>zip</code> (si veda per esempio <a href=apa.html#Abelson1996>[Abelson1996]</a>). La nostra analisi di questa definizione in Scala è adattata da <a href=apa.html#Ortiz2007>[Ortiz2007]</a>.

<pre><code>// <a href=esempi/cap-12/lazy-fibonacci-script.scala>esempi/cap-12/lazy-fibonacci-script.scala</a>

lazy val fib: Stream[Int] =
  Stream.cons(0, Stream.cons(1, fib.zip(fib.tail).map(p =&gt; p._1 + p._2)))

fib.take(10).print</code></pre>

<p>Lo script produce il risultato seguente.

<pre><samp>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, Stream.empty</samp></pre>

<p>Come nella nostra definizione iterativa all&#8217;inizio di questa sezione, abbiamo esplicitamente specificato i primi due valori, <code>0</code> e <code>1</code>. Il resto dei numeri viene calcolato usando <code>zip</code> e sfruttando il fatto che <code>fib(n) = fib(n-1) + fib(n-2)</code> per <code>n &gt; 1</code>.

<p>L&#8217;invocazione <code>fib.zip(fib.tail)</code> crea un nuovo flusso di tuple che contengono gli elementi di <code>fib</code> in prima posizione e gli elementi di <code>fib.tail</code> in seconda posizione. Per ottenere un flusso di singoli numeri interi, mappiamo il flusso di tuple in un flusso di <code>Int</code> sommando tra loro gli elementi di ogni tupla. Ecco le tuple calcolate.

<pre><samp>(0,1), (1,1), (1,2), (2,3), (3,5), (5,8), (8,13), (13,21), (21,34), &hellip;</samp></pre>

<p>Si noti che ogni secondo elemento di una tupla è il numero che, nella sequenza di Fibonacci, segue il numero del corrispondente primo elemento. Sommando tra loro i numeri di ogni tupla, otteniamo la sequenza seguente.

<pre><samp>1, 2, 3, 5, 8, 13, 21, 34, 55, &hellip;</samp></pre>

<p>Concatenando il flusso a <code>0</code> e <code>1</code>, otteniamo la sequenza di Fibonacci.

<pre><samp>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, &hellip;</samp></pre>

<p>Un altro tipo di Scala a valutazione ritardata, anche se finito, è <code>Range</code>, usato tipicamente per rappresentare intervalli letterali come <code>1 to 1000</code>, che pur essendo così ampio non consuma troppe risorse proprio grazie alla valutazione ritardata. Tuttavia, questa caratteristica può portare a un certo genere di problemi complicati a meno di non seguire le indicazioni di <a href=apa.html#Smith2009b>[Smith2009b]</a>, che riprendiamo in questa sede usando lo stesso esempio: una funzione che restituisce una sequenza di tre numeri interi casuali.

<pre><code>// <a href=esempi/cap-12/lazy-range-danger-script.scala>esempi/cap-12/lazy-range-danger-script.scala</a>

def mkRandomInts() = {
  val randInts = for {
    i &lt;- 1 to 3
    val rand = i + (new scala.util.Random).nextInt
  } yield rand
  randInts
}
val ints1 = mkRandomInts

println("Invoco first sull'istanza di Seq:")
for (i &lt;- 1 to 3) {
  println( ints1.first)
}

val ints2 = ints1.toList
println("Invoco first sulla Lista creata dall'istanza di Seq:")
for (i &lt;- 1 to 3) {
  println( ints2.first)
}</code></pre>

<p>Ecco il testo che viene stampato eseguendo lo script. I valori varieranno da esecuzione a esecuzione.

<pre><samp>Invoco first sull'istanza di Seq:
-1532554511
-1532939260
-1532939260
Invoco first sulla lista creata dall'istanza di Seq:
-1537171498
-1537171498
-1537171498</samp></pre>

<p>Si noti che l&#8217;invocazione di <code>first</code> sulla sequenza non restituisce sempre lo stesso valore. Il motivo è che l&#8217;intervallo all&#8217;inizio dell&#8217;espressione <code>for</code> obbliga l&#8217;intera sequenza a essere ritardata, e quindi ne innesca una nuova valutazione a <em>ogni</em> invocazione di <code>first</code>: così, il primo valore nella sequenza effettivamente cambia, dato che <code>Random</code> restituisce un numero differente ogni volta (almeno lo farà se tra un&#8217;invocazione e l&#8217;altra trascorre un intervallo di tempo sufficiente).

<p>Tuttavia, l&#8217;invocazione di <code>toList</code> sulla sequenza innesca la valutazione dell&#8217;intero intervallo e crea una lista <em>rigorosa</em>, in cui tutti gli elementi sono calcolati.

<blockquote class=warning>
<p><span class=u>&#x2762;</span>Evitate di usare gli intervalli in costrutti del tipo <code>for (&hellip;) yield x</code>, mentre potete usarli in quelli del tipo <code>for (&hellip;) {&hellip;}</code>.
</blockquote>

<p>Infine, la versione 2.8 di Scala doterà tutte le collezioni di un metodo <code>force</code> che ne farà diventare <em>rigorose</em> le istanze innescando la valutazione di tutti gli elementi.

<h2 id=_recap_and_what_8217_s_next_5>Riepilogo, e poi?</h2>

<p>Va ricordato che non è necessario padroneggiare le complessità del ricco sistema di tipi di Scala per usare efficacemente il linguaggio. Man mano che prenderete confidenza, comincerete a creare librerie potenti e sofisticate che incrementeranno la vostra produttività.

<p>La specifica del linguaggio <a href=apa.html#ScalaSpec2009>[ScalaSpec2009]</a> descrive i dettagli formali del sistema di tipi. Come qualsiasi specifica, può risultare difficile da leggere, ma vale la pena farlo se desiderate conoscere il sistema di tipi in profondità. Esiste anche una lunga serie di articoli sul sistema di tipi di Scala, che potete rintracciare a partire dal sito ufficiale del linguaggio all&#8217;indirizzo <a class=url href=http://scala-lang.org>http://scala-lang.org</a>.

<p>Nei prossimi due capitoli ci occuperemo di analizzare gli aspetti pratici della progettazione di software e gli strumenti e le librerie per sviluppare applicazioni in Scala.

<p class=v><a rel=prev href=cap-11.html title='indietro a &#8220;Linguaggi domain-specific in Scala&#8221;'><span class=u>&#x261C;</span></a> <a rel=next href=cap-13.html title='avanti a &#8220;La progettazione di applicazioni&#8221;'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2008&ndash;9 O&#8217;Reilly Media<br>
&copy; 2009&ndash;10 Giulio Piancastelli per la traduzione italiana
</div>
